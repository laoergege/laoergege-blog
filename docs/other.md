

接下来，通过一个系统 I/O 调用过程分层来将同步/异步、阻塞/非阻塞串联起来理解，因为要让一个进程进入阻塞的状态, 要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是它调用 System Call, 而 System Call 因为一般会涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为阻塞状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回就绪状态。

一个 系统 I/O 调用过程需要经历：
1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A 的业务代码

1 和 6 这一层都是我们的用户进程的代码，我

3和4，操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 

但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

编程层次







3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。




反应器设计模板的目的是避免为每个消息、请求和连接创建线程的常见问题。它接收来自多个处理程序的事件，并按顺序将它们分发给相应的事件处理程序。原则上，标准 Reactor 允许应用程序在同时发生事件的情况下运行，同时保持单线程处理的简单性。它通常会使用非阻塞同步 I/O（查看I/O 模型中的多路复用）。更有趣的是Proactor 模式。它是 Reactor 模式的异步版本。它通常使用操作系统提供的真正异步 I/O 操作（查看I/O 模型中的 AIO）。














js debug
- debugger client
  - cmd
    - node debugger
  - ui
    - chrome devtool
    - vscode debugger



- 系统路径大小写及系统分割符号问题











“With” 和 “eval” — ECMAScript中的动态作用域
，使用with和eval虽然加强了静态作用域，但相比之下，with和eval在实现上也可能会削弱变量查找和词法环境储存的性能（译注：因为这相当于扩充了当前作用域，增加了存储消耗和查找范围）。因此在ES5中，with在严格模式下被移除了，此外严格模式下的eval方法不再会在当前上下文创建变量。所以，ES5的严格模式下是完全遵守词法环境的实现。


 ES（译注：ECMAScript，下同）中的词法环境由两部分组成：一个环境记录项和一个对外部环境的引用。

- 执行上下文
  - 变量环境组件VariableEnvrionment
    - 变量声明和函数声明的初始储存位置
  - 词法环境组件LexicalEnvrionment
    - 词法环境组件和变量环境组件最初是同一个值，词法环境组件复制于变量环境，变量环境组件永远不会变，而词法环境组件可能会变。
    - 词法环境组件的改变发生在代码执行阶段

执行上下文的变量环境组件还是词法环境组件都是属于词法环境的概念

with语句和catch语句会在它们的代码执行阶段替代掉当前的执行上下文环境







- Hooks 也是用闭包，跟 vue composition 用的闭包，差别在于：后者可以修改闭包里的 reactivity state，而前者要求保持 immutable。
- 其实另一个原因是 concurrent mode，hooks 这种重复执行的方式使得每次 render 都顺道把这次 render 的 state 也一起存在闭包里了，可以减少 concurrent unsafe code 的概率（然而增加了写出一些正常用例的难度，比如需要 useRef 的情况）
- Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
- React 在组件方面的心智模型是「副作用受上下文托管的纯函数」
- Props 无论是跟着 View 销毁还是函数参数总是暂时性的输入，States 无论跟着组件实例还是置外总必须是持久化的，至于怎么判断更新
- 变更集
  - 依赖追踪
  - 引用不等性
- useState背后是全局链表黑魔法





- 如何实现跨语言调用
  - 进程间通信
    - 通信协议

- vscode remote
  - [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh#_debugging-on-the-ssh-host)
  - [Remote - Containers](https://code.visualstudio.com/docs/remote/containers)
    - [附加到正在运行的容器](https://code.visualstudio.com/docs/remote/attach-container)
    - [创建开发容器](https://code.visualstudio.com/docs/remote/create-dev-container)
    - [高级容器配置场景](https://code.visualstudio.com/remote/advancedcontainers/overview)
  - GitHub Codespaces
  - The VS Code Server 
  - Remote Repositories





## 框架

- ng
  - 视图层变更检测触发机制：事件驱动
- vue
  - 视图层变更检测触发机制：数据驱动（数据劫持）
- react
- vue/react没有抛弃面向对象设计，其本身的API也远远谈不上足够FP，其底层实现也是mutable的。
- 我的观点依然是:函数式提供底层抽象能力，面向对象提供业务组织能力。
- 函数式负责提高复用能力，简化代码实现，提升代码的信息密度。
- 面向对象负责描述组件/模块之间的关系和业务逻辑，提高代码可读性，致力于显式地充分暴露业务客观存在的复杂度。



- react 为什么函数式开发范式
  - 函数式的数据不可变契合 react 原理
  - 并发
  - this.state 问题
  - React 并发模式下很容易出现数据竞态（data race）的问题。
    - this.state 是一个对象，每次更新局部，更新时也可新加 state 进去，这就让 state 整体比较混沌。
    - 使用高阶组件等模式时，会造成 this.props 中的数据来源不透明，同样混沌。
    - 因为 this 魔法指针的存在，很容易挂一大堆东西上去，互相随意调用，就会让逻辑缠绕。
  - 复用状态逻辑
    - 提供逻辑共享，以替代高阶组件。
  - 逻辑关注点
  - algebraic effects

- 框架体系不同
  - Vue
    - 组件语义：基于响应式的对象
    - Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
    - 接近大家习惯的 JS
  - React
    - 函数
    - 副作用受控的「执行上下文（evaluation context）」
    - React 在组件方面的心智模型是「副作用受上下文托管的纯函数」

## 容器

### 容器突然被杀死
   
1. 容器内的主进程已成功结束
2. 交互程序的标准流没用附加管道或者终端
3. 收到关闭信号，如 `Ctrl+C`
4. 守护进程重启
5. docker stop
6. 系统杀死

7. 查看日志
8. 检查容器的状态，如退出状态码
9. 从相同的失败映像创建和启动容器，并使用 shell 覆盖入口sh点

## 语言

命令式编程是面向计算机硬件的抽象：
- 变量（对应着存储单元）
- 赋值语句（获取，存储指令）
- 表达式（内存引用和算术运算）
- 控制语句（跳转指令）
  - 分支
  - 循环
- 函数（过程）
一句话，命令式程序就是一个冯诺依曼机的指令序列。


## 程序设计语言

- 具有图灵完备性的计算机语言，就被称为图灵完备语言
  - “图灵完备”指的是语言指定的数据操作规则能够实现图灵机的全部功能
  - 图灵机是所有程序设计语言最底层的模型
  - 今天接触到的程序设计语言都是图灵完备的
- 程序设计语言发展简史
  - 机器语言
  - 汇编语言：对机器指令语义化封装
    - 缺点：不同厂商具有各自的 CPU 指令集
  - 高级程序设计语言：程序设计语言的发展就是一个“逐步远离计算机硬件，向着待解决的问题靠近”的过程
    - 屏蔽底层计算机硬件细节：如 C 语言
    - 类型系统：对内存抽象
      - 泛型
      - 动态语言
    - 内存管理
      - 垃圾回收机制
    - 如何组织程序
      - 结构化
      - 面向对象
    - 多核：高并发
      - 并发模型、异步模型
      - 内存安全
    - 函数式编程的程序设计语言
      - 关注如何解决问题，如何一层层构建抽象
      - 并发安全
    - 语言表达力
      - 程序设计语言的一个重要发展趋势：声明式编程
      - DSL（Domain Specific Language，简称 DSL），它是一种用于某个特定领域的程序设计语言
        - DSL 不必做到图灵完备，它只要做到满足特定领域的业务需求，就足以缩短问题和解决方案之间的距离，降低理解的门槛
        - DSL 分类：区别 DSL 采用的是不是宿主语言
          - 外部 DSL 
          - 内部 DSL：本质就是一个程序库，**将意图与实现分离开来**
- 学习一门新语言
  - 首先是学习语法（Syntax），
  - 然后学习程序库（Library），
  - 之后再学习运行时（Runtime）

## 源码阅读技巧

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。你对细节部分的了解会随着你对项目的深入而逐渐增加。而有了主线后，你就有了着力点，就可以不断深入了。

尽量忽略其他不相干 case 情况，保持主逻辑功能流程分析
**这里有个小技巧：看源码过程一般建议关注主线逻辑，像各种特殊情况可通过注释、issue 或者测试用例查看原由**。


1. 理解功能需求
2. 实现猜想
3. 功能源码主流程 debugger
4. 源码细节
   1. 看 issue
   2. 看测试用例


## 并发编程体系

- 语言分类
  - 编译型 vs 解释型
  - 强类型 vs 弱类型：对变量类型检查的程度，隐式转换
  - 静态类型 vs 动态类型：类型检查发生的时机、变量可动态类型赋值
- 编程：CPU 计算 + IO 调用
- IO
  - 内存
  - 网络
  - I/O设备
    - 磁盘
- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- 调度模式
  - 抢占式调度
  - 协作式调度
- 并发模型
  - 设计要素
    - 粒度
      - 指令
      - 函数
      - 程序
    - 调度
    - 通信
      - 共享内存
      - 消息传递
        - Actor
        - CSP
    - 同步
    - 编程范式
  - 编程范式
    - 线程模型
      - 多线程 + 同步原语 + 阻塞IO
    - 异步模型（事件驱动）
      - 事件驱动
        - 在合作型多任务处理中，总有一个处理内核负责所有I/O处理。其在设计模式中称为反应器模式
      - 模型
        - 单线程事件循环 + 异步回调队列
        - 协程模型
          - 特点
            - 协程就是用户态线程。协程的调度完全由开发者进行控制，因此实现协程的关键也就是实现一个用户态线程的调度器。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在 IO 上的性能瓶颈。
            - 框架或者编程语言将阻塞操作转为无阻塞，同时将其控制权交到其他的执行线程中
          - 按调用栈分类（由于协程必须支持 挂起/恢复，因此对于挂起点的状态保存就显得极其关键。）
            - 有栈协程（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈
            - 无栈协程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。
          - 按调度方式分类
            - 对称协程（Symmetric Coroutine）：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。对称协程有自己独立的调度器，除了挂起是由自己主动让出，它更像一个操作系统的原生线程，协程的调度运行完全取决于自己的调度器，在一个协程挂起后可以调度任何一个协程。
            - 非对称协程（Asymmetric Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。
              - 通过语法 `yield`、`await` 显示协作
          - 范式
            - CSP
            - Actor

## 其他

类型是一种对内存的解释方式
    - class/struct 是把有相关性的数据存放到一起的一种数据组织方式



- 异步
  - callback
  - promise
  - 响应式编程


了解指令是如何执行的：
运行机制和字节码执行
基于栈 vs 基于寄存器


“语言设计就是程序库设计”和“程序库设计就是语言设计” react 确实把自己当做语言造