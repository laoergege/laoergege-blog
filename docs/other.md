

接下来，通过一个系统 I/O 调用过程分层来将同步/异步、阻塞/非阻塞串联起来理解，因为要让一个进程进入阻塞的状态, 要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是它调用 System Call, 而 System Call 因为一般会涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为阻塞状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回就绪状态。

一个 系统 I/O 调用过程需要经历：
1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A 的业务代码

1 和 6 这一层都是我们的用户进程的代码，我

3和4，操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 

但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

编程层次







3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。




- 语言分类
  - 编译型 vs 解释型
  - 强类型 vs 弱类型：对变量类型检查的程度，隐式转换
  - 静态类型 vs 动态类型：类型检查发生的时机、变量可动态类型赋值
- 编程：CPU 计算 + IO 调用
- IO
  - 内存
  - 网络
  - I/O设备
    - 磁盘
- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- 调度模式
  - 抢占式调度
  - 协作式调度
- 并发模型
  - 设计要素
    - 粒度
      - 指令
      - 函数
      - 程序
    - 调度
    - 通信
      - 共享内存
      - 消息传递
        - Actor
        - CSP
    - 同步
    - 编程范式
  - 编程范式
    - 线程模型
      - 多线程 + 同步原语 + 阻塞IO
    - 异步模型（事件驱动）
      - 事件驱动
        - 在合作型多任务处理中，总有一个处理内核负责所有I/O处理。其在设计模式中称为反应器模式
      - 模型
        - 单线程事件循环 + 异步回调队列
        - 协程模型
          - 特点
            - 协程就是用户态线程。协程的调度完全由开发者进行控制，因此实现协程的关键也就是实现一个用户态线程的调度器。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在 IO 上的性能瓶颈。
            - 框架或者编程语言将阻塞操作转为无阻塞，同时将其控制权交到其他的执行线程中
          - 按调用栈分类（由于协程必须支持 挂起/恢复，因此对于挂起点的状态保存就显得极其关键。）
            - 有栈协程（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈
            - 无栈协程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。
          - 按调度方式分类
            - 对称协程（Symmetric Coroutine）：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。对称协程有自己独立的调度器，除了挂起是由自己主动让出，它更像一个操作系统的原生线程，协程的调度运行完全取决于自己的调度器，在一个协程挂起后可以调度任何一个协程。
            - 非对称协程（Asymmetric Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。
              - 通过语法 `yield`、`await` 显示协作
          - 范式
            - CSP
            - Actor






反应器设计模板的目的是避免为每个消息、请求和连接创建线程的常见问题。它接收来自多个处理程序的事件，并按顺序将它们分发给相应的事件处理程序。原则上，标准 Reactor 允许应用程序在同时发生事件的情况下运行，同时保持单线程处理的简单性。它通常会使用非阻塞同步 I/O（查看I/O 模型中的多路复用）。更有趣的是Proactor 模式。它是 Reactor 模式的异步版本。它通常使用操作系统提供的真正异步 I/O 操作（查看I/O 模型中的 AIO）。










1. 理解功能需求
2. 实现猜想
3. 功能源码主流程 debugger
4. 源码细节
   1. 看 issue
   2. 看测试用例



js debug
- debugger client
  - cmd
    - node debugger
  - ui
    - chrome devtool
    - vscode debugger



- 系统路径大小写及系统分割符号问题





尽量忽略其他不相干 case 情况，保持主逻辑功能流程分析
**这里有个小技巧：看源码过程一般建议关注主线逻辑，像各种特殊情况可通过注释、issue 或者测试用例查看原由**。




采用静态（词法）作用域的变量就叫词法变量。
词法“环境”一词指的是在变量或函数在定义时围着它的词法内容，即实际代码中围着它的最近的代码块或是全局环境：


“With” 和 “eval” — ECMAScript中的动态作用域
，使用with和eval虽然加强了静态作用域，但相比之下，with和eval在实现上也可能会削弱变量查找和词法环境储存的性能（译注：因为这相当于扩充了当前作用域，增加了存储消耗和查找范围）。因此在ES5中，with在严格模式下被移除了，此外严格模式下的eval方法不再会在当前上下文创建变量。所以，ES5的严格模式下是完全遵守词法环境的实现。


 ES（译注：ECMAScript，下同）中的词法环境由两部分组成：一个环境记录项和一个对外部环境的引用。

- 执行上下文
  - 变量环境组件VariableEnvrionment
    - 变量声明和函数声明的初始储存位置
  - 词法环境组件LexicalEnvrionment
    - 词法环境组件和变量环境组件最初是同一个值，词法环境组件复制于变量环境，变量环境组件永远不会变，而词法环境组件可能会变。
    - 词法环境组件的改变发生在代码执行阶段

执行上下文的变量环境组件还是词法环境组件都是属于词法环境的概念

with语句和catch语句会在它们的代码执行阶段替代掉当前的执行上下文环境







- Hooks 也是用闭包，跟 vue composition 用的闭包，差别在于：后者可以修改闭包里的 reactivity state，而前者要求保持 immutable。
- 其实另一个原因是 concurrent mode，hooks 这种重复执行的方式使得每次 render 都顺道把这次 render 的 state 也一起存在闭包里了，可以减少 concurrent unsafe code 的概率（然而增加了写出一些正常用例的难度，比如需要 useRef 的情况）
- Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
- React 在组件方面的心智模型是「副作用受上下文托管的纯函数」
- Props 无论是跟着 View 销毁还是函数参数总是暂时性的输入，States 无论跟着组件实例还是置外总必须是持久化的，至于怎么判断更新
- 变更集
  - 依赖追踪
  - 引用不等性
- useState背后是全局链表黑魔法





- 如何实现跨语言调用
  - 进程间通信
    - 通信协议

- vscode remote
  - [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh#_debugging-on-the-ssh-host)
  - [Remote - Containers](https://code.visualstudio.com/docs/remote/containers)
    - [附加到正在运行的容器](https://code.visualstudio.com/docs/remote/attach-container)
    - [创建开发容器](https://code.visualstudio.com/docs/remote/create-dev-container)
    - [高级容器配置场景](https://code.visualstudio.com/remote/advancedcontainers/overview)
  - GitHub Codespaces
  - The VS Code Server 
  - Remote Repositories







- ng
  - 视图层变更检测触发机制：事件驱动
- vue
  - 视图层变更检测触发机制：数据驱动（数据劫持）
- react
- vue/react没有抛弃面向对象设计，其本身的API也远远谈不上足够FP，其底层实现也是mutable的。
- 我的观点依然是:函数式提供底层抽象能力，面向对象提供业务组织能力。
- 函数式负责提高复用能力，简化代码实现，提升代码的信息密度。
- 面向对象负责描述组件/模块之间的关系和业务逻辑，提高代码可读性，致力于显式地充分暴露业务客观存在的复杂度。



## 容器

### 容器突然被杀死
   
1. 容器内的主进程已成功结束
2. 交互程序的标准流没用附加管道或者终端
3. 收到关闭信号，如 `Ctrl+C`
4. 守护进程重启
5. docker stop
6. 系统杀死

7. 查看日志
8. 检查容器的状态，如退出状态码
9. 从相同的失败映像创建和启动容器，并使用 shell 覆盖入口sh点