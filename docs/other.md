
## 操作系统

- 进程状态：阻塞、非阻塞
- 阻塞
  - 主动阻塞
  - IO 调用
    - IO 调用模型

### 一个 系统 I/O 调用过程需要经历

1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A 的业务代码

1 和 6 这一层都是我们的用户进程的代码

3和4，操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 

但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞 I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。

## vscode

- vscode remote
  - [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh#_debugging-on-the-ssh-host)
  - [Remote - Containers](https://code.visualstudio.com/docs/remote/containers)
    - [附加到正在运行的容器](https://code.visualstudio.com/docs/remote/attach-container)
    - [创建开发容器](https://code.visualstudio.com/docs/remote/create-dev-container)
    - [高级容器配置场景](https://code.visualstudio.com/remote/advancedcontainers/overview)
  - GitHub Codespaces
  - The VS Code Server 
  - Remote Repositories

## 框架

- 前端框架设计
  - 组件化
  - 响应式
- nuxt = CSR + SSR + SSG + ESR + ISR
  - 架构
    - 视图层 vue + vue-router
    - 服务层 Nitro(为 Node.js、Deno、Workers 等提供跨平台支持)
    - 构建层 vite + esbuild
- diff
  - 同层对比
  - type 变了就不再对比子节点
  - 移动：复用元素、尽量减少创建新元素
    - 判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的
    - 每个节点都是有唯一的标识 key，利用 key 复用
    - vue2 双端对比、vue3 最小递增子序列


vue和react都抛弃了基于class组织组件的模式，是为了解决逻辑复用带来的命名冲突问题以及依赖注入问题。


- Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
- React 在组件方面的心智模型是「副作用受上下文托管的纯函数」
- Props 无论是跟着 View 销毁还是函数参数总是暂时性的输入，States 无论跟着组件实例还是置外总必须是持久化的，至于怎么判断更新
- 变更集
  - 依赖追踪
  - 引用不等性


- ng
  - 视图层变更检测触发机制：事件驱动
- vue
  - 视图层变更检测触发机制：数据驱动（数据劫持）
- react
- vue/react没有抛弃面向对象设计，其本身的API也远远谈不上足够FP，其底层实现也是mutable的。
- 我的观点依然是:函数式提供底层抽象能力，面向对象提供业务组织能力。
- 函数式负责提高复用能力，简化代码实现，提升代码的信息密度。
- 面向对象负责描述组件/模块之间的关系和业务逻辑，提高代码可读性，致力于显式地充分暴露业务客观存在的复杂度。



- react 为什么函数式开发范式
  - 函数式的数据不可变契合 react 原理
  - 并发
  - this.state 问题
  - React 并发模式下很容易出现数据竞态（data race）的问题。
    - this.state 是一个对象，每次更新局部，更新时也可新加 state 进去，这就让 state 整体比较混沌。
    - 使用高阶组件等模式时，会造成 this.props 中的数据来源不透明，同样混沌。
    - 因为 this 魔法指针的存在，很容易挂一大堆东西上去，互相随意调用，就会让逻辑缠绕。
  - 复用状态逻辑
    - 提供逻辑共享，以替代高阶组件。
  - 逻辑关注点
  - algebraic effects

- 框架体系不同
  - Vue
    - 组件语义：基于响应式的对象
    - Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
    - 接近大家习惯的 JS
  - React
    - 函数
    - 副作用受控的「执行上下文（evaluation context）」
    - React 在组件方面的心智模型是「副作用受上下文托管的纯函数」


- state 去重
  - 处理多个组件状态同时更新这种case
- props 浅对比
- diff children 动静分离
在 React 中，随时间变化的数据称为状态，状态的行为更像是快照

- 状态
  - 管理状态
    - 状态流动
    - 状态共享
      - 状态提升
  - 状态设计
    - 数据扁平化
    - 状态机
    - 结构化


- React
  - 并发渲染
    - 这使 React 能够在渲染阶段暂停工作以允许浏览器处理事件。React 将在以后适当地恢复、丢弃或重新计算该工作。一旦渲染过程完成，React 仍然会一步同步运行提交阶段。
  - vDom: render => diff => patch
  - 渲染过程
    - 渲染阶段
      - render
        - 整个组件树的渲染输出之后，React 将 diff 新的对象树
      - diff
    - 提交阶段
      - patch
  - React 是如何知道输出何时以及如何实际改变的呢？
    - state
      - setState
        - 异步更新、批处理
          - React 17 及更早版本，React 事件处理程序中进行批处理
          - React 18 现在对任何单个事件循环 tick 中排队的所有更新进行“自动批处理”
        - 同步？
    - diff 算法
  - 功能组件：
    useState二传手
    useReducer派遣
    类组件：
    this.setState()
    this.forceUpdate()
    其他：
    再次调用 ReactDOM 顶层render(<App>)方法（相当于调用forceUpdate()根组件）
    从新useSyncExternalStore钩子触发的更新
  - 标准渲染行为
    - React 从树的顶部开始渲染，如果组件没有被标记为需要更新则跳过
    - React 的默认行为是，当父组件渲染时，React 会递归地渲染其中的所有子组件！
      - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件，因为父组件渲染！
  - 渲染并不是一件坏事——它是 React 知道它是否需要对 DOM 进行实际更改的方式！
  - React Render 规则
    - 纯函数
  - 并发渲染
    - [Fiber](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193)
      - React 存储了一个内部数据结构，用于跟踪应用程序中存在的所有当前组件实例
      - React 将组件的所有 hooks 存储为附加到该组件的 fiber object 的链表



## 容器

### 容器突然被杀死
   
1. 容器内的主进程已成功结束
2. 交互程序的标准流没用附加管道或者终端
3. 收到关闭信号，如 `Ctrl+C`
4. 守护进程重启
5. docker stop
6. 系统杀死

7. 查看日志
8. 检查容器的状态，如退出状态码
9. 从相同的失败映像创建和启动容器，并使用 shell 覆盖入口sh点

## 程序设计语言

- 具有图灵完备性的计算机语言，就被称为图灵完备语言
  - “图灵完备”指的是语言指定的数据操作规则能够实现图灵机的全部功能
  - 图灵机是所有程序设计语言最底层的模型
  - 今天接触到的程序设计语言都是图灵完备的
- 程序设计语言发展简史
  - 机器语言
  - 汇编语言：对机器指令语义化封装
    - 缺点：不同厂商具有各自的 CPU 指令集
  - 高级程序设计语言：程序设计语言的发展就是一个“逐步远离计算机硬件，向着待解决的问题靠近”的过程
    - 屏蔽底层计算机硬件细节：如 C 语言
    - 类型系统：对内存抽象
      - 泛型编程
      - 动态类型
    - 内存管理
      - 自动垃圾回收机制
    - 如何组织程序
      - 结构化
      - 面向对象
    - 多核：高并发
      - 并发模型、异步模型
      - 内存安全
    - 语言表达力
      - 程序设计语言的一个重要发展趋势：声明式编程
      - DSL（Domain Specific Language，简称 DSL），它是一种用于某个特定领域的程序设计语言
        - DSL 不必做到图灵完备，它只要做到满足特定领域的业务需求，就足以缩短问题和解决方案之间的距离，降低理解的门槛
        - DSL 分类：区别 DSL 采用的是不是宿主语言
          - 外部 DSL 
          - 内部 DSL：本质就是一个程序库，**将意图与实现分离开来**
    - 函数式编程的程序设计语言
      - 关注如何解决问题，如何一层层构建抽象
      - 并发安全
- 首先是学习语法、编程模型
  - 命令式编程是面向计算机硬件的抽象：命令式程序就是一个冯诺依曼机的指令序列
      - 变量（对应着存储单元）
      - 赋值语句（获取存储指令）
      - 表达式（内存引用和算术运算）
      - 控制语句（跳转指令）
        - 顺序
        - 选择
        - 循环
      - 函数（过程）
    - 类型系统
    - 面向泛型
    - 面向对象：隔离（封装）、接口（多态）
    - 函数式：组合
  - 然后学习程序库
  - 最后学习运行时
- 类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。
不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。
- 类型系统
  - 静态、动态
    - 动态
      - 类型检查
  - 强弱类型
    - 弱类型
      - 类型转化
        - 访问到了不同的地址和内存空间，这就导致程序出现严重的问题
    - 强类型
      - 类型抽象 =〉泛型
- 如何实现跨语言调用？

## JavaScript

- Reflect主要是和Proxy配对使用，提供对象语义的默认行为
- get/set带有额外的receiver参数，现阶段，receiver其实只对访问器进行上下文修改。因为对于除了访问器（立即求值导致的）以外的属性，没有其他情况会出现这种上下文丢失的情况了，因为即使是一般函数调用，过程也是分步的，先获取函数对象（[[Get]]），再执行函数（[[Call]]）。而不会在[[Get]]的时候直接执行就意味着不会出现上下文丢失。receiver参数完全是为了解决访问器上下文问题而添加的。

- 错误
  - 标准 JavaScript 错误
    - EvalError
    - RangeError
    - ReferenceError
    - SyntaxError
    - TypeError
    - URIError
    - Async errors
  - 系统错误
  - 用户指定的错误
  - 断言错误
- 堆栈错误跟踪
  - console.trace


- 元编程
  - “With” 和 “eval” — ECMAScript中的动态作用域
    ，使用with和eval虽然加强了静态作用域，但相比之下，with和eval在实现上也可能会削弱变量查找和词法环境储存的性能（译注：因为这相当于扩充了当前作用域，增加了存储消耗和查找范围）。因此在ES5中，with在严格模式下被移除了，此外严格模式下的eval方法不再会在当前上下文创建变量。所以，ES5的严格模式下是完全遵守词法环境的实现。

## NodeJS

## 源码阅读技巧

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。你对细节部分的了解会随着你对项目的深入而逐渐增加。而有了主线后，你就有了着力点，就可以不断深入了。

尽量忽略其他不相干 case 情况，保持主逻辑功能流程分析
**这里有个小技巧：看源码过程一般建议关注主线逻辑，像各种特殊情况可通过注释、issue 或者测试用例查看原由**。


1. 理解功能需求
2. 实现猜想
3. 功能源码主流程 debugger
4. 源码细节
   1. 看 issue
   2. 看测试用例


## 并发编程体系

- 语言分类
  - 编译型 vs 解释型
  - 强类型 vs 弱类型：对变量类型检查的程度，隐式转换
  - 静态类型 vs 动态类型：类型检查发生的时机、变量可动态类型赋值
- 编程：CPU 计算 + IO 调用
- IO
  - 内存
  - 网络
  - I/O设备
    - 磁盘
- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- 调度模式
  - 抢占式调度
  - 协作式调度
- 并发模型
  - 设计要素
    - 粒度
      - 指令
      - 函数
      - 程序
    - 调度
    - 通信
      - 共享内存
      - 消息传递
        - Actor
        - CSP
    - 同步
    - 编程范式
  - 编程范式
    - 线程模型
      - 多线程 + 同步原语 + 阻塞IO
    - 异步模型（事件驱动）
      - 事件驱动
        - 在合作型多任务处理中，总有一个处理内核负责所有I/O处理。其在设计模式中称为反应器模式
      - 模型
        - 单线程事件循环 + 异步回调队列
        - 协程模型
          - 特点
            - 协程就是用户态线程。协程的调度完全由开发者进行控制，因此实现协程的关键也就是实现一个用户态线程的调度器。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在 IO 上的性能瓶颈。
            - 框架或者编程语言将阻塞操作转为无阻塞，同时将其控制权交到其他的执行线程中
          - 按调用栈分类（由于协程必须支持 挂起/恢复，因此对于挂起点的状态保存就显得极其关键。）
            - 有栈协程（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈
            - 无栈协程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。
          - 按调度方式分类
            - 对称协程（Symmetric Coroutine）：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。对称协程有自己独立的调度器，除了挂起是由自己主动让出，它更像一个操作系统的原生线程，协程的调度运行完全取决于自己的调度器，在一个协程挂起后可以调度任何一个协程。
            - 非对称协程（Asymmetric Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。
              - 通过语法 `yield`、`await` 显示协作
          - 范式
            - CSP
            - Actor



## 软件设计

- 关注点分离
  - 变与不变分离
- 代码复用
  - 设计手段
    - 抽象
    - 抽取公共代码
  - 本质
    - 代码拷贝
    - 函数指针应用
      - 编译时
        - 组合
      - 运行时
        - 继承：委托
        - mixin：指针拷贝
  - 方式
    - 面向对象
      - 继承
      - mixin
      - 接口组合
        - 面向接口
        - 面向组合
    - 函数式
      - 高阶函数
      - 组合
- 完成需求本身就是一个面向过程
- 提高代码可维护性，那就是面向对象设计

## JavaScript

- UI 客户端是以**事件驱动**编程为主，所以应用背后的程序，就需要处理大量的用户和网络触发的事件，并根据事件的状态来做出响应。
- 在这个过程当中，我们要通过工具来处理很多事，比如事件处理、状态管理。函数就是这个工具，它的核心就是 IO 输入输出。我们给函数一个输入值（数据结构），它进行处理（算法），然后给我们一个输出值（返回值）
- 面向对象 vs 函数式
  - 函数式
    - 生产力，计算能力
    - 纯函数与IO关系？
    - 声明式，表达力强
  - 面向对象
    - 生产关系，系统设计模型关系
  - 一个是管理和解决副作用，一个是服务于业务对象。
- 范式作用
  - 约束
- 函数式
  - Monad 的核心，就是围绕一个“值”来组织各种方法
  - **变量可变，副作用导致的不确定性**
  - 函数式，特征不可变，只关注输入输出，具有可预测
  - 减少副作用：纯函数和不可变
    - 函数式编程最核心的地方，就是输入输出和中间的算法，我们要解决的核心问题就是副作用。而为了解决副作用，我们需要掌握两个重要的概念，一个是纯函数，一个是不可变。纯函数强调的是自身的稳定性，对结果只影响一次；而不可变强调的是和外界的交互中，尽量减少相互间负面的影响
    - “不可变”对值完全不影响：把这种思想用到状态管理里，你就会记录状态的变化，而不会篡改状态。
- js 编程模式
  - 事件驱动
  - 动态类型
  - 过程
  - 面向对象
    - 基于原型链的继承
      - 实现
    - 对象 api 
      - 属性遍历 for in
  - 函数式
- 如何才能在不可变的原则下，来管理这种变化呢？
  - 我们的应用肯定需要和用户交互，而一旦有交互，我们就需要管理值的状态（state） 和围绕值设计一系列行为（behavior）。在这个过程中，我们需要考虑的就是一个值的结构性不可变的问题。
  - **普通对象、闭包对象**
  - 状态的拷贝更新
    - 如何解决拷贝性能问题？
      - immutable.js
- 闭包最大的特点是可以突破生命周期和作用域的限制，也就是时间和空间的控制
- 函数操作复习
  - 部分应用可以减少每次函数调用时需要传入的参数，而柯里化更是把函数调用时需要传入的参数数量，降到了 1。它们实际上都起到了控制参数数量的作用
  - 等
- Pointe-Free Style
  - var isOdd = (x) => equalsToOne(remainderOfTwo(x));
  - point free的理解：把参数去掉，是指参数的含义已经体现在函数声明（名字）里面了，比如equalsToOne，那就是说传入的值是否等于1，如果是equalsToA，那么这个A就得传为参数，加上要比较的x就是两个参数了。这就是所谓“暴露给使用者的就是功能本身”。
- reducer
  - 它最主要的作用其实是解决在使用多个 map、filter、reduce 操作大型数组时，可能会发生的性能问题。而通过使用 transducer 和 reducer，我们就可以优化一系列 map、filter、reduce 操作，使得输入数组只被处理一次并直接产生输出结果，而不需要创建任何中间数组
  - 通过 reducer 的组合，做到普通的组合达不到的性能提升。
  - composeReducer 原理
  - mapReducer
  - filterReducer
  - 利用了reduce的第二个参数的初始值可以是一个“空数组”，映射或过滤后，放入“新数组”。



- IO是异步的，IO调用供给者提供可同步或者异步编程模型，存在异步就意味有时间差，有时间差就需要状态管理，才能保证逻辑同步性。在命令式编程中需要引入可变状态或者 IO 莫
- 谁告诉你Monad可以简化IO操作的？ Monad最大的作用就是在pure 函数式编程中处理副作用



- 异步处理
  - 函数式+响应式编程
- 动态加载策略：在前端开发中做资源加载设计
  - 按需加载
  - 懒加载
- 做逻辑计算 = 输入、计算、输出
  - 函数式：纯函数和不可变作为解决思路来管理副作用
  - 事件驱动：响应式编程和函数式编程，如何面对未知以及基于事件变化做出响应。
  


- 面向对象编程，一是抽象思维，把数据和算法抽象成类和对象；二是标准化，接口即协议，所有的实现类都要满足定义的接口才可以作为依赖；三是封装，对象之间通过接口调用，互相之间不关心彼此的细节；总之，接口的定义是否清晰是面向对象设计的关键；
由于对象内封装了状态，所以在并发环境下天然存在问题


- 结构化
  - 全局变量
  - 第二个是可重用性范围问题。结构化语言中可重用的范围是代码中的子代码（比如某个函数方法），如果离开当前代码，那么子代码就无法被再次使用。
    - 而面向对象结构却很好地避免了以上两种问题，类结构将相关的子程序（或函数）和全局变量汇总在一起，创建高一层级的软件组件；多态和继承则去除了冗余的公用子程序，让公用程序更好地被重用。
- 面向对象编程
  - 带来
    - 封装 => 模块化 => 可复用性
    - 继承、多态 => 接口、抽象 => 可扩展性
    - 组合 => 复用性
  - 利用多态（polymorphism）来限制用户对函数指针的使用？
    - 面向对象编程对程序控制权的间接转移进行了限制和规范
  - 继承
    - 目的
      - 代码复用
        - 代码复用：我们可以把通用功能放到抽象类；而一些特定的行为或属性，我们可以通过继承放到实现类中
      - 代码扩展
        - 重写
        - 重载
    - 继承问题
      - 继承导致强耦合(后来通过设计模式的策略模式解决)
        - 继承可以看作是非常紧耦合的一种关系，父类代码修改，子类行为也会变动。在实践中，过度滥用继承，可能会起到反效果。
      - 代码重用：Java 未区分
        - 实例类不能继承复用
        - 抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用
  - 多态：一个接口多种形态
    - 实现
      - 运行时动态绑定函数指针
        - AST 解释器
        - 静态编译  
          - vtable
    - 意义
      - 独立、抽象、插件架构
      - 依赖倒置
  - 接口和抽象类
    - 抽象类可扩展功能
    - 接口是对行为的抽象
      - 设计方法
    - 接口的多继承
    - 接口标记
  - 在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如 java.util.Collections。
  - 面向对象编程就是以对象为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可必编译成插件，实现独立于高层组件的开发和部署
    - 插件式架构
    - 依赖反转
- 函数式编程
  - 不可变：函数式编程来自 λ 演算法，其的一个核心思想是不可变性——某个符号所对应的值是永远不变的
    - 函数式编程对程序中的赋值进行了限制和规范
  - 函数式编程总结起来就是把一些功能或逻辑代码通过函数拼装方式来组织的玩法
    - 隔离可变：代码中还是需要处理数据的，这些就是所谓的“状态”，函数式编程需要我们写出无状态的代码？
- 软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理
  - 多态是我们跨越架构边界的手段
  - 函数式编程是我们规范和限制数据存放位置与访问权限的手段
  - 结构化编程则是各模块的算法实现基础

- 类型
  - 类型层次
    - 向上转型？
  - 结构化类型

- 对象
  - 公开属性
  - 私有属性
  - 静态属性
    - 静态属性只能作用于 class 本身。
    - 普通属性里调用
  - 静态私有属性
- 实现私有属性
  - 主要有闭包、WeakMap 和 Symbol 这三种方式。
    - 构造器 + 闭包
      ```js
      function WidgetG() { var appName = "天气应用"; this.getName = function(){ return appName; }}WidgetG.prototype = (function(){ var model = "支持安卓"; return { getModel: function(){ return model; } }}());var widget7 = new WidgetG();console.log(widget7.getName()); // 返回 “天气应用”console.log(widget7.getModel()); // 返回 “支持安卓”
      ```
- WeakMap，它的特点是只接受对象作为键名，键名是弱引用，键值可以是任意的
- JavaScript 中是通过哪些方法来解决代码复用
  - js：基于原型链的继承
  - 委托
  - 借用：在 JavaScript 中，函数有自带的 apply 和 call 功能。我们可以通过 apply 或 call 来“借用”一个功能。
  - 拷贝
  - 组合混入
- JS-代码复用
  - 复制
    - object.assign
  - 组合/委托
- 多态
  - 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法
  - 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
  - 多态机制使内部结构不同的对象可以共享相同的外部接口。即子类可以重写父类的某个函数，从而为这个函数提供不同于父类的行为。一个父类的多个子类可以为同一个函数提供不同的实现，从而在父类这个公共的接口下，表现出多种行为。
  - 多态的使用场景：当类之间存在层次结构，并且类之间是通过继承关联时。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
  - 接口及继承
    - 继承缺点：复杂-多层继承关系
- 组合、继承意义
  - 业务开发
  - 基础设施？
- object 接口
- 继承、组合
  - 继承 自定而下的关系定义
  - 组合 
- 父母都是以自身经历过往去教育孩子，可以他们为模板下的孩子有可能发展成为不了未来人才
- js 类实现、Object.create
- 实现私有属性的方法其实就两种：闭包和 symbol
- 在 JavaScript 中，this 是在运行时而不是编写时绑定的。所以要正确地使用它，需要考虑到函数调用时的执行上下文。
- 在 this 的绑定中，有一点是需要我们注意的，那就是当我们使用箭头函数的时候，this 是在词法域里面的，而不是根据函数执行时的上下文。
- 箭头函数区别
  - 不能作为构造函数
- JavaScript 当中有几种类型的值
  - 7+1
- 为什么 0.1+0.2 不等于 0.3？
  - 解决
- 如何判断一个值是不是数字
- Object.create
- 如何识别一个数组？ isArray
- 对象创建
  - 字面量语法
  - 构造器语法
- js debug
  - V8
  - debugger client
    - chrome devtool
    - vscode debugger
      - [Working with JavaScript](https://code.visualstudio.com/docs/nodejs/working-with-javascript)
      - [Node.js debugging in VS Code](https://code.visualstudio.com/docs/nodejs/nodejs-debugging)
      - 框架

## 网络

- TCP 协议是如何恢复数据的顺序的？
- 拆包和粘包的作用是什么？


- 稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。
  - 序号
- TCP 利用发送字节数和接收字节数，这个二元组的唯一性保证顺序
- 保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量
  - 滑动窗口
    - 传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供
- 网络安全
  - https 安全协议
  - 防火墙
- 从传输层看是 TCP 段；从网络层来看是 IP 封包；从链路层来看是 Frame。
- Whireshark 追溯的是最底层网卡传输的 Frame（帧），可以追溯到数据链路层。因此对二进制形式的解读，也就是我们的消息视图也要分层。因为对于同样的数据，不同层的解读是不同的。
- 网之初，性本善，不丢包，不乱序

## 工程

- 工程思维
  - 分解问题
  - 分层
- 应用及工程优化问题
  - 计算
    - 算法优化
    - 增量计算
      - 缓存
    - 并发计算
      - 多核：并行计算
      - 单线程：分片计算

## 内存

- 栈中的所有数据都必须占用已知且固定的大小
- 字符串字面值
- 指针和引用
  - 指针一般指的是某块内存的地址
  - 指针是一个持有内存地址的值，可以通过解引用（dereference）来访问它指向的内存地址，理论上可以解引用到任意数据类型，但如果没有用正确的类型解引用一个指针，那么会引发各种各样的内存问题
  - 引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用
  - 引用的实现上比正常指针携带更多信息的指针，我们称之为胖指针（fat pointer），很多数据结构的引用，内部都是由胖指针实现的
- 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；
- 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念。

## rust

- 值
  - 类型
  - 分配
    - 栈：内存大小是固定的数据类型
  - 使用
    - 场景
      - 赋值
      - 传惨
      - 返回值
  - 内存回收
    - 手动
    - 追踪式 GC
      - STW
    - 自动引用计数
    - 所有权、生命周期
      - 生命周期
        - 在 Rust 中，一对花括号括起来的代码区就是一个作用域
- 引用（reference）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。
- 引用，所以它没有所有权。
- slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合

## css

-  CSS Modules
-  Atomic CSS

## 其他


“语言设计就是程序库设计”和“程序库设计就是语言设计” react 确实把自己当做语言造


V8 JS 的执行原理：
了解指令是如何执行的：
运行机制和字节码执行
基于栈 vs 基于寄存器



所谓状态是对象某时间的快照，我们引入状态却把时间参数隐藏起来，于是我们不得不引入锁来保持一致性。强一致性（控制），最终一致性（回避），事件溯源（引入），这一步步正是重新正视我们过去抽象偷懒引来的问题。计算或逻辑本来就没有状态概念，减少多余概念的消耗，可以发挥计算最大效能。

Event Sourcing，把对象的状态每次变化抽象成独立的事件进行保存，对象的状态变化可由一系列事件的调用重现。 编写不变类，无可变化的状态；Event Sourcing记录每一次状态变化。




- 编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务、更为抽象的语言，如典型的面向对象语言 C++ 和 Java 等。
- 数据不可变意味着无状态
- 因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。
- 函数的执行没有顺序上的问题
- 函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。
- 有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。
  - 它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。
- 我们可以看到 map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么



- DI
  - 分离依赖
  - 可测试性


- 面向对象系统设计，对需求进行分析从而产生概念模型
- 模型
  - 业务层面：概念模型
  - 实现层面：设计模型
- UML 工具
- 面向对象思想：抽象、继承、封装
- 业务需求层面，原型
- 实现层面，模型



- 代码算法组成
  - 业务逻辑 Logic：Logic 部分是真正意义上的解决问题的算法
  - 控制逻辑 Control
- 有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！（代码就会变得更容易改进和维护）



```js
onst program = require('commander');
const build = require('../lib/commands/build');

(async () => {

  // build 命令注册
  program.command('build').description('build project').action(build);

  // 判断是否有存在运行的命令，如果有则退出已执行命令
  const proc = program.runningCommand;
  if (proc) {
    proc.on('close', process.exit.bind(process));
    proc.on('error', () => {
      process.exit(1);
    });
  }

  // 命令行参数解析
  program.parse(process.argv);

  // 如果无子命令，展示 help 信息
  const subCmd = program.args[0];
  if (!subCmd) {
    program.help();
  }

})();

```



- hash：每次 hash 值的变化，浏览器不发出请求，也就不会刷新页面，还会触发hashchange
- history：pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求
  - 但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求
    - 为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。



- js 数组
  - 断言
    - some
    - every
  - 转换
    - map
    - filter
    - **reduce**


逗号表达式


- stale-while-revalidate
  - 场景
    - 资源的 URL 是不能变的
    - 可接受牺牲一次资源的新鲜性
  - 配置：stale-while-revalidate大、max-age小应该是主流的选择
  - must-revalidate指令，可以屏蔽 stale-while-revalidate指令



- 组件模型允许解耦独立的前端团队，他们可以更容易地在独立组件上并行工作。作为一个架构，它允许组件的分层。从共享的原语到构成页面根目录的“有机体”。
- 单向的数据流使数据流更易于理解、跟踪和调试。这就提高了之前难以企及的可预见性。
- 虚拟 DOM 就是我们可以编写函数，返回用户界面的说明，让 React 去解决这些难点。这样可以避免在数据频繁变化时出现的一致性问题，并且使得模板的组成更加人性化。
- CPU 遭遇很大阻力
  - DOM 是 React 模型的一个问题。浏览器并不是为了在连续的渲染周期中不断创建和销毁 DOM 节点而构建的。就像任何可以通过引入一个新的间接级别来解决的问题一样，React 把它抽象到了虚拟 DOM 后面。
  - 人们只有在 100 毫秒以内感知到反馈，才会感到流畅。当虚拟 DOM 和真实 DOM 之间发生协调时，大型交互式应用程序会对用户的输入失去响应。像“长任务”这样的术语开始出现了。



- 当我们在写 JS 代码的时候会去思考一般如何处理变量。我们的操作几乎完全是为了给变量进行赋值或者是去将两个变量相加又或者是去将两个变量连接到一起并且将它们赋值给另外一个变量。
- 变量可变、维护
- 模块化作用
  - 通过模块化，你可以把变量和函数合理的进行分组归类
  - 它把这些函数和变量放在一个模块的作用域内。这个模块的作用域能够让其中的函数一起分享变量。
  - 但是不像函数的作用域，模块的作用域有一种方式去让它们的变量能过被其他模块所用。它们能够明确的安排其中哪些变量、类或者函数可以被其他模块使用。



- 构建工具
  - Bundler
  - Transformer
  - Minimizer
- SWC 的兼容性更好适合 web 前端场景，Esbuild 更适合 node 场景下的开发
  - esbuild
    - [tsx](https://github.com/esbuild-kit/tsx)



- 跨语言调用
  - 进程间通信
    - 二进制协议
    - 序列化与反序列化
    - 字节序


- git
  - husky
  - lint-staged 
  - commitlint
- 版本发布：发版与 CHANGELOG 自动化
  - standard-version
  - 根据指定规则自动升级项目不同级别（major、minor、patch）的版本并打 tag
  - 对比历史 commit 提交自动生成不同版本间的可阅读、分类的 CHANGELOG 日志





- em 相对于自身元素的 font-size


- web 攻击
  - 点击劫持
  - 跨站脚本 (XSS)
  - 跨站请求伪造 (CSRF)



- 环境锁定
- 项目模板
  - plop 代码模板生产
  - 支持 Mock 数据
  - 自动生成router，过滤components组件
  - Proxy 代理


object api









- ES modules 和 CommonJS modules 之间的区别之一就是将模块声明算法拆分到各个阶段去执行
  - CommonJS 在返回模块实例前就遍历完其整个依赖关系树：完成加载、实例化以及对各个依赖进行求值的操作



- 请求
- 构建
- 执行



- defer或async属性，脚本就会异步加载
- defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。
- 一句话，defer是“渲染完再执行”，async是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。
- module 加载规则默认 defer 行为
  - ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致
- module 加载代码
  - 严格模式
  - 模块作用域
- CommonJS
  - module.exports
  - require
- CommonJS 模块不能处理export命令。




exports和module.exports区别是什么。
两者指向同一块内存
ES Module则是指向同一块内存


- 路径解析规则






css 重叠
相同类名
相同属性

https://github.com/dcastil/tailwind-merge


提示浏览器如何加载资源






JWT的场景，是可靠地发布信息，就像IOS登录一样，将用户信息封装成JWT提供给第三方业务服务，业务服务只需要apple发布的公钥用于验证JWT的真实性，以决定是否使用其提供的内容。
我想，这也是为什么IOS登录时提供的不仅有JWT，还有一个用于访问API的code，后者才是对应的访问凭证。


页面加载速度优化的核心包括三点：减少资源文件的请求数量；减小每个资源文件的大小；提高每个资源的加载速度；


- 循环
- 遍历
  - 迭代
    - for await...of
  - 递归



- 在分层理念中，一种通用的分层思想，是将应用分为“数据层”“逻辑层”“表现层”
- 组件优先：同时承载了业务的逻辑和界面的交互逻辑
- 关注点分离-逻辑层：区分哪些代码是业务的，哪些代码是交互的
- DDD
  - 领域建模：转换自己的角色，把自己当作一个业务人员，问自己我用这套系统要完成什么业务目的，梳理出业务流程，指明不同角色在业务流程中的责任，画出业务的示意图，并最终用代码把它表达出来
    - 统一语言，说的直白些，就是图纸
    - 与图纸等效的建模代码
- 业务代码
  - 描述业务的实体对象，是业务所围绕的核心概念，你的公司所做的业务，本质上就是在创建和处理这些对象
  - 一类是描述工作流程的服务对象，它们主要是对实体对象的处理过程、逻辑、事件，是使得业务产生实际效果的非实体对象。
- 面向对象是DDD的核心方法
  ```js
  import { Model, meta, state, Int, Validator } from 'tyshemo'

  class Order extends Model {
    @meta({
      type: Number,
      label: '单价',
      required: true,
      validators: [
        Validator.required('单价必填'),
      ],
    })
    price = 0
  ```
- 领域服务:领域模型帮我们描绘了有关这个业务的核心对象的各种逻辑，但是，我们的这个业务实体会面对很多场景，每一个场景下，可能存在有些特定的转化逻辑，这就需要我们在领域模型的基础上，提供对应场景的服务。
- 分层模型
  - 视图层 View
  - 逻辑层
    - 交互模型 ViewModel
    - 领域服务 Service：完成不同场景的业务处理需求
    - 领域模型 Model：描述业务的实体对象模型
- 当用户点击“提交”按钮的时候，该订单被发送给检验员进行核对？



- Referer
  - Referrer-Policy
    - 默认：`Referrer-Policy: strict-origin-when-cross-origin`
      - 同源时，发送完整的 Referer 字段；
      - 跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，否则发送源信息
  - 设置 Policy 的方法
    - 元素属性
      - rel 
      - referrerpolicy
    - 标签设置整个网页的 Referer Policy 策略
    - Headers 请求头：`Referrer-Policy: no-referrer`
  - 作用及使用场景
    - 防盗链：按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问
    - 埋点分析：Referer 提供用户的来源网址和整体访问链路
    - 错误排查（接口日志）








- vite
  - 按需编译
  - 没有打包？
  - 冷启动性能优势。
  - 开发和生产环境的一致性
  - 极致的缓存复用
- esbuild
  - 没有热更新
  - 没有缓存
  - 不支持懒打包，比如基于路由和请求的按需打包方案



- 单链表翻转（递归或者循环）
- 树的前中后序遍历
- 动态规划（爬楼梯以及变形问题、斐波那契数列、股票问题）
- 二分查找（以及变形）
- 排序（快排）
- 搜索二维矩阵
- 零钱兑换
- 验证二叉搜索树


- 页面加载
  - 网络层
    - 连接复用
    - 并发连接
    - CDN
    - 缓存
  - 减少页面初载时，所需加载资源的「数量」和「体积」
    - 代码分割
      - 如何查看代码利用率
  - 初始渲染
    - 减少阻塞渲染的请求
      - 将脚本标签放在 body 标签的底部；
      - 使用 async 异步加载脚本；
      - 内联小型 JS 或 CSS 代码段（如果它们需要同步加载）
    - 避免阻塞渲染的顺序请求链
      - 内联合并
      - 预加载或预连接
- 页面交互


- goto
  - 结构化编程
- 指针
  - 修改
    - 面向对象
  - 空引用
    - Maybe，通过类型强制处理？
- 纯函数
  - 纯函数只对它们的输入参数进行操作，使得不同函数之间不可能有任何交互。这允许对编译器进行优化，以生成在多个内核上高效且轻松地运行的代码。
  - 纯函数不会产生副作用。通过这一限制，您可以提高稳定性，打开编译器优化的大门，并最终得到更容易推理的代码。
  - 函数式编程还要求数据是不可变的，这意味着一旦将变量设置为某个值，它就永远是那个值。变量更像是数学中的变量。
  - 状态？


- react
  - render => diff => patch
  - 渲染阶段
    - render
    - 整个组件树的渲染输出之后，React 将 diff 新的对象树
    - diff
  - 提交阶段
    - patch
  - 功能组件：
    useState二传手
    useReducer派遣
    类组件：
    this.setState()
    this.forceUpdate()
    其他：
    再次调用 ReactDOM 顶层render(<App>)方法（相当于调用forceUpdate()根组件）
    从新useSyncExternalStore钩子触发的更新
  - 标准渲染行为
    - React 从树的顶部开始渲染，如果组件没有被标记为需要更新则跳过
    - React 的默认行为是，当父组件渲染时，React 会递归地渲染其中的所有子组件！
      - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件，因为父组件渲染！
  - 渲染并不是一件坏事——它是 React 知道它是否需要对 DOM 进行实际更改的方式！
  - React Render 规则
    - 纯函数
  - 并发渲染
    - [Fiber](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193)
      - React 存储了一个内部数据结构，用于跟踪应用程序中存在的所有当前组件实例
      - React 将组件的所有 hooks 存储为附加到该组件的 fiber object 的链表


- 递归
  - 递归（重复）关系
  - 递推关系
    - 归纳法
  - 特征：递归是一种自顶向下求解模型
- 分治思想
  - 二分查找
  - 分治法：多分支递归的算法范型
    - 算法优化
      - 归并排序
      - 快速排序
- 暴力枚举
- 回溯算法
  - 状态树 + 分层分支选择 + 回溯
  - 适合
    - 搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解
  - 回溯的关键不在于递归，而在于“状态”
- 动态规划
  - 最优决策过程
  - 「分解问题」的思维模式：大事化小，小事化了”的思想:分层分解问题，分别求解这些子问题，即可推断出大问题的解
  - 特征
    - 无后效性：未来与过去无关
    - 最优子结构：大问题的最优解可以由小问题的最优解推出
  - 判断问题类型
    - 能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
  - 设计动态规划算法，一般可以分成三步走：
    - dp 状态定义：
      - 会变化的问题状态
      - 数据规模变小分解
    - 设计转移方程
      - 递归
        - 分治法 + 最优子结构 
      - 递推
    - 程序编写
- 动态规划与回溯区别
  - 动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的
  - 暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的
  - 关注问题及问题分解过程
- 搜索就是尝试问题中所有的可能性，在所有的可能性中找到正确的结果
  - 搜索模型：解答树
    - 组合排序模型
    - 多阶段最优模型
- 问题 => 树结构思维
  - 树的遍历
    - 问题状态升纬度 => 状态树
  - 分解问题 => 推导原问题
    - 递推形式
    - 递归形式
      - 前序写法
        - 先进先出
      - 后序写法
        - 后序遍历，利用递归的堆栈帮你实现了倒序遍历的效果
          - 利用堆栈保存原来状态

  - 前序位置的代码在刚刚进入一个二叉树节点的时候执行
  - 后序位置的代码在将要离开一个二叉树节点的时候执行；
  - 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
    - 遍历有序数组
- 递归写法（有返回）、遍历写法（有全局结果）
  - 意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。
  - 一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了
- 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。
- 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。
- 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案
- 意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

JVM标记清除算法：

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。
- 核心就是标记可达对象，清除不可达对象

不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。


内存模型 + 编译器内存分配原理：在内存分配时，会按照内存地址递增或递减的方式进行分配


数组容器：ArrayList 最大的优势就是可以将很多数组操作的细节封装起来。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持动态扩容。

常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。


循环链表
链表操作


单链表 字符串是否是回文字符串的问题


数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读


单链表反转
链表中环的检测
两个有序的链表合并
删除链表倒数第 n 个结点
求链表的中间结点


栈在表达式求值中的应用
栈在函数调用中的应用
栈在括号匹配中的应用
如何实现浏览器的前进、后退功能
leetcode上关于栈的题目大家可以先做20,155,232,844,224,682,496.


循环队列
确定好队空和队满的判定条件。
队空 head = tail
队满(tail+1)%n=head
队列应用 09 | 队列：队列在线程池等有限资源池中的应用
请求排队 任务排队调度
不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。


- 将 table / list 抽象，用类似 scheme 驱动的方式
- ui 都有差异,在设计层面，可能由于业务需求，很难做到统一，不得已自带设计体系
- 后端数据模型没有统一，因此对接数据前后涉及到的前端状态管理、数据流转也未能统一，复用性大打折扣。


性能问题


- 如何区分 UI 逻辑和业务逻辑？
  - 关注点分离：分层架构
- 业务逻辑 = 业务逻辑（业务实体 + 业务实体之间存在特定的关联） + **业务的交互逻辑（用户）**




- 浏览器渲染原理

  - canvas
    - https://www.html5canvastutorials.com/tutorials/html5-canvas-wrap-text-tutorial/
    - https://joshondesign.com/p/books/canvasdeepdive/toc.html
    - https://juejin.cn/post/6844903828916011022
    - https://www.kirupa.com/canvas/canvas_high_dpi_retina.htm
    - https://github.com/jondavidjohn/hidpi-canvas-polyfill
  - 资源调度
    - https://mp.weixin.qq.com/s/K24X2uNPvtbD4vZlXwJMYA
    - https://github.com/GoogleChromeLabs/preload-webpack-plugin
    - https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf
  - https://www.youtube.com/watch?v=kNzoswFIU9M&list=PLNYkxOF6rcICgS7eFJrGDhMBwWtdTgzpx


- 计算机导论

  - https://www.coursera.org/learn/jisuanji-biancheng/home/week/1
  - https://www.bilibili.com/video/av21376839/



- 表单
  - [formilyjs](https://v2.formilyjs.org/)
- 低代码
  - [amis](https://github.com/baidu/amis)
  - [imove](https://github.com/i5ting/imove)
  - [designable](https://github.com/alibaba/designable)



- 路由器
  - 路由器也承担了链路层网关的作用，作为家用电器之间信息的交换设备
- 交换机：只具有交换能力
- 交换技术的本质，就是让数据切换路径
  - 具有交换能力的设备是路由器（Router）和链路层交换机（Link-Layer Switch）
- 通信链路（Communication Link），用于传输网络信号
  - 而通信链路是一个抽象概念
- 网络传输
  - 一类是端到端（Host-to-Host）的能力，由 TCP/IP 协议群提供
  - 广播的能力，是一对多、多对多的能力
- 网络基础设施往往不能一次性传输太大的数据量，因此通常会将数据分片传输
- 网络中两点间的路径非常多，如果一条路径阻塞了，部分封包可以考虑走其他路径。发送端将数据拆分成封包（Packet），封包在网络中遇到岔路，由交换器和路由器节点决定走向，图 9 中是对封包交换技术的一个演示。


- 相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。

- 会话（Session），会话是应用的行为
- 因为可靠性给予 请求响应，你发请求同步包，对方需要回复你一个 ack 包作为响应
- TCP 是一个面向连接的协议
- UDP 是一个面向报文（Datagram-oriented）的协议


- 这个  FIN 报文代表客户端不会再发送数据了



- Symbol
  - 使用 Symbol 做为私有属性
- Symbol.for(str) 是新建一个以该字符串为名称的值，并注册到全局，如果已注册过，就直接返回
- Symbol.iterator 迭代器协议


- “JS 是单线程的”指的是执行 JS 代码的线程只有一个
- 这里的异步不是 JS 自身实现的，其实是浏览器为其提供的能力。
- 浏览器异步任务的执行原理背后其实是一套事件驱动的机制
- 事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。


- 迭代器协议
  - for of
  - 数组
  - 生成器函数



- 业务逻辑 = 通用业务逻辑 + UI 交互逻辑
- 分层
  - UI 表现层
  - 业务逻辑层




因为屏幕像素密度问题，根据devicePixelRate不同要将canvas设置对大小