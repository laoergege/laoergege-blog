<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>laoergege blog</title>
    <meta name="description" content="Just For Fun">
    
    
    <link rel="preload" href="/laoregege-blog/assets/css/0.styles.2731f072.css" as="style"><link rel="preload" href="/laoregege-blog/assets/js/app.41457635.js" as="script"><link rel="preload" href="/laoregege-blog/assets/js/2.afa2900c.js" as="script"><link rel="preload" href="/laoregege-blog/assets/js/22.ec116f47.js" as="script"><link rel="prefetch" href="/laoregege-blog/assets/js/10.61c009e0.js"><link rel="prefetch" href="/laoregege-blog/assets/js/11.e738f172.js"><link rel="prefetch" href="/laoregege-blog/assets/js/12.a7a1a835.js"><link rel="prefetch" href="/laoregege-blog/assets/js/13.7f0b0d40.js"><link rel="prefetch" href="/laoregege-blog/assets/js/14.f4eba2ad.js"><link rel="prefetch" href="/laoregege-blog/assets/js/15.a49020dd.js"><link rel="prefetch" href="/laoregege-blog/assets/js/16.de300aad.js"><link rel="prefetch" href="/laoregege-blog/assets/js/17.9b93e00b.js"><link rel="prefetch" href="/laoregege-blog/assets/js/18.31f5b602.js"><link rel="prefetch" href="/laoregege-blog/assets/js/19.2e5bf559.js"><link rel="prefetch" href="/laoregege-blog/assets/js/20.ded01176.js"><link rel="prefetch" href="/laoregege-blog/assets/js/21.c3c259b3.js"><link rel="prefetch" href="/laoregege-blog/assets/js/23.9b9caf0d.js"><link rel="prefetch" href="/laoregege-blog/assets/js/24.fe90e203.js"><link rel="prefetch" href="/laoregege-blog/assets/js/25.234d0588.js"><link rel="prefetch" href="/laoregege-blog/assets/js/26.5eb595a7.js"><link rel="prefetch" href="/laoregege-blog/assets/js/27.4b4e18c8.js"><link rel="prefetch" href="/laoregege-blog/assets/js/28.84568e96.js"><link rel="prefetch" href="/laoregege-blog/assets/js/29.53c57bcb.js"><link rel="prefetch" href="/laoregege-blog/assets/js/3.7ae5402d.js"><link rel="prefetch" href="/laoregege-blog/assets/js/30.b627bc9a.js"><link rel="prefetch" href="/laoregege-blog/assets/js/31.06573bcc.js"><link rel="prefetch" href="/laoregege-blog/assets/js/32.a85b1687.js"><link rel="prefetch" href="/laoregege-blog/assets/js/33.721f4386.js"><link rel="prefetch" href="/laoregege-blog/assets/js/34.05bffb34.js"><link rel="prefetch" href="/laoregege-blog/assets/js/35.ed6fdcb2.js"><link rel="prefetch" href="/laoregege-blog/assets/js/36.2cbc1004.js"><link rel="prefetch" href="/laoregege-blog/assets/js/37.9fd5bc93.js"><link rel="prefetch" href="/laoregege-blog/assets/js/38.eb936ad6.js"><link rel="prefetch" href="/laoregege-blog/assets/js/39.0d6e486c.js"><link rel="prefetch" href="/laoregege-blog/assets/js/4.59116900.js"><link rel="prefetch" href="/laoregege-blog/assets/js/40.638edff1.js"><link rel="prefetch" href="/laoregege-blog/assets/js/41.dce05572.js"><link rel="prefetch" href="/laoregege-blog/assets/js/42.e49e7c8f.js"><link rel="prefetch" href="/laoregege-blog/assets/js/43.83e0b8db.js"><link rel="prefetch" href="/laoregege-blog/assets/js/44.87de43a7.js"><link rel="prefetch" href="/laoregege-blog/assets/js/45.dfe2bb27.js"><link rel="prefetch" href="/laoregege-blog/assets/js/46.6232cdb0.js"><link rel="prefetch" href="/laoregege-blog/assets/js/47.2e222b75.js"><link rel="prefetch" href="/laoregege-blog/assets/js/48.ccdbe3bc.js"><link rel="prefetch" href="/laoregege-blog/assets/js/5.ffe58514.js"><link rel="prefetch" href="/laoregege-blog/assets/js/6.cdf21dfd.js"><link rel="prefetch" href="/laoregege-blog/assets/js/7.46459a23.js"><link rel="prefetch" href="/laoregege-blog/assets/js/8.57168558.js"><link rel="prefetch" href="/laoregege-blog/assets/js/9.26b4d1f9.js">
    <link rel="stylesheet" href="/laoregege-blog/assets/css/0.styles.2731f072.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/laoregege-blog/" class="home-link router-link-active"><!----> <span class="site-name">laoergege blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><hr> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???
</code></pre></div><p>第一段会报错：Uncaught ReferenceError: a is not defined。</p> <p>第二段会打印：1。</p> <p>这是因为函数中的 &quot;a&quot; 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p> <p>第一段执行 console 的时候， AO 的值是：</p> <div class="language- extra-class"><pre class="language-text"><code>AO = {
    arguments: {
        length: 0
    }
}
</code></pre></div><p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p> <p>当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</p> <hr> <div class="language- extra-class"><pre class="language-text"><code>console.log(foo);

function foo(){
    console.log(&quot;foo&quot;);
}

var foo = 1;
</code></pre></div><p>会打印函数，而不是 undefined 。</p> <p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p> <hr> <p>下面的代码将输出什么到控制台，为什么？</p> <div class="language- extra-class"><pre class="language-text"><code>(function(){

  var a = b = 3;

})();

 

console.log(&quot;a defined? &quot; + (typeof a !== 'undefined'));

console.log(&quot;b defined? &quot; + (typeof b !== 'undefined'));
</code></pre></div><p>由于 a 和 b 都定义在函数的封闭范围内，并且都始于 var关键字，大多数JavaScript开发人员期望 typeof a 和 typeof b 在上面的例子中都是undefined。</p> <p>然而，事实并非如此。这里的问题是，大多数开发人员将语句 var a = b = 3; 错误地理解为是以下声明的简写：</p> <p>var b = 3;</p> <p>var a = b;</p> <p>但事实上，var a = b = 3; 实际是以下声明的简写：</p> <p>b = 3;</p> <p>var a = b;</p> <p>因此（如果你不使用严格模式的话），该代码段的输出是：</p> <p>a defined? false</p> <p>b defined? true</p> <p>但是， b 如何才能被定义在封闭函数的范围之外呢？是的，既然语句 var a = b = 3; 是语句 b = 3; 和 var a = b;的简写， b 最终成为了一个全局变量（因为它没有前缀 var 关键字），因此仍然在范围内甚至封闭函数之外。</p> <p>需要注意的是，在严格模式下（即使用 use strict），语句var a = b = 3; 将生成ReferenceError: b is not defined的运行时错误，从而避免任何否则可能会导致的headfakes /bug。 （还是你为什么应该理所当然地在代码中使用 use strict 的最好例子！）</p> <hr> <p>NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaN ？</p> <p>NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， &quot;abc&quot; / 4），要么是因为运算的结果非数字（例如，除数为零）。</p> <p>虽然这看上去很简单，但 NaN 有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。</p> <p>首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(typeof NaN === &quot;number&quot;);  // logs &quot;true&quot;
</code></pre></div><p>此外， NaN 和任何东西比较——甚至是它自己本身！——结果是false：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(NaN === NaN);  // logs &quot;false&quot;
</code></pre></div><p>一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。</p> <p>一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。另外，ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。</p> <hr> <p>写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。</p> <p>下面这个函数在 str 是回文结构的时候返回true，否则，返回false。</p> <div class="language- extra-class"><pre class="language-text"><code>function isPalindrome(str) {

    str = str.replace(/W/g, '').toLowerCase();

    return (str == str.split('').reverse().join(''));

}
</code></pre></div><p>例如：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(isPalindrome(&quot;level&quot;));                   // logs 'true'

console.log(isPalindrome(&quot;levels&quot;));                  // logs 'false'

console.log(isPalindrome(&quot;A car, a man, a maraca&quot;));  // logs 'true'
</code></pre></div><hr> <p>获取数组中的最大值和最小值</p> <div class="language- extra-class"><pre class="language-text"><code>var numbers = [5, 458 , 120 , -215 ];

var maxInNumbers = Math.max.apply(Math, numbers), //458

maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458

</code></pre></div><p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p> <hr> <p>doctype是什么
告诉浏览器当前HTMl版本的指令,决定使用兼容模式还是标准模式对文档进行渲染</p> <hr> <p>ES5的继承和ES6的继承有什么区别？
ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。
ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。</p> <hr> <p>数组去重：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">NaN</span><span class="token punctuation">,</span><span class="token number">NaN</span><span class="token punctuation">,</span><span class="token keyword">undefined</span><span class="token punctuation">,</span><span class="token keyword">undefined</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">unique</span><span class="token operator">=</span> <span class="token parameter">arr</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> newA<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>newA<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//遍历newA是否存在key，如果存在key会大于0就跳过push的那一步</span>
            newA<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">unique</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let unique= [...new Set(array)];
//es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。
//Set内部使用===来判断是否相等，类似'1'和1会两个都保存，NaN和NaN只会保存一个
</code></pre></div><hr> <div class="language- extra-class"><pre class="language-text"><code>翻转一个字符串
let a=&quot;hello word&quot;;
let b=[...str].reverse().join(&quot;&quot;);//drow olleh
</code></pre></div><hr> <p>四种定位的区别</p> <p>static 是默认值
relative 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中
absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。
fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。
sticky: position:relative 和 position:fixed</p> <hr> <p>怎么判断两个对象相等？
JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//false</p> <hr> <p>性能优化？</p> <ul><li>代码打包以及分割</li> <li>减少DOM操作</li> <li>减少 http 请求， 多用缓存</li> <li>图片懒加载</li></ul> <hr> <p>数组中最大差值</p> <div class="language- extra-class"><pre class="language-text"><code>let arr = [23, 4, 5, 2, 4, 5, 6, 6, 71, -3];
const difference = arr =&gt; {
    let max = Math.max(...arr),
        min = Math.min(...arr);
    return max - min ;
}
console.log(difference(arr)) // 74

</code></pre></div><hr> <p>输入a = 2,b = 3,输出 a = 3,b = 2</p> <div class="language- extra-class"><pre class="language-text"><code>let a = 2,
    b = 3;
const swop = (a, b) =&gt; {
    b = b - a;
    a = a + b;
    b = a - b;
    return [a,b];
}
console.log(swop(2,3)) // [3,2]
</code></pre></div><hr> <p>冒泡排序算法就是依次跟其他元素比较大小，小的的大的进行位置上的交换。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">let</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><hr> <p>跨域</p> <p>JSONP
不支持post请求，因为script只支持get请求
原理：利用<script></script></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/laoregege-blog/assets/js/app.41457635.js" defer></script><script src="/laoregege-blog/assets/js/2.afa2900c.js" defer></script><script src="/laoregege-blog/assets/js/22.ec116f47.js" defer></script>
  </body>
</html>
