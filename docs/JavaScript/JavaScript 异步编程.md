# JavaScript 异步编程

- JavaScript 异步编程
  - 事件循环和异步回调
  - Promise
  - Generator + Promise
  - Async/Await

## 同步异步

同步和异步是相对的概念，从本质上来理解：

- **同步即事物之间有顺序依赖关系，必须等上一事物完成才能进行下一事物**
- **异步则是事物之间是独立存在的，没有顺序依赖关系，他们可以同时发生或者不同时间发生**

总之，**同步异步的区别就是事物之间有无顺序关联关系**。

如何理解异步？最好的方式就是**从个体视角去看待事物问题**，比如经典的消息通信例子：比如你发送电子邮箱，如果是同步方式，你需要等待对方回复，异步则是你不需要等待邮件回复，邮件回复事件是独立发生，你只要不定时去查看邮箱或者系统通知就行了。

总之，**同步、异步只是一种模式，在不同语境下代表不同含义，但本质还是一样的**，比如说异步编程。

## 异步编程

数编程语言默认下都是同步的，因为微观下 CPU 执行执行本身就是一条条同步执行，
你可以想象在理想情况语言指令一一映射对应的 CPU 指令理解来看。

要实现异步任务，
- 语言级层面，借助编译器调整执行顺序或者运行时通过状态机制来调度任务实现
- 操作系统层面，借助多线程、硬件实现

同步、异步在编程语言中指的是执行步骤在一个控制流序列中按的顺序，，每条语句、每个方法都是同步执行调用的

使用**异步意味着代码不再是按照逻辑顺序执行，而是独立于主程序流而发生**。

JavaScript 默认情况下是同步的，并且是单线程的，这就意味着一旦遇到耗时的操作， JavaScript 无法创建新的线程来执行异步操作。

- 异步调用
  - 事件循环、消息队列
- 任务调度
  - 任务队列

线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元

异步流程控制

- callback 与事件循环
- 发布/订阅
- promise
- generator
- async/await



在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。

现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。

为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。

为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。













<img src="./images/01e40e30db7e8a91eb70ce02fd8a6985.png" alt="img" style="zoom:80%;" />



## Promsie


Node.js 通过单线程 + 事件循环解决了并发问题。而我们使用 Node.js 利用 Cluster 模块根据 CPU 核心数创建多进程解决的是并行问题

进程是系统进行资源分配和调度的基本单位，
线程是操作系统能够进行运算调度的最小单位

并发指的某个时间点多个任务队列对应到同一个 CPU 上运行，在任一时间点内也只会有一个任务队列在 CPU 上执行，这时就产生排队了。

为了解决这个问题，CPU 运行时间片会被分成多个 CPU 时间段，每个时间段给各个任务队列执行（对应多个线程），这样解决了一个任务如果造成阻塞，不会影响到其它的任务运行，同样线程是会自动切换的。

线程是系统级别的调用
协程是语言层面的调用
协程之间的调用不需要涉及任何系统调用，是语言层级的构造，可看作一种形式的控制流，有时候我们也会称它为用户态的轻量级线程。

协程与线程两者的差异，可以看出 “同一时间如果有多个线程，但它们会都处于运行状态，线程是抢占式的，而协程同一时间运行的只有一个，其它的协程处于暂停状态，执行权由协程自己分配”。

## Generator（生成器）

生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。

```js
function* gen() {
    yield 1
    yield 2
    yield 3
}

const g = gen()

console.log(g.next().value) // 1

console.log(g.next().value) // 2

console.log(g.next().value) // 3
```

1. 如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行
2. 外部函数可以通过 next 方法恢复函数的执行

在 JavaScript 中，生成器就是协程的一种实现方式。

### 协程

协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

父子协程之间调用栈切换