---
release: true
top: 3
tags:
 - javascript
 - 异步
 - 编程语言
---

# JavaScript 异步编程

- JavaScript 异步编程
  - [异步编程](#何为异步编程)
  - JavaScript 并发模型：事件循环与消息队列
  - JavaScript 异步编程范式
    - 异步回调
    - 发布订阅模式
    - Promise
    - 函数响应式编程
    - Async/Await
      - Generator & co

## 何为异步编程

同步/异步是一种术语在不同场景下有不同层面的意思。个人觉得比较广义的说法，同步/异步关注的是事物之间的行为模式、协作关系：一个事物的发生必须等待另一事物的结果，这就是同步，反之亦是异步，说明事物之间没有因果顺序关系，是独立性的。

在编程语言中，同步编程意味着任务的执行流程跟代码的编写调用顺序是一样的，而异步编程模型中，代码更多是被组织成为了异步任务单元，任务的发生、执行顺序不再像同步编程那样直观、可预测，因为他们之间没有明确的时序关系，统一由异步运行时并发调度。

> 💡 并发是系统拥有同时与多件事情打交道的能力；并行是同时处理多件事情的手段；并行是并发的子集 

编程语言的异步体系构成：
- 硬件层
- 操作系统
- 并发模型

硬件层：我们世界的事物是在并发发生的，计算机的内部硬件同样如此。比如多个 CPU 可以并行工作；CPU 可以与 IO 设备异步进行，IO 设备通过 DMA 方式直接与内存打交道，然后通过中断信号后通知 CPU 再来读取相应的设备缓冲区。

操作系统：大多数编程语言都是同步模型，但实际上我们的程序在计算机内部却是并发执行的，操作系统以线程作为最小调度执行单位并且分时调度我们的代码（操作系统会保存上下文及执行位置以便恢复原来执行），这对于开发者来说是无感的，并且操作系统还帮我们屏蔽硬件层面的异步，（主要）提供了阻塞的系统调用，这样的一切使得我们程序表现出一种同步执行效果。

并发模型：为了保证并发系统设计的正确性人们试图通过形式化的模型来规范它，并发模型主要分为**线程模型**和**异步模型（事件驱动）**，从理论上说，本质上两者是等价的，它们都是调度代码执行的手段，或者说在计算机里模拟并发性的手段。区别：
- 线程适合处理事务之间有着明显因果关系或者相关性很强的场合，事件驱动机制会把代码搞的支离破碎
- 事件驱动比较擅长处理异步事件的问题，但当需要处理跨事件的事务逻辑时，事件驱动都会变得复杂难解；事务驱动有一点优势的地方，就是它与生俱来的并发性和灵活性
- 线程是分时调度或抢占式调度机制；而事件驱动机制则采用单线程事件循环、协程这样一种同步调度或者协作式的调度机制
- 使用协作式多任务处理的应用程序的编程难点在于，切换处理，保持上下文环境，这些职责都落在了可怜的开发者肩上了或者由编程语言去实现异步运行时和编程范式；而线程模型则由操作系统自带

那么异步编程相比同步编程究竟有什么好处？使用异步编程可以提高系统的并发性，相当于提高系统的响应性和资源利用率。

任务一般分为 IO 密集型和 CPU 密集型。而 web 领域是一个 IO 密集的场景：主流的多线程并发方案不仅要面对竞争条件、死锁等编程问题，更重要的是绝大部分线程都处在等待网络响应或者等待磁盘读取中，CPU 的利用率依然很低，而且大部分 CPU 都耗在操作系统的线程调度上了；而且线程也是资源，它们不是免费的，系统有数量限制。

**异步编程主要是解决 CPU 上下文切换消耗问题，提高 CPU 利用率**。  

**异步编程本质上是带有用户空间线程的协作式多任务处理机制**，应用程序在用户空间中管理"线程"和上下文切换。基本上，在异步世界中，上下文切换仅发生在定义好的切换点，而不是非确定性的时间间隔。

总结来说异步编程是一种并发编程模型，**代码之间具有异步关系才具备并发性**，保证单个事务的连续性（代码是异步执行，但业务逻辑必须是同步调度），是编程中处理异步问题的关键解决之道。

接下来，我们来看看 JavaScript 异步编程中的异步运行时和编程范式。

## JavaScript 异步编程范式

- JavaScript 异步编程范式
  - 异步回调
  - 发布订阅模式
  - Promise
  - 函数响应式编程
  - Async/Await
    - Generator & Promise

### Async/Await 实现原理

Async/Await 其实只是语法糖，通过编译器编译成 Generator 函数和内置一个Promise 自动执行器。

```js
function _async(gen) {
  const g = gen()
  return new Promise((resolve, reject) => {
    const co = function(res, err) {
      try {
        let { value, done } = err ? g.throw(err) : g.next(res);
        if(done) {
          resolve(value) 
        } else {
          Promise.resolve(value).then(co, (err) => co(null, err))
        }
      } catch (error) {
        reject(err)
      }
    };
    co();
  });
}

function* g() {
  let res = yield Promise.resolve().then(() => 1);
  res += yield Promise.resolve().then(() => { throw 2 } );
  // try {
  //       res += yield Promise.resolve().then(() => { throw 2 } );
  // } catch (error) {
  //       console.log(error)
  // }
  return yield res;
}

_async(g).then((res) => {
  console.log(res);
});
```

## 参考

- [从根本上了解异步编程体系](https://zhuanlan.zhihu.com/p/434361727)
- [白话并发模型和异步编程范式](https://code2life.top/2021/05/31/0062-concurrent-model-async-programming/)
- [并发编程模型：事件驱动 vs 线程](https://zhuanlan.zhihu.com/p/32961438)
- [Asynchronous programming. Blocking I/O and non-blocking I/O](https://luminousmen.com/post/asynchronous-programming-blocking-and-non-blocking)
- [Asynchronous programming. Cooperative multitasking](https://luminousmen.com/post/asynchronous-programming-cooperative-multitasking)
- [Asynchronous programming. Await the Future](https://luminousmen.com/post/asynchronous-programming-await-the-future)

## Promise

- 回调问题：
  - 回调地狱
  - 分流结果处理：每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性
- Promise 优点
  - 链式调用、错误冒泡：消灭嵌套调用和多次错误处理

1. 链式调用
2. 延迟绑定
3. 值穿透
4. 异步调用






## Promsie



为了解决这个问题，CPU 运行时间片会被分成多个 CPU 时间段，每个时间段给各个任务队列执行（对应多个线程），这样解决了一个任务如果造成阻塞，不会影响到其它的任务运行，同样线程是会自动切换的。

线程是系统级别的调用
协程是语言层面的调用
协程之间的调用不需要涉及任何系统调用，是语言层级的构造，可看作一种形式的控制流，有时候我们也会称它为用户态的轻量级线程。

协程与线程两者的差异，可以看出 “同一时间如果有多个线程，但它们会都处于运行状态，线程是抢占式的，而协程同一时间运行的只有一个，其它的协程处于暂停状态，执行权由协程自己分配”。






协程本质上和单线程+状态机是等价的，只是用协程的话，协程负责来保存状态，开发起来方便些。



协程只有在等待IO的过程中才能重复利用线程 IO密集
协程只有和异步IO结合起来，才能发挥最大的威力


Javascript 执行引擎仍然是一个基于事件循环的单线程环境，


1. 定义
   1. 在浏览器中有 HTML 规范来定义事件循环的处理模型
   2. Node.js 中事件循环的定义与实现均来自于 Libuv。
2. 顺序
   1. Node.js 官网展示的事件循环分为 6 个阶段，每个阶段都有一个 FIFO（先进先出）队列执行回调函数，这几个阶段之间执行的优先级顺序还是明确的




工作经历
    2015年7月~2016年1月，实习于东方海外（OOCL），参与AngularJS、Node.js开发。
    2016年3月~2018年4月，就职于科大讯飞教育业务部门，承担多个系统前后端开发工作，包括服务端（Java SSM、ASP.Net MVC、Node.js & MySQL、Oracle、MongoDB）, 客户端C++, C# (WinForm/WPF/CEF), NW.js, 以及前端AngularJS、Vue的开发。期间负责的其中两个系统服务端的性能优化工作，关键业务性能提升近十倍。
    2018年4月后，入职软视软件（ZOOM），参与会议室相关的业务开发：
        2018年，解决了某重量级Node.js系统的多个可用性及性能问题：CPU占用率过高，进程Crash，内存泄漏，缓存，限流，负载均衡等等。并用Typescript和RxJS对其中一个实时通信组件重写；
        2018年11月左右，开始参与后端业务拆分和微服务化转型，主导云原生DevOps方案落地，包括构建Kubernetes集群，Prometheus监控告警平台，SpringCloud项目的CI/CD流水线，Docker基础镜像以及容器编排等，同时构建并标准化了新的前后端分离Vue项目的CI/CD流程。
        2019年5月开始，负责其中一个子业务进行SpringCloud微服务化重构，包括前端和后台开发，新旧系统间数据同步和迁移，基础公共组件的开发等等。
关于我
    2016年本科毕业于南京大学软件工程专业，长期参与一线开发工作，喜欢尝试新技术，读源码思考原理。JS/TS的前后端开发比较熟练，对Node.js有一些理解；在云原生技术栈方面，对Golang、Kubernetes、Service Mesh等技术略知一二，在DevOps领域有一些实践和理解；Java技术栈工作使用较多，相对熟练。业余时间喜欢捯饬单片机和单板计算机，学习探索物联网领域。
发布有技术类微信公众号 "Anti丨Entropy"，我所理解的生命的意义即 —— 制造反熵（Anti-Entropy




异步编程的核心理念是异步操作：启动了的操作将会在一段时间后完成。这个操作正在执行时，不会阻塞原来的线程。启动了这个操作的线程，可以继续执行其他任务。当操作完成时，会通知它的future，或者调用回调函数，以便让程序知道操作已经结束。






- 并发模型
  - 设计要素
    - 粒度
      - 指令
      - 函数
      - 程序
    - 调度
    - 通信
      - 共享内存
      - 消息传递
    - 同步
    - 编程范式
  - 编程范式
    - 线程模型
      - 多线程 + 锁 + 阻塞IO
    - 异步模型（事件驱动）
      - 异步回调 + 单线程事件轮询
        - 发布订阅模式：把callback丢出去不管了；因为事件模式，解开了Callback，会带来逻辑碎片化的问题。也就是说，完全靠Event Listener无法写出高内聚的代码。
        - Promise
        - 函数响应式编程：把callback做成烤串；
        - Async/Await
          - Generator & co
      - 协程
        - 特点
          - 框架或者编程语言将阻塞操作转为无阻塞，同时将其控制权交到其他的执行线程中
        - 模型
          - CSP
          - Actor







