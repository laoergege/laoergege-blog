# JavaScript 异步编程

- JavaScript 异步编程
  - 异步编程
  - 异步回调：事件循环与消息队列
  - Promise
  - Generator & co
  - Async/Await

## 异步编程

> 曾有一段时间“沉迷”在何为异步编程？异步编程就是异步调用？异步编程跟并发编程有什么区别，好像都用到了多线程？异步、并发、并行好像都挺一样的？问题上无法自拔 😱

同步/异步关注的是事物之间的行为模式、协作关系**
  > 一个事物的发生必须等待另一事物的结束，这就是同步，反之亦是异步，说明事物之间没有因果顺序关系，是独立发生的

异步编程 = 并发编程模型 + [语法特征]

## 参考

- [从根本上了解异步编程体系](https://zhuanlan.zhihu.com/p/434361727)
- [白话并发模型和异步编程范式](https://code2life.top/2021/05/31/0062-concurrent-model-async-programming/)

## Promise

- 回调问题：
  - 回调地狱
  - 分流结果处理：每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性
- Promise 优点
  - 链式调用、错误冒泡：消灭嵌套调用和多次错误处理

1. 链式调用
2. 延迟绑定
3. 值穿透
4. 异步调用





使用**异步意味着代码不再是按照逻辑顺序执行，而是独立于主程序流而发生**。

JavaScript 默认情况下是同步的，并且是单线程的，这就意味着一旦遇到耗时的操作， JavaScript 无法创建新的线程来执行异步操作。

- 异步任务
  - 编译
  - 运行时
    - 任务调度
      - 异步调用：事件循环、消息队列
    - 任务队列

线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元


现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。

为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。

为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。






<img src="./images/01e40e30db7e8a91eb70ce02fd8a6985.png" alt="img" style="zoom:80%;" />



## Promsie



为了解决这个问题，CPU 运行时间片会被分成多个 CPU 时间段，每个时间段给各个任务队列执行（对应多个线程），这样解决了一个任务如果造成阻塞，不会影响到其它的任务运行，同样线程是会自动切换的。

线程是系统级别的调用
协程是语言层面的调用
协程之间的调用不需要涉及任何系统调用，是语言层级的构造，可看作一种形式的控制流，有时候我们也会称它为用户态的轻量级线程。

协程与线程两者的差异，可以看出 “同一时间如果有多个线程，但它们会都处于运行状态，线程是抢占式的，而协程同一时间运行的只有一个，其它的协程处于暂停状态，执行权由协程自己分配”。






协程本质上和单线程+状态机是等价的，只是用协程的话，协程负责来保存状态，开发起来方便些。

用户态调度的任务，

单线程通过分时复用的方式运行多个协程

协程只有在等待IO的过程中才能重复利用线程 IO密集
协程只有和异步IO结合起来，才能发挥最大的威力


Javascript 执行引擎仍然是一个基于事件循环的单线程环境，


1. 定义
   1. 在浏览器中有 HTML 规范来定义事件循环的处理模型
   2. Node.js 中事件循环的定义与实现均来自于 Libuv。
2. 顺序
   1. Node.js 官网展示的事件循环分为 6 个阶段，每个阶段都有一个 FIFO（先进先出）队列执行回调函数，这几个阶段之间执行的优先级顺序还是明确的



计算机发展史
- 支持分时任务的操作系统：操作系统以线程作为最小调度执行单位，线程代表一个独立的计算任务，当遇到需要费时的操作时，操作系统就把当前线程停下，让 CPU 去执行别的线程任务，这样 CPU 就不需要为了要执行一个几纳秒的指令而等上两百万纳秒。如果操作系统调度得当，可以大大提高 CPU 的利用率，在相同的时间内完成多得多的任务
- 并发模型：利用多线程就是解决并发的最主流方案
- web 领域是一个 IO 密集的场景：虽然操作系统上有很多线程，但绝大部分线程都处在等待网络响应或者等待磁盘读取中，CPU 的利用率依然很低，而且大部分 CPU 都耗在操作系统的线程调度上了




工作经历
    2015年7月~2016年1月，实习于东方海外（OOCL），参与AngularJS、Node.js开发。
    2016年3月~2018年4月，就职于科大讯飞教育业务部门，承担多个系统前后端开发工作，包括服务端（Java SSM、ASP.Net MVC、Node.js & MySQL、Oracle、MongoDB）, 客户端C++, C# (WinForm/WPF/CEF), NW.js, 以及前端AngularJS、Vue的开发。期间负责的其中两个系统服务端的性能优化工作，关键业务性能提升近十倍。
    2018年4月后，入职软视软件（ZOOM），参与会议室相关的业务开发：
        2018年，解决了某重量级Node.js系统的多个可用性及性能问题：CPU占用率过高，进程Crash，内存泄漏，缓存，限流，负载均衡等等。并用Typescript和RxJS对其中一个实时通信组件重写；
        2018年11月左右，开始参与后端业务拆分和微服务化转型，主导云原生DevOps方案落地，包括构建Kubernetes集群，Prometheus监控告警平台，SpringCloud项目的CI/CD流水线，Docker基础镜像以及容器编排等，同时构建并标准化了新的前后端分离Vue项目的CI/CD流程。
        2019年5月开始，负责其中一个子业务进行SpringCloud微服务化重构，包括前端和后台开发，新旧系统间数据同步和迁移，基础公共组件的开发等等。
关于我
    2016年本科毕业于南京大学软件工程专业，长期参与一线开发工作，喜欢尝试新技术，读源码思考原理。JS/TS的前后端开发比较熟练，对Node.js有一些理解；在云原生技术栈方面，对Golang、Kubernetes、Service Mesh等技术略知一二，在DevOps领域有一些实践和理解；Java技术栈工作使用较多，相对熟练。业余时间喜欢捯饬单片机和单板计算机，学习探索物联网领域。
发布有技术类微信公众号 "Anti丨Entropy"，我所理解的生命的意义即 —— 制造反熵（Anti-Entropy