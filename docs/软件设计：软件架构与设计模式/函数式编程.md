- 函数式编程
  - 主要作用：限制使用赋值语句，它是对程序中的**赋值**施加了约束
  - 函数式编程元素就是函数，函数是一等公民，这里的函数指的是**数学的函数**
  - 函数编程的特性
    - **不可变性**：函数式编程的不变性主要体现在值和纯函数，我们使用到量不会再担心发生改变，我们调用到的函数传进去同样的参数，它保证给出同样的可预测结果，而且不会隐式改变一个外部量，造成影响。
      - 值，一旦初始化之后就不再改变的量
        - 纯函数式编程语言中的变量不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称，这就意味着变量的值是不可变的
        - 在实际上要实现不可变，对于可变变量值的操作并不是修改原来的值，而是修改新产生的值，原来的值保持不便
      - 纯函数
        - 不依赖其他状态，只依赖输入；对于相同的输入，给出相同的输出
        - 没有[副作用](https://zh.m.wikipedia.org/zh-cn/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))
    - 组合性
      - 以函数作为基本构建块，把模型拆解成多个可以组合的构造块，也是“分离关注点”的能力，然后由使用者根据自己需要将这些构造块组合起来，提供出新的模型
      - 通过高阶函数的方式，接收函数作为输入，返回一个新的函数作为输出。可以用它去做行为的组合
      - 面向对象编程是对系统结构的组合，函数式编程是对计算接口的组合
    - 循环：递归
    - 函数操作
      - 柯里化（Currying）：将一个多元函数，转换成一个依次调用的单元函数
      - 偏应用函数/部分应用函数（Partially Applied Functions）
      - Thunk：将多参函数变成只能接受一个回调参数的函数
      - 组合（Compose） 从右往左
      - 管道（Pipe）
      - 
      - Monad：函数式编程不太擅长处理可变状态和处理 IO，要么引入可变变量，要么通过 Monad 来进行封装（如State Monad和IO Monad）
      - 惰性求值
      - 
      - 
      - 闭包（Closure）
  - 列表转换思维：
    - 最基础的三个转换是：map、filter 和 reduce


真正原因就在于变量是可变的，

1. 使用不可变变量
2. 如果需要有改变对象，返回一个新的对象，而不是修改已有字段
3. 尽量所有的方法都是纯函数：编写纯函数的重点是，不修改任何字段，也不调用修改字段内容的方法

纯粹的函数式编程是很困难的，我们只能把编程原则设定为尽可能编写不变类和纯函数。


Event Sourcing，把对象的状态每次变化抽象成独立的事件进行保存，对象的状态变化可由一系列事件的调用重现。 编写不变类，无可变化的状态；Event Sourcing记录每一次状态变化。




函数式编程给自己提供了一种新的代码重构思路-通过函数单元将数据逻辑处理和条件隔离开来。另外，提升了自己的编程抽象思维，多态不是绝对依赖于继承，而是依赖于函数。“走路像鸭子，叫声像鸭子，那么它就是鸭子”，这就是多态思想。有幸看过go语言的开源项目，对多态思想有了新认识，提高了编程抽象思维。设计关注点开始从关注细节实现向宏观统筹开始转变。




设计可以组合的函数接口：一个好的函数式的接口，需要我们做的同样是“分离关注点”

函数式编程中，还有一个重要的体系，就是列表转换的思想，将很多操作分解成若干转换的组合。最基础的三个转换是：map、filter 和 reduce，更多的转换操作都可以基于这三个转换完成。



函数式编程其实也是一种对传统编程思想的转变 面向对象编程是对系统结构的组合，函数式编程是对计算接口的组合 这些编码规则或者范式也是对“分离关注点”的深刻理解之后抽象出来的标准模式 如果同样问题经常出现，那么标准的解决方案也会出现


函数式编程，stream和响应式编程三者分别的本质是什么





变化是软件开发的永恒主题，所以在编码实践上尽量的编写不变的纯函数和类，将变化的粒度控制到最小
作者回复: 变化是需求层面的不得已，不变是代码层面的努力控制。











所谓状态是对象某时间的快照，我们引入状态却把时间参数隐藏起来，于是我们不得不引入锁来保持一致性。强一致性（控制），最终一致性（回避），事件溯源（引入），这一步步正是重新正视我们过去抽象偷懒引来的问题。计算或逻辑本来就没有状态概念，减少多余概念的消耗，可以发挥计算最大效能。






函数式编程初步
起源于Lambda 演算，我们这里不关心 Lambda 演算的数学逻辑，你只要知道，Lambda 演算和图灵机是等价的，都是那个年代对“计算”这件事探索的结果。

从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是图灵完全（Turing completeness）的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的。









monad来源于范畴论

单子在哲学里是个重要的概念，大致意思就是完整单个的个体却能反射出整个世界

函数式的纯洁性在于对于一个特定的参数，必定存在一个特定的返回值。所以函数式的执行是无关顺序的。
而在现实世界里，很多东西就必须是有顺序的，比如输入输出。于是Haskell决定用monad去模拟这种操作。monad来源于范畴论，他并不解决副作用问题本身，而是对此类问题提供了抽象。