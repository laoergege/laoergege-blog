---
tags:
 - rust
---

# 内存安全：所有权、借用及生命周期

所有权和生命周期是 Rust 和其它编程语言的主要区别，也是 Rust 其它知识点的基础。

- Rust 内存机制
  - 所有权：Rust 通过单一所有权来限制任意引用的行为
    - 一个值只能被一个变量所拥有，这个变量被称为所有者（杜绝多重引用带来的不可预测）
    - 一个值同一时刻只能有一个所有者：一旦发生赋值、传参以及函数返回时，就会**把值的所有权转移（Move）给新的所有者**，之前的变量就不能访问
      - Copy 语义和 Copy trait：如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行浅拷贝（值会被按位拷贝一份），否则使用 Move 语义进行移动
  - 生命周期：当程序离开所有者的作用域，其拥有的值被丢弃
  - 借用

所有权转移：

```rust
fn move_var_ownership() {
    let num = 123;
    let num2 = num;
    println!("{}", num); // success

    let data = vec![1, 2, 3, 4];
    //移动：所有权一旦转移，旧变量将不再有效
    let data1 = data;
    println!("data1: {:?}", data); // error
}
```

Rust 哪些类型会发生复制：

- 原生类型，包括函数、不可变引用和裸指针实现了 Copy；
- 数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；
- 可变引用没有实现 Copy；
- 非固定大小的数据结构，没有实现 Copy。

> TODO: 相比其他语言，Rust 在对变量赋值、传参以及函数返回时的行为不够直观，但是否可以一般来说，数据分配在栈的通常为 Copy 行为，而分配在堆上的则只能 Move 行为。也就是原始类型而言则是直接复制，对于引用类型则会“所有权移动”。🤔

## 生命周期

当程序离开 "hello" 所有者变量 s 所在生命周期（作用域），其拥有的值被丢弃。

```rust
fn main() {
    let s_ref;                                   ——————————————————————                      
    {                                                                 ｜
        let s = String::from("hello");   ----------                   ｜ 
                                                  |                   ｜
                                                  s 生命周期范围        s_ref 生命周期范围
        s_ref = &s;                      _________|                   ｜ 
    }                                                                 ｜ 
    println!("{}", s_ref);                       ——————————————————————
}
```

##  借用
