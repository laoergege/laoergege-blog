---
tags:
 - rust
---

# 内存安全：所有权、借用及生命周期

- 所有权
  - Rust 通过**单一所有权**来限制任意引用的行为：一个值只能被一个变量所拥有，这个变量被称为所有者，杜绝多重引用带来的不可预测
  - 值使用：值只能所有者使用，当想通过其他方式使用呢？
    - 值复制：在绑定、传参以及函数返回时，如果值的类型实现了 **Copy trait**，就会自动使用 Copy 语义进行拷贝（值会被按位拷贝一份），否则使用 Move 语义进行移动，即**把值的所有权转移（Move）给新的所有者**，之前的变量就不能访问
    - **所有权转移**：所有权一旦转移，旧变量将不再有效
    - **借用**：将创建一个引用的行为称为**借用**
      - `&T：不可变借用`、`&mut T: 可变借用`
      - 借用规则：
        - 在同一作用域只能有一个可变借用
        - 在同一作用域，不能在不可变引用前使用可变引用
        - 禁止值的声明周期导致空引用
- 生命周期：当程序离开所有者的作用域，其拥有的值被丢弃

## 值复制：Copy trait & Clone trait

如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量时就会发生值复制并且旧变量仍然可用。那么 Rust 类型系统中哪里类型实现 Copy trait：

## 所有权转移

```rust
fn move_var_ownership() {
    let num = 123;
    let num2 = num;
    println!("{}", num); // success

    let data = vec![1, 2, 3, 4];
    //移动：所有权一旦转移，旧变量将不再有效
    let data1 = data;
    println!("data1: {:?}", data); // error
}
```

##  借用

## 生命周期

当程序离开 "hello" 所有者变量 s 所在生命周期（作用域），其拥有的值被丢弃。

```rust
fn main() {
    let s_ref;                                   ——————————————————————                      
    {                                                                 ｜
        let s = String::from("hello");   ----------                   ｜ 
                                                  |                   ｜
                                                  s 生命周期范围        s_ref 生命周期范围
        s_ref = &s;                      _________|                   ｜ 
    }                                                                 ｜ 
    println!("{}", s_ref);                       ——————————————————————
}
```