---
release: true
top: 2
tags:
  - 事件循环
desc: 总结消息队列和事件循环系统心智模型
---

# 消息队列和事件循环系统

> 网上对事件循环介绍的文章太多了，本文笔者只是总结事件循环的心智模型要点

1. 事件循环系统是 HTML 标准定义的，用户代理实现，而不是 JavaScript 引擎提供的，JavaScript 引擎只是等待用户代理分发 JS 任务
2. 事件循环系统的本质是一个 user agent 上协调调度各类事件任务的机制
   > 为了防止资源竞争，在 Chrome 中每个渲染进程只有一个主执线程，主执行线处理 DOM 构建、计算样式、处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。
3. 宿主环境发起的任务称为宏任务，把 JavaScript 引擎发起的任务称为微任务
4. 宏任务、微任务分别对应消息队列中的**宏任务队列**和**微任务队列**两种类型队列
5. 心智模型：事件循环系统

   1. 主线程从宏任务队列取一任务执行
   2. 再循环执行完微任务队列里的所有任务
   3. 重复 1、2 步骤

   ![图 2](./images/1645524610613.png)

   心智代码：

   ```js
   for (let task of macroQueue) {
     task();

     for (let microTask of microQueue) {
       microTask();
     }
   }
   ```

6. 在心智模型建设上，为了方便只抽象了一个宏任务队列，但实际实现上并不是单消息队列架构而是多消息队列架构。
   - Blink 任务调度细节
     - 按照不同的任务类型来划分任务优先级
     - 基于不同的场景来动态调整消息队列的优先级
       ![图 3](./images/1645541022331.png)  
       ![图 5](./images/1645602449768.png)  
       ![图 6](./images/1645602532010.png)  
     - 设置队列权重：如果连续执行了一定个数的高优先级的任务，那么中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况
7. JS 任务主要是单线程同步执行，对于异步任务的实现主要是通过环境提供的异步API + 异步回调的范式去支持
8. JS 异步任务调度API
   - 宏任务
     - script
     - MessageChannel、postMessage
     - requestAnimationFrame：跟随系统 VSync 信号调度，在每一帧渲染之前执行
     - 渲染
     - setTimeout、setInterval
       - setTimeout 限制
         - 如果当前任务执行时间过久，会影响定时器任务的执行
         - 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
         - 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
         - 延时执行时间有最大值 大约 24.8 天
     - ajax、fetch 网络等
     - requestIdleCallback
   - 微任务（微任务其实是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前）
     - promise.then、promise.reject（JS 规范实现即引擎自带）
     - MutationObserver（DOM4 规范实现，注入到引擎中）
     - queueMicrotask
9. 在每一次的事件循环结束后不一定会执行渲染
    > 浏览器渲染有个渲染时机（Rendering opportunity）的问题，也就是浏览器会根据当前的浏览上下文判断是否进行渲染，它会尽量高效，只有必要的时候才进行渲染，如果没有界面的改变，就不会渲染

### 微任务队列

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。


## requestAnimationFrame

使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销

promise 实现

1. executor
2. 延迟绑定回调函数
3. 链式调用
4. 回调函数返回值穿透到最外层
5. 错误冒泡

回调地狱的问题：

1. 多层嵌套的问题，不符合人的线性思维方式、直观
2. 还要分别回调处理这两种成功失败可能性

Generator 的底层实现机制——协程（Coroutine）

async/await 使用了 Generator 和 Promise 两种技术，

yield




MutationObserver 采用了“异步 + 微任务”的策略。通过异步操作解决了同步操作的性能问题；通过微任务解决了实时性的问题。