# 消息队列和事件循环系统

> 事件循环是 HTML 标准定义的，用户代理实现，而不是 JavaScript 引擎提供的

每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。

> 事件循环的本质是一个 user agent 上协调调度各类事件任务的机制

单线程不停工作，循环机制
不浪费CPU，事件机制
不阻塞，异步回调



其他线程不断得把任务事件放进消息队列里，主线程不断从消息队列取任务执行


单线程、事件循环

渲染进程的任务调度系统

渲染进程内部的大多数任务都是在主线程上执行的，诸如 JavaScript 执行、DOM、CSS、计算布局、V8 的垃圾回收等任务。要让这些任务能够在主线程上有条不紊地运行，就需要引入消息队列。

主线程维护了一个普通的消息队列和一个延迟消息队列，调度模块会按照规则依次不断取出这两个消息队列中的任务，并在主线程上执行。

宏任务
微任务


等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务

单消息队列架构
- 队头阻塞问题
- 低优先级任务会阻塞高优先级任务


多消息队列架构

将任务划分为多个不同的优先级，来实现更加细粒度的任务调度

![图 4](./images/bbe47340e34b0d6cea4a487a75437ccecec3a20ee655e205a7ecee63a9ff7df7.png)  


在渲染进程中引入一个任务调度器，负责从多个消息队列中选出合适的任务，通常实现的逻辑，先按照顺序从高优先级队列中取出任务，如果高优先级的队列为空，那么再按照顺序从低优级队列中取出任务。

## 多个消息队列及优先队列

### setTimeout 延迟队列

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

使用 setTimeout 的一些注意事项
1. 如果当前任务执行时间过久，会影响定时器任务的执行
2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
4. 延时执行时间有最大值 大约 24.8 天

### 微任务队列

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

MutationObserver（DOM4 规范实现，注入到引擎中）、Promise（JS 规范实现即引擎自带）

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。

![图 1](images/376098ad2cda9dfc61a0309697ca4ca53d54ba9e2f2e6b17d353a92450990824.png)  

![图 2](images/d137d00a2fe3b8a9f3841485edb1a723c7a2be0d2b06052d710b98943e3018ac.png)  



## requestAnimationFrame

使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销


promise 实现
1. executor
2. 延迟绑定回调函数
3. 链式调用
4. 回调函数返回值穿透到最外层
5. 错误冒泡


回调地狱的问题：
1. 多层嵌套的问题，不符合人的线性思维方式、直观
2. 还要分别回调处理这两种成功失败可能性

Generator 的底层实现机制——协程（Coroutine）

async/await 使用了 Generator 和 Promise 两种技术，

yield

协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

V8 是如何切换到父子协程之间的调用栈？

- 根据消息类型实现不同优先级的消息队列
  - 交互
  - 合成
  - 默认（普通）
  - 空闲


raq 交互
rAF的回调是在每个帧的开头执行