---
release: true
tags:
 - http
---

# http 各版本协议对比

- HTTP/0.9
  - 只传输超文本内容 HTML，并且只支持GET请求
- HTTP/1.0
  - 增加了 HEAD、POST 等新方法；
  - 增加了响应状态码，标记可能的错误原因；
  - 引入了协议版本号概念；
  - 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
  - 支持多种文件类型
- HTTP/1.1
  - 增加了 PUT、DELETE、OPTIONS、PATCH 等新的方法；
  - 增加了缓存管理和控制；
  - [默认支持 keep-alive 长连接](#keep-alive-长连接)
  - 允许响应数据分块（chunked），利于传输大文件；
  - 引入管道机制：一个TCP连接，可以同时发送多个请求，但要求服务端必须按照请求发送的顺序返回响应，当顺序请求多个文件时，其中一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，这也是队头阻塞 (Head-Of-Line Blocking)
- HTTP/2：改进性能，解决了 [HTTP 队头阻塞问题](#http-队头阻塞)
  - [头部压缩](#头部压缩)
  - [二进制分帧传输](#二进制分帧)
  - [多路复用](#多路复用)
    - 流
      - 唯一 ID
      - 优先级及依赖关系
      - 双向性
  - 帧控制
  - [服务推送](#服务器推送)
- HTTP/3：主要解决 TCP 队头阻塞、TCP及TSL 握手消耗
  - 基于 UDP

## keep-alive 长连接

在 HTTP/1.1 之前，客户端与服务器端的的**每次请求都需要创建 TCP 连接，服务器响应后断开 TCP 连接**，再请求再创建断开。因为客户端不会与服务器保持长时间的连接状态，所以就被称为“短连接”（short-lived connections）。

![图 1](images/750369eee85b600041095ba4e0c153ee9f146e2118e99caaa5bad96bc5702cb1.png)  

TCP 的连接和关闭非常耗时间，**长连接即在一个请求结束后保持 TCP 连接不关闭**，其他多个请求可以复用到同一 TCP 连接。

![图 5](images/a0bcce54c1f34281df9e345b474b0dfd0bfb939318933a4529dca34e12ac4b6c.png)  

## http 队头阻塞

即使是使用了长连接，但在同一条 TCP 连接中，由于 http 的请求应答模式，决定了 http 是“半双工”，只能一发一回收发数据，队列后边的请求必须等待队首完成，如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，这就是 http 队头阻塞的根源。

![图 4](./images/21eeea004e945f9c27eede678a686d7137192c66f916bafb1c5fe2caab24c90c.png)  

## 头部压缩

http 请求头可能带有很多字段或者每次传输重复字段都会导致带宽浪费，HTTP/2 使用 “HPACK” 算法进行“头部压缩”：

1. 浏览器和服务器会维护一个相同的静态表和一个动态表，以及内置一个静态霍夫曼编码表
2. 静态表存储的是常见的一些头部，和一些很常见的头部键值对
   ![图 27](./images/1649176543339.png)  
3. 动态表初始为空，添加在静态表后面，结构相同
4. 请求、响应头部中对于静态表里未出现过的字段或者对应值则经过哈夫曼压缩编码发送之后，客户端和服务器更新自己的动态表；对应已有的则只需发送索引值
   ![图 26](./images/1649175617174.png)  

## 二进制分帧

![图 24](./images/binary_framing_layer01.svg)  

二进制分帧层是在应用层和传输层之间的中间层，HTTP/2 采用了类似于 TCP 数据包二进制结构，将数据分割成多个数据包（简称帧），并对其进行二进制结构化编码，并且每个帧都分配给一个唯一“流” ID。

![图 6](./images/b631c1a3b6db5767ed5e6bbd85155934dad4aa978a94d0da959efe9756a5c473.png)  

- 帧类型
  - 数据帧
    - HEADERS 帧
    - DATA 帧
  - 控制帧
    - SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。
- 帧标志：携带简单的控制信息
  - END_HEADERS：表示头数据结束，相当于 HTTP/1 里头后的空行（“\r\n”）
  - END_STREAM：表示单方向数据发送结束（即 EOS，End of Stream）
- 流标识符：帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”

## 多路复用

每个帧都分配给一个“流”：这里的“流”，其实是一个虚拟的概念，在同一个 TCP 连接中所有消息都是被分成多个帧乱序发送，每条“流”其实可以看作是每个 http 请求，属于同一个 http 请求的消息往返的帧会分配一个唯一的流 ID，将同一个流ID的帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。

![图 7](./images/43efe9a0eb0235d9d6510f524a67913eef49c5f0baefb56a125d34ccc3e31cb9.png)  

http2 就可以在一个 TCP 同时发送接受多个请求“碎片化”的消息，这就是常说的“多路复用”（ Multiplexing）——多个往返通信都复用一个连接来处理。

## 服务器推送

http2 保留了应用层 http “请求 - 响应答” 语义，是为了兼容保证上层应用继续工作，
但底层不再 “请求 - 响答” 的工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）。

![图 25](./images/push01.svg)  

## 参考

- [HTTP/2](https://hpbn.co/http2/)
- [详解 HTTP/2 头压缩算法 —— HPACK](https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/HTTP:2_Header-Compression.md#3-indexing-tables)
- [Why is it said that HTTP2 is a binary protocol?](https://stackoverflow.com/questions/58498116/why-is-it-said-that-http2-is-a-binary-protocol)







管道机制会造成什么样的问题，http2.0是怎么解决的


http2.0允许服务器主动推送消息，那跟WebSocket有什么区别吗？




- tcp
  - 启动慢
  - 用塞窗口


帧里有流id，流里的帧是有序的
tcp会保证有序送达，多个流是并行乱序发，但看单个流，它里面的帧还是有序的。
tcp层是有序的，所以一个流里的多个帧会按照顺序依次到达，接收方只要依次接收就可以了。


二进制的好处显而易见，用位来表示信息，要比字符串表示简单，比如用01表示host，而用字符串就需要4个字节，而且要用状态机去检测单词，非常麻烦。

http/2在底层是二进制，解析起来快速方便，然后再到应用层对字符串做个映射就行了，不是再编码。

可以再用hpack来理解一下。


UDP 是无序的，包之间没有依赖关系

httpdtzs
- 请求应答模式
- 无法识别



> 二进制格式指的是内容格式，不是编码格式，计算机底层下传输的都是二进制数据

HTTP/1.x 里的报文是纯文本形式。对于 TCP 上数据流读取的时候，消息头必须按照必须逐个字符来解析，直到到达换行符为止；而消息体则是按照消息提示的主体长度 `content-length` 去读取。

这也解释了[长连接中队头阻塞问题](#默认支持长连接)：队列后面的 TCP 请求必须等待前面的请求响应完成，**因为文本流读取的过程是一个整体，不可拆分**。


为什么采用二进制
- 首先就是效率会更高，计算机最喜欢处理二进制数了

- 在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接
- keep-alive 
- 请求-应答模式，队头阻塞
- 将 HTTP 消息分解为独立的帧，交错发送，最后再在另一端把它们重新组装起来。分帧、多路复用


 SPDY