---
tags:
 - javascript
 - error
 - try
 - catch
---

> 参考
>
> [使用 promise 进行错误处理](https://zh.javascript.info/promise-error-handling)
>
> [错误处理，"try..catch"](https://zh.javascript.info/try-catch)



```javascript
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);
```

1. `try..catch` 结构只能「捕抓」到同步的错误

2. Promise 的执行者（executor）和 promise 的处理程序（handler）周围有一个“隐式的 `try..catch`”，但是该函数本身要稍后才才抛出错误，这时引擎已经离开了 `try..catch` 结构



错误处理几种语法结构

- try...catch

- try..catch...finally

- try..finally

  

**finally** 和 **return**

`finally` 子句适用于 `try..catch` 的 **任何** 出口。这包括显式的 `return`。在下面这个例子中，在 `try` 中有一个 `return`。在这种情况下，`finally` 会在控制转向外部代码前被执行。

```javascript
function func() {

  try {
    return 1;

  } catch (e) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}

alert( func() ); // 先执行 finally 中的 alert，然后执行这个 alert
```



**try..finally**

没有 `catch` 子句的 `try..finally` 结构也很有用。当我们不想在这儿处理 error（让它们 fall through），但是需要确保我们启动的处理需要被完成。

```javascript
function func() {
  // 开始执行需要被完成的操作（比如测量）
  try {
    // ...
  } finally {
    // 完成前面我们需要完成的那件事儿，即使 try 中的执行失败了
  }
}
```

上面的代码中，由于没有 `catch`，所以 `try` 中的 error 总是会使代码执行跳转至函数 `func()` 外。但是，在跳出之前需要执行 `finally` 中的代码。



**错误抛出**

再次抛出（rethrowing）是一种错误处理的重要模式：`catch` 块通常期望并知道如何处理特定的 error 类型，因此它应该再次抛出它不知道的 error。

使用 `throw` 操作符来生成自定义的 error。从技术上讲，`throw` 的参数可以是任何东西，但通常是继承自内建的 `Error` 类的 error 对象



**全局 catch**

即使我们没有 `try..catch`，大多数执行环境也允许我们设置“全局”错误处理程序来捕获“掉出（fall out）”的 error。在浏览器中，就是 `window.onerror`。