(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{395:function(t,a,e){t.exports=e.p+"assets/img/content.dc5502b8.png"},396:function(t,a,e){t.exports=e.p+"assets/img/微信截图_20200606152948.68499927.png"},397:function(t,a,e){t.exports=e.p+"assets/img/pixels.84ae0c89.png"},398:function(t,a,e){t.exports=e.p+"assets/img/stages.c59952c7.png"},399:function(t,a,e){t.exports=e.p+"assets/img/微信图片_20200606191641.4c79b8f6.png"},400:function(t,a,e){t.exports=e.p+"assets/img/1252c6d3c1a51714606daa6bdad3a560.1252c6d3.png"},401:function(t,a,e){t.exports=e.p+"assets/img/微信截图_20200606201932.495c6ab9.png"},402:function(t,a,e){t.exports=e.p+"assets/img/fe9a0ea868dc02a3c4a59f6080aa80b4.fe9a0ea8.png"},403:function(t,a,e){t.exports=e.p+"assets/img/88a3aac427cc7c09361eac01a85fc7b2.88a3aac4.png"},404:function(t,a,e){t.exports=e.p+"assets/img/微信截图_20200606211336.02848d50.png"},405:function(t,a,e){t.exports=e.p+"assets/img/2020-06-20001908.86368df3.png"},406:function(t,a,e){t.exports=e.p+"assets/img/2020-06-21222300.de3b948f.png"},407:function(t,a,e){t.exports=e.p+"assets/img/微信截图_20200606215912.a0b9b658.png"},408:function(t,a,e){t.exports=e.p+"assets/img/e2c917edf5119cddfbec9481372f8fc0.e2c917ed.png"},409:function(t,a,e){t.exports=e.p+"assets/img/tree.426337f8.png"},410:function(t,a,e){t.exports=e.p+"assets/img/a03eb12053aac1ac496b61a424f20119.a03eb120.png"},411:function(t,a,e){t.exports=e.p+"assets/img/微信截图_20200607154033.37304839.png"},412:function(t,a,e){t.exports=e.p+"assets/img/303515c26fcd4eaa9b9966ad7f190370.303515c2.png"},413:function(t,a,e){t.exports=e.p+"assets/img/paint-phases.45576a5f.png"},414:function(t,a,e){t.exports=e.p+"assets/img/2020-06-22000128.7913b488.png"},415:function(t,a,e){t.exports=e.p+"assets/img/paint.d7f0e9dd.png"},460:function(t,a,e){"use strict";e.r(a);var r=e(35),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("本文以 chrome 为例，分析 chrome 的页面渲染流程")])]),t._v(" "),r("h2",{attrs:{id:"blink（渲染引擎）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#blink（渲染引擎）"}},[t._v("#")]),t._v(" Blink（渲染引擎）")]),t._v(" "),r("p",[t._v("浏览器是如何将 web content 转变成屏幕显示的像素，也就是我们看到的页面")]),t._v(" "),r("p",[t._v("web content 一般指的是构成网页的物件（文本、图片、HTML、CSS、JS），\n其他内容 "),r("code",[t._v("<video>")]),t._v(", "),r("code",[t._v("<canvas>")]),t._v(", "),r("code",[t._v("WebAssembly")]),t._v(", "),r("code",[t._v("WebGL")]),t._v(", "),r("code",[t._v("WebVR")]),t._v(", "),r("code",[t._v("PDF")]),t._v(", … 则通过其他方式进行。\n因为只有 web content 的才是由渲染进程(沙箱模式)进行处理渲染的。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(395),alt:""}})]),t._v(" "),r("p",[t._v("其中 Blink 是一个 Web 渲染引擎，主要功能如下：")]),t._v(" "),r("ul",[r("li",[t._v("实现了 HTML 标准规范")]),t._v(" "),r("li",[t._v("嵌入 V8 引擎去执行 JavaScript 代码")]),t._v(" "),r("li",[t._v("请求网络资源？TODO")]),t._v(" "),r("li",[t._v("构建 DOM 树")]),t._v(" "),r("li",[t._v("计算样式和布局")]),t._v(" "),r("li",[t._v("嵌入 "),r("a",{attrs:{href:"https://chromium.googlesource.com/chromium/src/+/HEAD/cc/README.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Chrome Compositor"),r("OutboundLink")],1),t._v(" 去绘制图形")])]),t._v(" "),r("p",[r("img",{attrs:{src:e(396),alt:"Blink"}})]),t._v(" "),r("p",[t._v("Blink 作为渲染引擎被嵌入到 Chromium、Opera，WebView 等浏览器客户端中并提供 "),r("a",{attrs:{href:"https://chromium.googlesource.com/chromium/src/+/HEAD/content/public/README.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("content public APIs"),r("OutboundLink")],1),t._v(" 使用。")]),t._v(" "),r("p",[t._v("Blink 就像是胶水一样，连接调用不同基础组件（V8、Skia等），处理 web 标准规范的 content。（PS：这也是 web 能够快速发展的原因，并不需要通过编译打包，只需要输入纯文本的HTML、JS、CSS，内部便帮我即时处理渲染）")]),t._v(" "),r("p",[r("strong",[t._v("渲染引擎解析处理 web content 后转换成底层操作系统提供的图形库调用去显示页面像素")]),t._v("，在多平台的今天，有标准 API 图形库 OpenGL，但在 window 平台，还需要额外转换成 DirectX API 调用，未来还将实现更多图形库支持，如 vulkan")]),t._v(" "),r("p",[r("img",{attrs:{src:e(397),alt:""}})]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://www.chromium.org/blink",target:"_blank",rel:"noopener noreferrer"}},[t._v("Blink 文档链接"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"页面渲染流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页面渲染流程"}},[t._v("#")]),t._v(" 页面渲染流程")]),t._v(" "),r("blockquote",[r("p",[t._v("注：由于 Chrome 对 Blank 引擎某些实现的修改，某些我们之前熟知的类名有了变化，比如 RenderObject 变成了 LayoutObject，RenderLayer 变成了 PaintLayer。感兴趣的看以参阅 "),r("a",{attrs:{href:"https://www.chromium.org/blink/slimming-paint?spm=taofed.bloginfo.blog.2.1d175ac8atKvCQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("Slimming Paint"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("页面渲染有两种情况")]),t._v(" "),r("ul",[r("li",[t._v("首次渲染")]),t._v(" "),r("li",[t._v("更新事件\n"),r("ul",[r("li",[t._v("JavaScript")]),t._v(" "),r("li",[t._v("user input")]),t._v(" "),r("li",[t._v("asynchronous loading")]),t._v(" "),r("li",[t._v("animations")]),t._v(" "),r("li",[t._v("scrolling")]),t._v(" "),r("li",[t._v("zooming")])])])]),t._v(" "),r("p",[t._v("为了提高渲染效率，渲染流程就像是一条流水线，分成多个渲染阶段，每个阶段会有不同产物，当发生更新时，就可以重其中某一阶段开始执行并复用之前的产物，并且分多阶段任务执行，可以提高系统任务调度灵活性")]),t._v(" "),r("p",[r("img",{attrs:{src:e(398),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"构建-dom-树（parse-html）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树（parse-html）"}},[t._v("#")]),t._v(" 构建 DOM 树（Parse HTML）")]),t._v(" "),r("p",[t._v("浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的、并且反映 HTML 结构的数据结构——DOM 树")]),t._v(" "),r("p",[r("img",{attrs:{src:e(399),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"样式计算（recalculate-style）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#样式计算（recalculate-style）"}},[t._v("#")]),t._v(" 样式计算（Recalculate Style）")]),t._v(" "),r("h4",{attrs:{id:"解析-css-规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解析-css-规则"}},[t._v("#")]),t._v(" 解析 CSS 规则")]),t._v(" "),r("p",[t._v("和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets，在控制台中输入 document.styleSheets 查看")]),t._v(" "),r("h4",{attrs:{id:"转换样式表中的属性值，使其标准化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#转换样式表中的属性值，使其标准化"}},[t._v("#")]),t._v(" 转换样式表中的属性值，使其标准化")]),t._v(" "),r("p",[t._v("CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化")]),t._v(" "),r("p",[r("img",{attrs:{src:e(400),alt:""}})]),t._v(" "),r("h4",{attrs:{id:"计算出-dom-树中每个节点的具体样式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算出-dom-树中每个节点的具体样式"}},[t._v("#")]),t._v(" 计算出 DOM 树中每个节点的具体样式")]),t._v(" "),r("p",[t._v("会把解析后的样式规则和浏览器默认的样式规则，遍历 DOM 节点，为元素匹配样式规则并计算出最终样式，储存在 ComputedStyle 属性")]),t._v(" "),r("p",[r("img",{attrs:{src:e(401),alt:""}})]),t._v(" "),r("p",[t._v("CSS 计算规则涉及以下两个规则")]),t._v(" "),r("ul",[r("li",[t._v("样式继承\n"),r("img",{attrs:{src:e(402),alt:""}})]),t._v(" "),r("li",[t._v("样式覆盖\n"),r("img",{attrs:{src:e(403),alt:""}})])]),t._v(" "),r("h3",{attrs:{id:"布局阶段（layout）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段（layout）"}},[t._v("#")]),t._v(" 布局阶段（Layout）")]),t._v(" "),r("h4",{attrs:{id:"创建-layout-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建-layout-tree"}},[t._v("#")]),t._v(" 创建 Layout Tree")]),t._v(" "),r("p",[t._v("遍历 DOM tree 生成 layout tree，其中每个节点都是 LayoutObject 的子类，其实现相应的布局。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(404),alt:""}})]),t._v(" "),r("p",[t._v("DOM Nodes 并不是跟 layout object 一对一对应关系，比如有些情况：")]),t._v(" "),r("p",[r("img",{attrs:{src:e(405),alt:""}})]),t._v(" "),r("ul",[r("li",[t._v("display：none 的元素不会生成 layout object")]),t._v(" "),r("li",[t._v("伪元素 after 与 before 不会成 DOM Node")]),t._v(" "),r("li",[t._v("文本内联元素将会被隐式 block 包裹")]),t._v(" "),r("li",[t._v("head 标签下面的全部内容")])]),t._v(" "),r("h4",{attrs:{id:"布局计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局计算"}},[t._v("#")]),t._v(" 布局计算")]),t._v(" "),r("p",[r("img",{attrs:{src:e(406),alt:""}})]),t._v(" "),r("p",[t._v("遍历 layout tree，计算每个节点的布局信息（比如，坐标及几何等信息）（布局的计算过程非常复杂，这里不详细展开）")]),t._v(" "),r("p",[t._v("在执行布局操作的时候，会把布局运算的结果重新写回保存布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(407),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"分层（layers）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层（layers）"}},[t._v("#")]),t._v(" 分层（Layers）")]),t._v(" "),r("p",[t._v("我们看到的页面实际是由多张图层合成的，打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示：")]),t._v(" "),r("p",[r("img",{attrs:{src:e(408),alt:""}})]),t._v(" "),r("p",[t._v("通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率")]),t._v(" "),r("blockquote",[r("p",[t._v("为了提升每帧的渲染效率，Chrome 引入了"),r("strong",[t._v("分层和合成")]),t._v("的机制")])]),t._v(" "),r("p",[r("img",{attrs:{src:e(409),alt:""}})]),t._v(" "),r("p",[t._v("DOM 中某些具有特定样式的 node 会被转换为单独的 Graphic Layer，并不是 DOM 中的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层")]),t._v(" "),r("p",[t._v("Layout Object 在上面的 layout 阶段生成")]),t._v(" "),r("h4",{attrs:{id:"paintlayers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#paintlayers"}},[t._v("#")]),t._v(" PaintLayers")]),t._v(" "),r("p",[t._v("页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念。PaintLayer 是用来实现 stacking contest（层叠上下文），以此来保证页面元素以正确的显示顺序，这样才能正确的展示元素的重叠以及半透明元素等等")]),t._v(" "),r("p",[r("img",{attrs:{src:e(410),alt:""}})]),t._v(" "),r("p",[t._v("从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。")]),t._v(" "),r("p",[t._v("形成层叠上下文的属性条件如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:e(411),alt:""}})]),t._v(" "),r("p",[t._v("若你想要了解更多层叠上下文的知识，参考 "),r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"}},[t._v("The_stacking_context"),r("OutboundLink")],1)]),t._v(" "),r("h4",{attrs:{id:"graphicslayers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#graphicslayers"}},[t._v("#")]),t._v(" GraphicsLayers")]),t._v(" "),r("p",[t._v("要能成为图层的节点必须要有成为 PaintLayer 的层叠上下文属性条件。 但是并不是所有的 PaintLayer 都能成为 GraphicsLayer，"),r("strong",[t._v("因为生成图层是会占用内存")]),t._v("，只有某些特殊的 PaintLayer 才会被提升为 GraphicsLayer。要形成单独图层的元素需要具有以下条件：")]),t._v(" "),r("ul",[r("li",[t._v("根元素")]),t._v(" "),r("li",[t._v("3D transform 或 perspective 的元素")]),t._v(" "),r("li",[t._v("硬件加速的 video")]),t._v(" "),r("li",[t._v("3D 或硬件加速的 2D 的canvas")]),t._v(" "),r("li",[t._v("对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 active 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）")]),t._v(" "),r("li",[t._v("will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）")]),t._v(" "),r("li",[t._v("裁剪滚动区域")]),t._v(" "),r("li",[r("strong",[t._v("overlaps a composited layer 的元素")])])]),t._v(" "),r("p",[t._v("以上只列举常见情况，更多详情查看")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://fed.taobao.org/blog/taofed/do71ct/performance-composite/?spm=taofed.homepage.header.13.7eab5ac8Ut2aYd",target:"_blank",rel:"noopener noreferrer"}},[t._v("无线性能优化：Composite（推荐）"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://chromium.googlesource.com/chromium/blink/+/72fef91ac1ef679207f51def8133b336a6f6588f/Source/platform/graphics/CompositingReasons.cpp?autodive=0%2F%2F%2F",target:"_blank",rel:"noopener noreferrer"}},[t._v("CompositingReasons.cpp"),r("OutboundLink")],1)])]),t._v(" "),r("blockquote",[r("p",[t._v("目前 Layers 阶段发生 Paint（下文见）阶段前，未来将被转移 Paint 阶段后面 TODO")])]),t._v(" "),r("h3",{attrs:{id:"paint（绘制）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#paint（绘制）"}},[t._v("#")]),t._v(" Paint（绘制）")]),t._v(" "),r("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，但 Paint 阶段并不是真正的界面绘制，而是生成绘制指令列表，交给其他线程进行光栅任务，大大减低了主线程的负担，提高主线程效率。")]),t._v(" "),r("p",[t._v("可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：")]),t._v(" "),r("p",[r("img",{attrs:{src:e(412),alt:""}})]),t._v(" "),r("p",[t._v("每一个图层在 Paint 阶段会分为多个小阶段，并按照层叠顺序对 layout subTree 进行多次遍历")]),t._v(" "),r("p",[t._v("这就可能为什么导致下面案列 float 布局中，一个元素甚至有可能部分地位于另一个元素的前面和一部分之后，我们需要清除浮动")]),t._v(" "),r("p",[r("img",{attrs:{src:e(413),alt:""}})]),t._v(" "),r("p",[t._v("多次遍历产生 DisplayItem 即对应 Paint 多阶段产生的操作")]),t._v(" "),r("p",[r("img",{attrs:{src:e(414),alt:""}})]),t._v(" "),r("p",[r("img",{attrs:{src:e(415),alt:""}})]),t._v(" "),r("h3",{attrs:{id:"raster"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#raster"}},[t._v("#")]),t._v(" Raster")]),t._v(" "),r("p",[t._v("绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染进场中的合成线程来完成的")]),t._v(" "),r("h4",{attrs:{id:"bitmap（位图）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#bitmap（位图）"}},[t._v("#")]),t._v(" bitmap（位图）")]),t._v(" "),r("h4",{attrs:{id:"tile"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tile"}},[t._v("#")]),t._v(" tile")]),t._v(" "),r("p",[t._v("Chromium 目前实际支持三种不同的光栅化和合成的组合方式：软件光栅化 + 软件合成，软件光栅化 + gpu 合成，gpu 光栅化 + gpu 合成。在移动平台上，大部分设备和移动版网页使用的都是 gpu 光栅化 + gpu 合成的渲染方式，理论上性能也最佳。")]),t._v(" "),r("hr"),t._v(" "),r("Vssue",{attrs:{title:t.$title}})],1)}),[],!1,null,null,null);a.default=s.exports}}]);