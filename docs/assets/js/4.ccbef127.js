(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{371:function(t,a){t.exports="http://images.laoergege.cn/40ba46ba8c9173671b95ddb714bf03f6.png"},372:function(t,a){t.exports="http://images.laoergege.cn/481cbb8a7183e892a400cce4d69d2f06.png"},373:function(t,a){t.exports="http://images.laoergege.cn/e8db62e32d9acc7166f25dd5eec91e8b.png"},374:function(t,a){t.exports="http://images.laoergege.cn/963802aa6c42f39fba7adf6fa2e706dc.png"},415:function(t,a,e){"use strict";e.r(a);var r=e(35),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"javascript-模块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-模块"}},[t._v("#")]),t._v(" JavaScript 模块")]),t._v(" "),r("h2",{attrs:{id:"javascript-模块发展历程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-模块发展历程"}},[t._v("#")]),t._v(" JavaScript 模块发展历程")]),t._v(" "),r("h3",{attrs:{id:"文件划分阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文件划分阶段"}},[t._v("#")]),t._v(" 文件划分阶段")]),t._v(" "),r("p",[r("img",{attrs:{src:e(371),alt:"文件阶段"}})]),t._v(" "),r("p",[t._v("该阶段仅仅只是文件上模块化划分，文件模块里的变量成员还是直接工作在全局环境，但")]),t._v(" "),r("ol",[r("li",[t._v("污染全局作用域，容易发生命名冲突 ✘")]),t._v(" "),r("li",[t._v("变量容易被外部访问修改 ✘")]),t._v(" "),r("li",[t._v("难以维护模块依赖关系（我们需要在 HTML 中控制好 script 引入顺序）✘")])]),t._v(" "),r("h3",{attrs:{id:"对象命名空间方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象命名空间方式"}},[t._v("#")]),t._v(" 对象命名空间方式")]),t._v(" "),r("p",[r("img",{attrs:{src:e(372),alt:"文件阶段"}})]),t._v(" "),r("p",[t._v("用一个全局对象包裹所有模块成员，这种方式就好像是为模块内的成员添加“命名空间”，通过命名空间以及规范命名的方式，能够较大可能解决变量命名冲突问题，但是2、 3问题依旧存在")]),t._v(" "),r("h3",{attrs:{id:"iife（立即执行函数）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#iife（立即执行函数）"}},[t._v("#")]),t._v(" IIFE（立即执行函数）")]),t._v(" "),r("p",[r("img",{attrs:{src:e(373),alt:"文件阶段"}})]),t._v(" "),r("p",[t._v("将所有成员放在一个立即执行函数所形成的私有作用域，私有成员只能通过公开成员以闭包的形式访问，而公开成员可以通过挂载全局对象或者返回的方式暴露出去")]),t._v(" "),r("ul",[r("li",[t._v("解决了全局污染、命名冲突和成员访问控制 ✔")])]),t._v(" "),r("h3",{attrs:{id:"iife-依赖参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#iife-依赖参数"}},[t._v("#")]),t._v(" IIFE 依赖参数")]),t._v(" "),r("p",[r("img",{attrs:{src:e(374),alt:"IIFE 依赖参数"}})]),t._v(" "),r("p",[t._v("通过 IIFE 依赖参数声明，可以使得模块依赖关系明显")]),t._v(" "),r("ul",[r("li",[t._v("但模块依赖管理还是没有解决 ✘")])]),t._v(" "),r("p",[t._v("在 ES 语言层面未实现的模块功能前，IIFE 是实现模块化最好的方式。\n而模块依赖管理的本质就是模块加载顺序的问题，早期的模块加载顺序管理只能手动维护HTML script 标签的顺序，而要实现自动化模块加载，需要两点")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("统一的模块化标准规范")])]),t._v(" "),r("li",[t._v("在同一模块标准规范后，才能实现 "),r("strong",[t._v("自动加载模块的基础库")])])]),t._v(" "),r("p",[t._v("参考")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:""}},[t._v("webpack 原理与实践")]),t._v(" "),r("Vssue",{attrs:{title:t.$title}})],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);