(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{436:function(t,s,a){"use strict";a.r(s);var e=a(35),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("ul",[a("li",[a("a",{attrs:{href:"#%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86"}},[t._v("代码拆分")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#optimizationsplitchunks"}},[a("code",[t._v("optimization.splitChunks")])]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"}},[t._v("默认配置")])]),t._v(" "),a("li",[a("a",{attrs:{href:"#cachegroups"}},[t._v("cacheGroups")])])])]),t._v(" "),a("li",[a("a",{attrs:{href:"#%E5%AE%9E%E6%88%98"}},[t._v("实战")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E4%BD%93%E7%A7%AF%E5%88%86%E6%9E%90"}},[t._v("体积分析")])])])])]),t._v(" "),a("h2",{attrs:{id:"代码拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码拆分"}},[t._v("#")]),t._v(" 代码拆分")]),t._v(" "),a("p",[t._v("代码拆分能够把代码拆分到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码拆分可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。")]),t._v(" "),a("p",[t._v("一个 webpack 应用包含三种类型代码：")]),t._v(" "),a("ul",[a("li",[t._v("你或你的团队编写的源码。")]),t._v(" "),a("li",[t._v('你的源码会依赖的任何第三方的 library 或 "vendor" 代码。')]),t._v(" "),a("li",[t._v("webpack 的 runtime 和 manifest，管理所有模块的交互。")])]),t._v(" "),a("p",[t._v("我们可以从对应角度进行代码拆分，故可分为以下三种方式：")]),t._v(" "),a("ul",[a("li",[t._v("Entry Split：使用 entry 配置 webpack 多个为入口，手动地分离代码（如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中，并且不能动态地将核心应用程序逻辑中的代码拆分出来。）。")]),t._v(" "),a("li",[t._v("Bundle Split：使用 SplitChunksPlugin 去重和分离公共代码或者第三方库，因此类代码变动较小，可以做浏览器缓存，加快应用访问速度。")]),t._v(" "),a("li",[t._v("Code Split：使用 "),a("code",[t._v("import()")]),t._v(" 语句进行对我们编写的应用程序逻辑代码进行动态拆分。动态加载的好处主要是减小代码打包体积，让程序在运行时按需加载模块，提高应用初始化速度。")])]),t._v(" "),a("p",[t._v("而 webpack 中对代码进行 Bundle Split，主要是配置 "),a("code",[t._v("optimization.splitChunks")]),t._v(" 选项。")]),t._v(" "),a("h2",{attrs:{id:"optimization-splitchunks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimization-splitchunks"}},[t._v("#")]),t._v(" "),a("code",[t._v("optimization.splitChunks")])]),t._v(" "),a("p",[t._v("webpack v4 开始，"),a("code",[t._v("CommonsChunkPlugin")]),t._v(" 被移除，"),a("code",[t._v("optimization.splitChunks")]),t._v(" 配置选项作为替代，也就是分离模块的功能已作为 webpack 内置功能。")]),t._v(" "),a("blockquote",[a("p",[t._v("注意，以下说的“拆分” 是指 Bundle Split，而不是 Code Split")])]),t._v(" "),a("h3",{attrs:{id:"默认配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认配置"}},[t._v("#")]),t._v(" 默认配置")]),t._v(" "),a("p",[t._v("webpack 4 内置的 SplitChunksPlugin 的默认配置：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("module"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...")]),t._v("\n  optimization"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    splitChunks"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      chunks"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'async'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      minSize"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      maxSize"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      minChunks"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      maxAsyncRequests"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      maxInitialRequests"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      automaticNameDelimiter"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'~'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      cacheGroups"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        vendors"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          test"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token regex"}},[t._v("/[\\\\/]node_modules[\\\\/]/")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          priority"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          minChunks"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          priority"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          reuseExistingChunk"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("参数说明如下：")]),t._v(" "),a("ul",[a("li",[t._v("chunks：表示针对哪些 chunk 做拆分优化\n"),a("ul",[a("li",[t._v("async 仅对按需加载的 chunk 优化")]),t._v(" "),a("li",[t._v("initial 仅对初始的 chunk 优化")]),t._v(" "),a("li",[t._v("all 对所有 chunk 优化，意味着初始块和按需加载块可以共享相同的块")])])]),t._v(" "),a("li",[t._v("minSize：表示抽取出来的文件在压缩前的最小大小，默认为 30000；")]),t._v(" "),a("li",[t._v("maxSize：表示抽取出来的文件在压缩前的最大大小，默认为 0，表示不限制最大大小；")]),t._v(" "),a("li",[t._v("minChunks：表示模块被引用次数，默认为1；")]),t._v(" "),a("li",[t._v("maxAsyncRequests：按需加载时的最大并行请求数，默认为 5；")]),t._v(" "),a("li",[t._v("maxInitialRequests：最大的初始化加载次数，默认为 3；")]),t._v(" "),a("li",[t._v("automaticNameDelimiter：抽取出来 chunk 的名字由被抽取出来的源文件名组成且由默认分割符 ~ 间隔各个源文件名(e.g. 由 a、b chunk抽取的 vender chunk 名为 vendors~a~b.js)；")]),t._v(" "),a("li",[t._v("name：抽取出来文件的名字，默认为 true，表示自动生成文件名(使用 chunk 名和 cache key)；如果名称与入口点名称匹配，则将删除入口点。")]),t._v(" "),a("li",[t._v("cacheGroups: 缓存组。（这才是配置的关键）")])]),t._v(" "),a("p",[t._v("可以通过以下两篇的实验体会 chunks 的意思：")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://medium.com/dailyjs/webpack-4-splitchunks-plugin-d9fbbe091fd0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Webpack 4 — Mysterious SplitChunks Plugin"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://juejin.im/post/5c08fe7d6fb9a04a0d56a702",target:"_blank",rel:"noopener noreferrer"}},[t._v("webapck4 玄妙的 SplitChunks Plugin"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("通过观察两篇文章时，我们需要注意的一个点是")]),t._v(" "),a("blockquote",[a("p",[t._v("当为不同的拆分块分配相同的 "),a("code",[t._v("name")]),t._v(" 时，所有的拆分出来的块都会合并成同一个块，这样可能会导致下载无相关的其他代码")])]),t._v(" "),a("h3",{attrs:{id:"cachegroups"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cachegroups"}},[t._v("#")]),t._v(" cacheGroups")]),t._v(" "),a("p",[t._v("上面的那么多参数，其实都可以不用管，cacheGroups 才是我们配置的关键。 cacheGroups 可以继承和/或覆盖（ splitChunks 中的任何选项，禁止默认的 cacheGroups 设置为 "),a("code",[t._v("default: false")]),t._v("。并且还有多了如下配置属性：")]),t._v(" "),a("ul",[a("li",[t._v("test: 表示要过滤 modules，默认为所有的 modules，可匹配模块路径或 chunk 名字，当匹配的是 chunk 名字的时候，其里面的所有 modules 都会选中；")]),t._v(" "),a("li",[t._v("priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；")]),t._v(" "),a("li",[t._v("reuseExistingChunk：选项 reuseExistingChunk 告诉 SplitChunks 插件在当前cachingGroup 的现有块中进行额外查找，如果可能的话，尽量不为匹配的模块生成额外的块,复用现有的块。（"),a("a",{attrs:{href:"https://github.com/webpack/webpack.js.org/issues/2122",target:"_blank",rel:"noopener noreferrer"}},[t._v("example"),a("OutboundLink")],1),t._v("）。")]),t._v(" "),a("li",[t._v("enforce：忽略除 test、priority、reuseExistingChunk 其他的限制条件")])]),t._v(" "),a("p",[t._v("根据以上配置，webpack 会有如下默认代码拆分行为：")]),t._v(" "),a("ul",[a("li",[t._v("只针对异步加载的 chunk 优化，因为对初始化 chunk 拆分，必须在 HTML 中引入新拆分的 chunk 才会工作")]),t._v(" "),a("li",[t._v("新产生的 chunk 来自 node_modules 或者被多个地方复用 2 次以上。")]),t._v(" "),a("li",[t._v("新 chunk 需要大于 30kb。")]),t._v(" "),a("li",[t._v("对 chunks 的最大同时请求数小于等于 5。换句话说，如果拆分后导致 bundle 需要同时异步加载的 chunk 数量大于 5 个或更多时，则不会进行拆分，因为增加了请求数，得不偿失。")]),t._v(" "),a("li",[t._v("拆分后需要尽量做到对于入口文件中最大同时请求数控制在 3 个以内。")])]),t._v(" "),a("p",[t._v("在满足最后两个条件时，决定了 chunk 应越大越好，而不是越多。")]),t._v(" "),a("h2",{attrs:{id:"实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实战"}},[t._v("#")]),t._v(" 实战")]),t._v(" "),a("p",[t._v("webpack 优化策略主要分为构建速度优化和应用体积优化。webpack 应用体积优化策略有：")]),t._v(" "),a("ul",[a("li",[t._v("Tree shaking")]),t._v(" "),a("li",[t._v("代码拆分")]),t._v(" "),a("li",[t._v("源码压缩")])]),t._v(" "),a("p",[t._v("那么如何对现有应用进行代码拆分，以达到体积优化？")]),t._v(" "),a("h3",{attrs:{id:"体积分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#体积分析"}},[t._v("#")]),t._v(" 体积分析")]),t._v(" "),a("p",[t._v("应用体积分析如下方法有：")]),t._v(" "),a("ul",[a("li",[t._v("应用程序的架构及其加载的脚本")]),t._v(" "),a("li",[t._v("linghthouse 对 JavaScript 执行时间进行审计")]),t._v(" "),a("li",[t._v("chromw devtool 的 source 面板输入 "),a("code",[t._v("show coverage")])]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.webpagetest.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("webpagetest"),a("OutboundLink")],1)])]),t._v(" "),a("hr"),t._v(" "),a("Vssue",{attrs:{title:t.$title}})],1)}),[],!1,null,null,null);s.default=n.exports}}]);