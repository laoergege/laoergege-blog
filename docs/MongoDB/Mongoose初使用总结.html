<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Laoergege Blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="Just For Fun">
    <link rel="preload" href="/assets/css/0.styles.f164480b.css" as="style"><link rel="preload" href="/assets/js/app.b14a24a9.js" as="script"><link rel="preload" href="/assets/js/2.c21b76fe.js" as="script"><link rel="preload" href="/assets/js/25.3938d09f.js" as="script"><link rel="prefetch" href="/assets/js/10.c295213a.js"><link rel="prefetch" href="/assets/js/11.78e7cf66.js"><link rel="prefetch" href="/assets/js/12.e64ce61b.js"><link rel="prefetch" href="/assets/js/13.f63511d9.js"><link rel="prefetch" href="/assets/js/14.38cfcd90.js"><link rel="prefetch" href="/assets/js/15.b692f2da.js"><link rel="prefetch" href="/assets/js/16.7b8db6fc.js"><link rel="prefetch" href="/assets/js/17.93c37643.js"><link rel="prefetch" href="/assets/js/18.aae888c7.js"><link rel="prefetch" href="/assets/js/19.731046b0.js"><link rel="prefetch" href="/assets/js/20.0e02e56f.js"><link rel="prefetch" href="/assets/js/21.93faa14c.js"><link rel="prefetch" href="/assets/js/22.faf4ab05.js"><link rel="prefetch" href="/assets/js/23.ab561704.js"><link rel="prefetch" href="/assets/js/24.6946910f.js"><link rel="prefetch" href="/assets/js/26.f333c306.js"><link rel="prefetch" href="/assets/js/27.de3ee048.js"><link rel="prefetch" href="/assets/js/28.59b34fc2.js"><link rel="prefetch" href="/assets/js/29.5800baaa.js"><link rel="prefetch" href="/assets/js/3.b773b97b.js"><link rel="prefetch" href="/assets/js/30.59389f3f.js"><link rel="prefetch" href="/assets/js/31.1e0ce497.js"><link rel="prefetch" href="/assets/js/32.150b4df2.js"><link rel="prefetch" href="/assets/js/33.78bc762b.js"><link rel="prefetch" href="/assets/js/34.16d3dcaf.js"><link rel="prefetch" href="/assets/js/35.e81bf215.js"><link rel="prefetch" href="/assets/js/36.3c88c325.js"><link rel="prefetch" href="/assets/js/37.006a9089.js"><link rel="prefetch" href="/assets/js/38.82179d08.js"><link rel="prefetch" href="/assets/js/39.4fe15aa5.js"><link rel="prefetch" href="/assets/js/4.62c6cda8.js"><link rel="prefetch" href="/assets/js/40.bd6781f3.js"><link rel="prefetch" href="/assets/js/41.f035eee9.js"><link rel="prefetch" href="/assets/js/42.6f0a9cea.js"><link rel="prefetch" href="/assets/js/43.8fda49dc.js"><link rel="prefetch" href="/assets/js/44.67203918.js"><link rel="prefetch" href="/assets/js/45.4a3e150d.js"><link rel="prefetch" href="/assets/js/5.a252ca81.js"><link rel="prefetch" href="/assets/js/6.e32b3e7a.js"><link rel="prefetch" href="/assets/js/7.a340b773.js"><link rel="prefetch" href="/assets/js/8.781e475b.js"><link rel="prefetch" href="/assets/js/9.def35855.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f164480b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Laoergege Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li></ul></div></div><div class="nav-item"><a href="/前端工程/" class="nav-link">
  前端工程
</a></div><div class="nav-item"><a href="/浏览器原理及API/" class="nav-link">
  浏览器原理及API
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/Git/" class="nav-link">
  Git
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端框架" class="dropdown-title"><span class="title">前端框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/React/" class="nav-link">
  React
</a></li></ul></div></div><div class="nav-item"><a href="/前端工程/" class="nav-link">
  前端工程
</a></div><div class="nav-item"><a href="/浏览器原理及API/" class="nav-link">
  浏览器原理及API
</a></div><div class="nav-item"><a href="/NodeJS/" class="nav-link">
  NodeJS
</a></div><div class="nav-item"><a href="/Git/" class="nav-link">
  Git
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>参考<a href="https://www.villainhr.com/page/2016/05/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmongoose#Model" target="_blank" rel="noopener noreferrer">深入浅出mongoose<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="连接mongoose"><a href="#连接mongoose" class="header-anchor">#</a> 连接mongoose</h2> <p>mongoose连接数据库有两种方式
第一种：</p> <div class="language- extra-class"><pre class="language-text"><code>'use strict';

const mongoose = require('mongoose');

mongoose.connect('mongodb://localhost:27017/test');
const con = mongoose.connection;
con.on('error', console.error.bind(console, '连接数据库失败'));
con.once('open',()=&gt;{
    //成功连接
})
</code></pre></div><p>第二种：</p> <div class="language- extra-class"><pre class="language-text"><code>var mongoose = require('mongoose');

db = mongoose.createConnection('localhost', 'test');
var schema = new mongoose.Schema({ name: String });
var collectionName = 'kittens';
var M = db.model('Kitten', schema, collectionName);
var silence = new M({ name: &quot;Silence&quot;});
silence.save(function(err){
 
});
</code></pre></div><h3 id="mongoose-createconnection-和mongoose-connect-区别"><a href="#mongoose-createconnection-和mongoose-connect-区别" class="header-anchor">#</a> mongoose.createConnection()和mongoose.connect()区别</h3> <p>首先，我们需要定义一个连接，如果你的app只用到一个数据库，你应该使用 mongoose.connect。如果你还需要连接其他数据库，使用mongoose.createConnection。
所有的 connect and createConnection 使用 mongodb:// URI, or the parameters host, database, port, options.等参数</p> <div class="language- extra-class"><pre class="language-text"><code>var mongoose = require('mongoose');

mongoose.connect('mongodb://localhost/my_database');
</code></pre></div><p>一旦连接，Connection对象会触发open事件，如果你使用 mongoose.connect, Connection对象就是默认的 mongoose.connection，而使用 mongoose.createConnection 返回值就是 Connection.</p> <blockquote><p>Mongoose会缓存所有命令直到连接上数据库，这意味着你不必等待它连接MongoDB再定义 models，执行 queries 等。</p></blockquote> <h2 id="mongoose基本概念"><a href="#mongoose基本概念" class="header-anchor">#</a> Mongoose基本概念</h2> <ul><li>Schema: 表定义模板</li> <li>Model: 类似关系数据库表，封装成具有一些集合操作的对象</li> <li>instance: 类似记录，由Model创建的实体，也具有影响数据库的操作</li></ul> <h2 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h2> <div class="language- extra-class"><pre class="language-text"><code>//定义一个schema
    let Schema = mongoose.Schema({
        category:String,
        name:String
    });
    Schema.methods.eat = function(){
        console.log(&quot;I've eatten one &quot;+this.name);
    }
    //继承一个schema
    let Model = mongoose.model(&quot;fruit&quot;,Schema);
    //生成一个document
    let apple = new Model({
        category:'apple',
        name:'apple'
    });
    //存放数据
    apple.save((err,apple)=&gt;{
        if(err) return console.log(err);
        apple.eat();
        //查找数据
        Model.find({name:'apple'},(err,data)=&gt;{
            console.log(data);
        })
    });
</code></pre></div><h2 id="schema"><a href="#schema" class="header-anchor">#</a> Schema</h2> <div class="language- extra-class"><pre class="language-text"><code>// from mongoose author
var mongoose = require('mongoose');
var Schema = mongoose.Schema;//引用出来，不需要每次调用 mongoose.Schema()这个丑陋的API.

var blogSchema = new Schema({
  title:  String,
  author: String,
  //直接写法，会被转化成相应的SchemaType 
  body:   String,  
  comments: [{ body: String, date: Date }],
  //定义SchemaType写法
  date: { type: Date, default: Date.now },
  hidden: Boolean,
  meta: {
    votes: Number,
    favs:  Number
  }
});
</code></pre></div><p>Schema 之所以能够定义documents, 是因为他可以限制你输入的字段及其类型. mongoose支持的基本类型有:</p> <ul><li>String</li> <li>Number</li> <li>Date</li> <li>Buffer</li> <li>Boolean</li> <li>Mixed</li> <li>ObjectId</li> <li>Array</li></ul> <h3 id="schematype"><a href="#schematype" class="header-anchor">#</a> SchemaType</h3> <p>type属性指定SchemaType类型，不同的SchemaType类型还有其他不同的属性配置</p> <div class="language- extra-class"><pre class="language-text"><code>var schema2 = new Schema({
  test: {
    type: String,
    lowercase: true // Always convert `test` to lowercase
  }
});
</code></pre></div><p>这是所有类型公有的：</p> <ul><li>required: 必选验证器。</li> <li>default: 默认值。Any或function，如果该值是一个函数，则该函数的返回值将用作默认值。</li> <li>select: boolean值, 指定是否被投影</li> <li>`validate: 验证器</li> <li>get: get方法，using Object.defineProperty().</li> <li>set: set方法 using Object.defineProperty().</li> <li>alias: 别名。</li></ul> <p><a href="http://mongoosejs.com/docs/schematypes.html" target="_blank" rel="noopener noreferrer">其他类型特有属性官方API查找。<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="设置索引"><a href="#设置索引" class="header-anchor">#</a> 设置索引</h3> <p>这里设置索引分两种,一种设在Schema filed, 另外一种设在 Schema.index 里.</p> <div class="language- extra-class"><pre class="language-text"><code>//在field 设置
var animalSchema = new Schema({
  name: String,
  type: String,
  tags: { type: [String], index: true } 
});
</code></pre></div><p>//在Schema.index中设置.</p> <div class="language- extra-class"><pre class="language-text"><code>animalSchema.index({ name: 1, type: -1 });



//1 表示正序, -1 表示逆序
</code></pre></div><p>实际上,两者效果是一样的. 看每个人的喜好了. 不过推荐直接在Schema level中设置, 这样分开能够增加可读性. 不过,
可以说，当应用启动的时候, ，Mongoose会自动为Schema中每个定义了索引的调用ensureIndex，确保生成索引.
并在所有的secureIndex调用成功或出现错误时，在 Model 上发出一个'index'事件。 开发环境用这个很好, 但是建议在生产环境不要使用这个.使用下面的方法禁用ensureIndex。
通过将 Schema 的autoIndex选项设置为false或通过将选项config.autoIndex设置为false将连接全局设置为禁用此行为 有可能严重拖慢查询或者创建速度,所以一般而言,我们需要将该option 关闭.</p> <div class="language- extra-class"><pre class="language-text"><code>mongoose.connect('mongodb://user:pass@localhost:port/database', { config: { autoIndex: false } });  //真心推荐
// or  
mongoose.createConnection('mongodb://user:pass@localhost:port/database', { config: { autoIndex: false } });  //不推荐
// or
animalSchema.set('autoIndex', false);  //推荐
// or
new Schema({..}, { autoIndex: false }); //懒癌不推荐
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// Will cause an error because mongodb has an _id index by default that
// is not sparse
animalSchema.index({ _id: 1 }, { sparse: true });
var Animal = mongoose.model('Animal', animalSchema);

Animal.on('index', function(error) {
  // &quot;_id index cannot be sparse&quot;
  console.log(error.message);
});
</code></pre></div><h3 id="定义schema-methods"><a href="#定义schema-methods" class="header-anchor">#</a> 定义Schema.methods</h3> <div class="language- extra-class"><pre class="language-text"><code>// 定义一个schema
var freshSchema = new Schema({ name: String, type: String });

// 添加一个fn. 
animalSchema.methods.findSimilarTypes = function (cb) {
  //这里的this指的是具体document上的this
  //this.model 返回Model对象
  return this.model ('Animal').find({ type: this.type }, cb);
}
// 实际上,我们可以通过schema绑定上,数据库操作的所有方法.
// 该method实际上是绑定在 实例的 doc上的

</code></pre></div><p>实例Model</p> <p>这里同样很简单,只需要 mongoose.model() 即可.</p> <div class="language- extra-class"><pre class="language-text"><code>//生成,model 类. 实际上就相当于我们的一个collection
var Animal = mongoose.model('Animal', animalSchema);
var dog = new Animal({ type: 'dog' });
</code></pre></div><p>但是, 这里有个问题. 我们在Schema.methods.fn 上定义的方法,只能在 new Model() 得到的实例中才能访问. 那如果我们想,直接在Model上调用 相关的查询或者删除呢？</p> <p>绑定Model方法</p> <p>同样很简单,使用 Statics 即可.</p> <div class="language- extra-class"><pre class="language-text"><code>// 给model添加一个findByName方法
animalSchema.statics.findByName = function (name, cb) {
  //这里的this 指的就是Model
  return this.find({ name: new RegExp(name, 'i') }, cb);
}

var Animal = mongoose.model('Animal', animalSchema);
Animal.findByName('fido', function (err, animals) {
  console.log(animals);
});
</code></pre></div><h3 id="虚拟属性"><a href="#虚拟属性" class="header-anchor">#</a> 虚拟属性</h3> <p>Mongoose 还有一个super featrue-- virtual property 该属性是直接设置在Schema上的. 但是,需要注意的是,VR 并不会真正的存放在db中. 他只是一个提取数据的方法.</p> <div class="language- extra-class"><pre class="language-text"><code>//schema基本内容
var personSchema = new Schema({
  name: {
    first: String,
    last: String
  }
});

// 生成Model
var Person = mongoose.model('Person', personSchema);

//现在我们有个需求,即,需要将first和last结合输出.
//一种方法是,使用methods来实现
//schema 添加方法
personSchema.methods.getName = function(){
    return this.first+&quot; &quot;+this.last;
}

// 生成一个doc
var bad = new Person({
    name: { first: 'jimmy', last: 'Gay' }
});

//调用
bad.getName();
</code></pre></div><p>但是,像这样,仅仅这是为了获取一个属性, 实际上完全可以使用虚拟属性来实现.</p> <div class="language- extra-class"><pre class="language-text"><code>//schema 添加虚拟属性
personSchema.virtual('fullName').get(function(){
    return this.first+&quot; &quot;+this.last;
})
//调用
bad.fullName;  //和上面的方法的结果是完全一致的
</code></pre></div><p>而且,经过测试, 使用fn实现的返回,比VR 要慢几十倍. 一下是测试结果:</p> <div class="language- extra-class"><pre class="language-text"><code>console.time(1);
    bad.getName();
    console.timeEnd(1);
    console.time(2);
    bad.fullName;
    console.timeEnd(2);
    
    //结果为:
    1: 4.323ms;  //method
    2: 0.253ms  // VR
</code></pre></div><p>最后再补充一下,Schema中初始化的相关参数.
Schema参数 在 new Schema([options]) 中,我们需要设置一些相关的参数.</p> <ul><li>safe: 用来设置安全模式. 实际上,就是定义入库时数据的写入限制. 比如写入时限等.</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//使用安全模式. 表示在写入操作时,如果发生错误,也需要返回信息.
 var safe = true;
new Schema({ .. }, { safe: safe });

// 自定义安全模式. w为写入的大小范围. wtimeout设置写入时限. 如果超出10s则返回error
var safe = { w: &quot;majority&quot;, wtimeout: 10000 };
new Schema({ .. }, { safe: safe });
</code></pre></div><ul><li>toObject: 用来表示在提取数据的时候, 把documents 内容转化为Object内容输出. 一般而言只需要设置getters为true即可.</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var schema = new Schema({ name: String });
schema.path('name').get(function (v) {
  return v + ' is my name';
});
schema.set('toObject', { getters: true });
var M = mongoose.model('Person', schema);
var m = new M({ name: 'Max Headroom' });
console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }
</code></pre></div><ul><li>toJSON： 该是和toObject一样的使用. 通常用来把 documents 转化为Object. 但是, 需要显示使用toJSON()方法,</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var schema = new Schema({ name: String });
schema.path('name').get(function (v) {
  return v + ' is my name';
});
schema.set('toJSON', { getters: true, virtuals: false });
var M = mongoose.model('Person', schema);
var m = new M({ name: 'Max Headroom' });
console.log(m.toObject()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' }
console.log(m.toJSON()); // { _id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' }
// since we know toJSON is called whenever a js object is stringified:
console.log(JSON.stringify(m)); // { &quot;_id&quot;: &quot;504e0cd7dd992d9be2f20b6f&quot;, &quot;name&quot;: &quot;Max Headroom is my name&quot; }
</code></pre></div><h2 id="model"><a href="#model" class="header-anchor">#</a> Model</h2> <h3 id="model的创建"><a href="#model的创建" class="header-anchor">#</a> model的创建</h3> <p>model的创建实际上就是方法的copy. 将schema上的方法,copy到model上. 只是copy的位置不一样, 一部分在prototype上, 一部分在constructor中.</p> <div class="language- extra-class"><pre class="language-text"><code>//from mongoosejs
var schema = new mongoose.Schema({ name: 'string', size: 'string' });
var Tank = mongoose.model('Tank', schema);
</code></pre></div><p>这里,我们一定要搞清楚一个东西. 实际上, mongoose.model里面定义的第一个参数,比如’Tank’, 并不是数据库中的, collection. 他只是collection的单数形式, 实际上在db中的collection是’Tanks’.</p> <blockquote><p>想两边名称保持一致，可参考http://aiilive.blog.51cto.com/1925756/1405203</p></blockquote> <h3 id="model-的子文档操作"><a href="#model-的子文档操作" class="header-anchor">#</a> model 的子文档操作</h3> <p>本来mongodb是没有关系的. 但是, mongoose提供了children字段. 让我们能够轻松的在表间建立关系. 现在,我们来创建一个子域:</p> <div class="language- extra-class"><pre class="language-text"><code>var childSchema = new Schema({ name: 'string' });

var parentSchema = new Schema({
  children: [childSchema]   //指明sub-doc的schema
});
//在创建中指明doc
var Parent = mongoose.model('Parent', parentSchema);
var parent = new Parent({ children: [{ name: 'Matt' }, { name: 'Sarah' }] })
parent.children[0].name = 'Matthew';
parent.save(callback);
</code></pre></div><p>现在, 我们就已经创建了3个table. 一个parent 包含了 两个child 另外,如果我们想要查询指定的doc。 则可以使用 id()方法.</p> <div class="language- extra-class"><pre class="language-text"><code>var doc = parent.children.id(id);
</code></pre></div><p>子文档的CRUD, 实际上就是数组的操作, 比如push,unshift,remove,pop,shift等</p> <div class="language- extra-class"><pre class="language-text"><code>parent.children.push({ name: 'Liesl' });
</code></pre></div><p>mongoose还给移除提供了另外一个方法–remove:</p> <div class="language- extra-class"><pre class="language-text"><code>var doc = parent.children.id(id).remove();
</code></pre></div><p>如果你忘记添加子文档的话，可以在外围添加, 但是字段必须在Schema中指定</p> <p>var newdoc = parent.children.create({ name: 'Aaron' });</p> <h3 id="document的crud操作"><a href="#document的crud操作" class="header-anchor">#</a> document的CRUD操作</h3> <p>document 的创建 关于document的创建,有两种方法, 一种是使用document实例创建,另外一种是使用Model类创建.</p> <h4 id="document的创建"><a href="#document的创建" class="header-anchor">#</a> document的创建</h4> <div class="language- extra-class"><pre class="language-text"><code>var Tank = mongoose.model('Tank', yourSchema);

var small = new Tank({ size: 'small' });
//使用实例创建
small.save(function (err) {
  if (err) return handleError(err);
  // saved!
})

//使用Model类创建
Tank.create({ size: 'small' }, function (err, small) {
  if (err) return handleError(err);
  // saved!
})
</code></pre></div><h3 id="document的查询"><a href="#document的查询" class="header-anchor">#</a> document的查询</h3> <p>Mongoose查找文档很容易，它支持MongoDB的丰富的查询语法。 可以使用每个models <strong>find</strong>，<strong>findById</strong>，<strong>findOne</strong>或<strong>where</strong> 等静态方法进行查找文档。
事实上,在mongoose中,query数据 提供了两种方式.</p> <ul><li>callback: 使用回调函数, 即, query会立即执行,然后返回到回调函数中.</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Person.findOne({ 'name.last': 'Ghost' }, 'name occupation', function (err, person) {
  if (err) return handleError(err);
 // get data
})
</code></pre></div><ul><li>query: 使用查询方法,返回的是一个Query对象. 该对象是一个Promise, 所以可以使用 chain 进行调用.最后必须使用exec(cb)传入回调进行处理. cb 是一个套路, 第一个参数永远是err. 第二个就是返回的数据。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);
</code></pre></div><p>以下两种等价写法：</p> <div class="language- extra-class"><pre class="language-text"><code>// With a JSON doc
Person.
  find({
    occupation: /host/,
    'name.last': 'Ghost',
    age: { $gt: 17, $lt: 66 },
    likes: { $in: ['vaporizing', 'talking'] }
  }).
  limit(10).
  sort({ occupation: -1 }).
  select({ name: 1, occupation: 1 }).
  exec(callback);
  
// Using query builder
Person.
  find({ occupation: /host/ }).
  where('name.last').equals('Ghost').
  where('age').gt(17).lt(66).
  where('likes').in(['vaporizing', 'talking']).
  limit(10).
  sort('-occupation').
  select('name occupation').
  exec(callback);
</code></pre></div><h4 id="query-helpers"><a href="#query-helpers" class="header-anchor">#</a> Query Helpers</h4> <p>你能够添加 query helper functions,跟定义在Schema实例方法一样，但是返回query对象作为mongoose queries使用（说句白了就是封装mongoose查询方法）. Query helper methods 使你能够扩展mongoose's chainable query builder API.</p> <div class="language- extra-class"><pre class="language-text"><code>animalSchema.query.byName = function(name) {
  return this.find({ name: new RegExp(name, 'i') });
};

var Animal = mongoose.model('Animal', animalSchema);
Animal.find().byName('fido').exec(function(err, animals) {
  console.log(animals);
});
</code></pre></div><p>上面4个API, 3个使用方式都是一样的, 另外一个不同的是where. 他一样是用来进行query. 只是,写法和find系列略有不同.</p> <p><strong>where简介</strong> where的API为: Model.where(path, [val]) path实际上就是字段, 第二个参数.val表示可以用来指定,path = val的数据内容, 你也可以不写, 交给后面进行筛选. 看一下对比demo吧:</p> <div class="language- extra-class"><pre class="language-text"><code>User.find({age: {$gte: 21, $lte: 65}}, callback);
//等价于:
User.where('age').gte(21).lte(65).exec(callback);
</code></pre></div><p>从上面的query中,我们可以看到有许多fn, 比如gte,lte,$gte,$lte. 这些是db提供给我们用来查询的快捷函数. 我们可以参考, mongoose给的参考: <a href="http://mongoosejs.com/docs/api.html#query-js" target="_blank" rel="noopener noreferrer">query Helper fn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>另外还有一些游标集合的处理方法: 常用的就3个, limit,skip,sort.</p> <p>**limit:**用来获取限定长度的内容.</p> <div class="language- extra-class"><pre class="language-text"><code>query.limit(20); //只返回前20个内容
</code></pre></div><p>skip: 返回，跳过指定doc后的值.</p> <div class="language- extra-class"><pre class="language-text"><code>query.skip(2);
</code></pre></div><p>sort: 用来设置根据指定字段排序. 可以设置为1:升序, -1:降序.</p> <div class="language- extra-class"><pre class="language-text"><code>query.sort({name:1,age:-1});
</code></pre></div><p>实际上, 关于query,我们需要了解的也就差不多了.</p> <h3 id="document删除"><a href="#document删除" class="header-anchor">#</a> document删除</h3> <p>reomve操作仅在通过回调时执行。 要强制执行没有回调，您必须先调用remove（），然后使用exec（）方法执行它。
我们可以在document上执行remove方法也可以在Model上。</p> <div class="language- extra-class"><pre class="language-text"><code>Model.find().remove({ name: 'Anne Murray' }, callback)
Model.remove({ name: 'Anne Murray' }, callback)
//没有添加回调情况
Model.find().remove({ name: 'Anne Murray' }).remove(callback)
Model.remove({ name: 'Anne Murray' }).exce(callback)
</code></pre></div><h3 id="document更新"><a href="#document更新" class="header-anchor">#</a> document更新</h3> <p>使用Model.update([(conditions, doc, [options], [callback])]
不返回更新对象到应用程序。如果要更新数据库中的单个文档并将其返回到应用程序，请改用findOneAndUpdate。</p> <p>参数说明：</p> <ul><li>conditions: 就是query. 通过query获取到指定doc</li> <li>doc: 就是用来替换doc内容的值.</li> <li>options: 这块需要说一些下.
safe (boolean) 是否开启安全模式 (default for true)
<strong>upsert</strong> (boolean) 如果没有匹配到内容,是否自动创建 ( default for false)
<strong>multi</strong> (boolean) 如果有多个doc,匹配到,是否一起更改 ( default for false)
strict (boolean) 使用严格模式(default for false)
overwrite (boolean) 匹配到指定doc,是否覆盖 (default for false)
runValidators (boolean): 表示是否用来启用验证. 实际上,你首先需要写一个验证. 关于如果书写,验证大家可以参考下文, validate篇(default for false)</li></ul> <p><strong>new</strong>（使用findOneAndUpdate时才有参数）：bool - 如果为true，则返回修改后的文档而不是原始文件。 默认为false。</p> <div class="language- extra-class"><pre class="language-text"><code>Model.update({age:18}, { $set: { name: 'jason borne' }}, {multi:true}, function (err, raw) {
  if (err) return handleError(err);
  console.log('raw 就是mongodb返回的更改状态的falg ', raw);
  //比如: { ok: 1, nModified: 2, n: 2 }
});
</code></pre></div><p>其中的$set是,用来指明更新的字段。</p> <h2 id="validation"><a href="#validation" class="header-anchor">#</a> Validation</h2> <p>验证器在SchemaType中定义。
Validation 是一种中间件，Mongoose 触发 validation 同 a pre('save')钩子一样 。
你能够手动触发 validation 通过doc.validate(callback) or doc.validateSync()。</p> <div class="language- extra-class"><pre class="language-text"><code>cat.save(function(error) {
//自动执行,validation
});

//手动触发 validatio
//上面已经设置好user的字段内容.
  user.validate(function(error) {
    //error 就是验证不通过返回的错误信息
     assert.equal(error.errors['phone'].message,
        '555.0123 is not a valid phone number!');
    });
});
</code></pre></div><h3 id="内置验证器"><a href="#内置验证器" class="header-anchor">#</a> 内置验证器</h3> <p>Mongoose 有一些列内置验证器.</p> <ul><li>所有的SchemaTypes都有required验证器</li> <li>min,max: 用来给Number类型的数据设置限制.</li></ul> <div class="language- extra-class"><pre class="language-text"><code> var breakfastSchema = new Schema({
      eggs: {
        type: Number,
        min: [6, 'Too few eggs'],
        max: 12
      }
});
</code></pre></div><ul><li>enum,match,maxlength,minlength: 这些验证是给string类型的. enum 就是枚举,表示该属性值,只能出席那那些. match是用来匹配正则表达式的. maxlength&amp;minlength 显示字符串的长度.</li></ul> <div class="language- extra-class"><pre class="language-text"><code>new Schema({
    drink: {
        type: String,
        enum: ['Coffee', 'Tea']
      },
     food:{
        type: String,
        match:/^a/,
        maxlength:12,
        minlength:6
    }
})
</code></pre></div><h3 id="自定义验证器"><a href="#自定义验证器" class="header-anchor">#</a> 自定义验证器</h3> <p>如果内置验证器不够，您可以定义自定义验证器以满足您的需要。</p> <div class="language- extra-class"><pre class="language-text"><code>// 创建验证器
function validator (val) {
  return val == 'something';
}
new Schema({ name: { type: String, validate: validator }});

// 附带自定义错误信息

var custom = [validator, 'Uh oh, {PATH} does not equal &quot;something&quot;.']
new Schema({ name: { type: String, validate: custom }});

//添加多验证器

var many = [
    { validator: validator, msg: 'uh oh' }
  , { validator: anotherValidator, msg: 'failed' }
]
new Schema({ name: { type: String, validate: many }});

// 直接通过SchemaType.validate方法定义验证器:

var schema = new Schema({ name: 'string' });
schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');
</code></pre></div><h3 id="验证错误对象"><a href="#验证错误对象" class="header-anchor">#</a> 验证错误对象</h3> <p>验证失败后返回的错误包含一个包含实际ValidatorError对象的错误对象。 每个ValidatorError都有kind，path，value和message属性。</p> <div class="language- extra-class"><pre class="language-text"><code>  var toySchema = new Schema({
      color: String,
      name: String
    });

    var Toy = db.model('Toy', toySchema);

    var validator = function (value) {
      return /blue|green|white|red|orange|periwinkle/i.test(value);
    };
    Toy.schema.path('color').validate(validator,
      'Color `{VALUE}` not valid', 'Invalid color');

    var toy = new Toy({ color: 'grease'});

    toy.save(function (err) {
      // err is our ValidationError object
      // err.errors.color is a ValidatorError object
      assert.equal(err.errors.color.message, 'Color `grease` not valid');
      assert.equal(err.errors.color.kind, 'Invalid color');
      assert.equal(err.errors.color.path, 'color');
      assert.equal(err.errors.color.value, 'grease');
      assert.equal(err.name, 'ValidationError');
    });
</code></pre></div><h3 id="更新验证器"><a href="#更新验证器" class="header-anchor">#</a> 更新验证器</h3> <p>在Model.update那一节有个参数–runValidators. 还没有详细说. 这里, 展开一下. 实际上, validate一般只会应用在save上, 如果你想在update使用的话, 需要额外的trick，而runValidators就是这个trick.
Mongoose还支持update（）和findOneAndUpdate（）操作的验证。 在Mongoose 4.x中，更新验证器默认关闭 - 您需要指定runValidators选项。</p> <div class="language- extra-class"><pre class="language-text"><code>var opts = { runValidators: true };
    Test.update({}, update, opts, function(error) {  //额外开启runValidators的验证
      // There will never be a validation error here
    });
</code></pre></div><p>更多验证器用法请参考<a href="http://mongoosejs.com/docs/validation.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="population"><a href="#population" class="header-anchor">#</a> population</h2> <p>ongodb 本来就是一门非关系型数据库。 但有时候,我们又需要联合其他的table进行数据查找。 mongoose提供的 population. 用来连接多表数据查询. 一般而言, 我们只要提供某一个collection的_id , 就可以实现完美的联合查询. population 用到的关键字是: ref 用来指明外联的数据库的名字. 一般,我们需要在schema中就定义好.</p> <div class="language- extra-class"><pre class="language-text"><code>var mongoose = require('mongoose')
  , Schema = mongoose.Schema
  
var personSchema = Schema({
  _id     : Number,
  name    : String,
  age     : Number,
  stories : [{ type: Schema.Types.ObjectId, ref: 'Story' }]
});

var storySchema = Schema({
  _creator : { type: Number, ref: 'Person' },
  title    : String,
  fans     : [{ type: Number, ref: 'Person' }]
});

var Story  = mongoose.model('Story', storySchema);
var Person = mongoose.model('Person', personSchema);

</code></pre></div><blockquote><p>Note: ObjectId, Number, String, and Buffer are valid for use as refs.</p></blockquote> <p>使用populate query方法进行关联</p> <div class="language- extra-class"><pre class="language-text"><code>Story
.findOne({ title: 'Once upon a timex.' })
.populate('_creator')
.exec(function (err, story) {
  if (err) return handleError(err);
  console.log('The creator is %s', story._creator.name);
  // prints &quot;The creator is Aaron&quot;
});
</code></pre></div><h2 id="中间件"><a href="#中间件" class="header-anchor">#</a> 中间件</h2> <p>mongoose里的中间件,有两个, 一个是pre, 一个是post.</p> <ul><li>pre: 在指定方法执行之前绑定。 中间件的状态分为 parallel和series.</li> <li>post: 相当于事件监听的绑定</li></ul> <p>这里需要说明一下, 中间件一般仅仅只能限于在几个方法中使用. (但感觉就已经是全部了)</p> <ul><li>doc 方法上: init,validate,save,remove;</li> <li>model方法上: count,find,findOne,findOneAndRemove,findOneAndUpdate,update</li></ul> <h3 id="pre"><a href="#pre" class="header-anchor">#</a> pre</h3> <p>我们来看一下,pre中间件是如何绑定的.</p> <h4 id="串行"><a href="#串行" class="header-anchor">#</a> 串行</h4> <div class="language- extra-class"><pre class="language-text"><code>var schema = new Schema(..);
schema.pre('save', function(next) {
  // do stuff
  next(); //执行完毕，执行下一中间件
});
</code></pre></div><h4 id="并行"><a href="#并行" class="header-anchor">#</a> 并行</h4> <div class="language- extra-class"><pre class="language-text"><code>var schema = new Schema(..);

// 设置第二参数为true，意味这是一个并行中间件
// as the second parameter if you want to use parallel middleware.
schema.pre('save', true, function(next, done) {
  // calling next kicks off the next middleware in parallel
  next();
  setTimeout(done, 100);
});
</code></pre></div><h3 id="post"><a href="#post" class="header-anchor">#</a> post</h3> <p>post会在指定事件后触发,就像事件监听器一样，post钩子没什么控制流程，即它是异步的。</p> <div class="language- extra-class"><pre class="language-text"><code>schema.post('save', function(doc) {
 //在save完成后 触发.
  console.log('%s has been saved', doc._id);
});
</code></pre></div><p>当save方法调用时, 便会触发post绑定的save事件.
假如你绑定了多个post。 也可以需要指定一下中间件顺序.</p> <div class="language- extra-class"><pre class="language-text"><code>// Takes 2 parameters: this is an asynchronous post hook
schema.post('save', function(doc, next) {
  setTimeout(function() {
    console.log('post1');
    // Kick off the second post hook
    next();
  }, 10);
});

// Will not execute until the first middleware calls `next()`
schema.post('save', function(doc, next) {
  console.log('post2');
  next();
})
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b14a24a9.js" defer></script><script src="/assets/js/2.c21b76fe.js" defer></script><script src="/assets/js/25.3938d09f.js" defer></script>
  </body>
</html>
