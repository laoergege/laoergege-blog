# 身份验证和权限校验

- 身份验证：Session vs Token 
- SSO：单点登录，一次登录全线通用
  - 核心：单独**认证服务**（通常被称为 SSO）
  - 顶级域相同
    - cookie 顶级域共享 + 共享 session/token
  - 顶级域不同
- OAuth2：授权协议
- 权限设计
  - ACL 即访问控制列表，它的核心在于用户直接和权限挂钩
  - RBAC 核心是用户只和角色关联，而角色对应了权限



## 身份验证：Session vs Token 

进行身份验证需要用户提交身份资料信息，验证通过后就需要发放**访问凭证**来保证应用程序的后续交互。凭证验证机制主要分两种：

- 基于会话（Session）：在服务端保存相关会话信息，对用户发放会话 ID， 最后通过会话 ID 在服务端查找会话是否存在
- 基于令牌（Token）：对用户发放特殊设计的签名令牌（通常为 [JWT](#jwt)），服务端只需对用户请求中的令牌进行校验是否有效即可

Session vs Token 的区别对比：

- 场景：简单场景优先 Token 
  - Token（JWT）：适合无状态的 API 服务**授权**调用，以及可靠地交换信息
    - 如果需要管理用户状态则不合适，如单点登陆、登录注销、登录踢出、长时间登录状态、黑白名单，分配多级权限路由等
  - Session：适合复杂的会话状态管理场景
    - Session 的分布式问题
      - 独立的 Redis 缓存服务器：共享 session
- 无状态的，去中心化，可扩展性好
  - JWT 令牌的大小要大得多，这是因为它们包含更多信息
  - 最佳实践：
    - 尽量不要将涉及到安全数据，或者先进行数据加密
    - 尽可能的使用 HTTPS 协议传输
    - Token 刷新机制：Token 的过期时间也要设置的尽可能短

依赖 Cookie，用户可以在浏览器端禁用 Cookie,不支持跨端兼容 app



## JWT

> [JWT](https://jwt.io/)

- JWT Token = header.payload.signature
- Header = base64url({ typ, alg, ...})
  - typ：表示令牌类型，JWT 令牌统一写为 JWT
  - alg：签名算法，默认为 HS256
- Payload = base64url({...})
- Signature = HASH(Header.Payload, secret)


