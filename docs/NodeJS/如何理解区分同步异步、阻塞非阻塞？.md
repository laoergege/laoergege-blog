

- **同步/异步关注的是事物之间的行为模式、协作关系**
  > 一个事物的发生必须等待另一事物的结束，这就是同步，反之亦是异步，说明事物之间没有因果顺序关系，是独立发生的
- **阻塞/非阻塞描述的是事物的状态**
  > 阻塞/非阻塞描述的是事物的状态，在计算机世界，事物即为线程。阻塞状态时就是只能等待，其他事都做不了

接下来，通过一个系统 I/O 调用过程分层来将同步/异步、阻塞/非阻塞串联起来理解，因为要让一个进程进入阻塞的状态, 要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是它调用 System Call, 而 System Call 因为一般会涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为阻塞状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回就绪状态。

一个 系统 I/O 调用过程需要经历：
1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A 的业务代码

1 和 6 这一层都是我们的用户进程的代码，我

3和4，操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 

但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

编程层次







3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。




- 编程：CPU 计算 + IO 调用
- IO
  - 内存
  - 网络
  - I/O设备
    - 磁盘
- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- 调度模式
  - 抢占式调度
  - 协作式调度
- 并发模型
  - 多线程
    - 编程语言实现多线程模型，大多基于操作系统提供的原生线程，再包装一层出来给开发者用。而封装的线程和OS线程是一对一关系，线程调度完全交给操作系统就完事了，编程语言的Runtime实现也相对简单
    - 这叫竞态条件（Race Condition）。解决这类问题，需要用到各种同步原语：从CPU硬件层面的CAS指令；到OS级别的临界区、信号量、互斥量；再到编程语言的原子类型、各种锁、同步栅栏、并发安全的集合，都是让内存数据能被多核CPU安全地修改。
    - 1:1 线程模型
    - M:N 线程模型
  - 单线程 + I/O多路复用 + 事件驱动 + 事件循环 + 消息队列
  - 协程 + 调度器 + CSP/Actor(CSP模型/Actor模型：回归同步调用，放到有栈的协程/线程。)
    - 协程就是 用户态线程。协程的调度完全由开发者进行控制，因此实现协程的关键也就是 实现一个用户态线程的调度器。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在 IO 上的性能瓶颈。
    - 协程最核心的特点就是：不用OS线程的上下文切换，在用户态实现超轻量的执行单元调度。
    - 编程语言的演进过程也是互相“借鉴”的过程，最后的结果就是“你有我有全都有”。其中最典型的“借鉴”就是Generator函数，搭配async/await或yield实现无栈协程。
    - 两者方式去实现合作型多任务处理
      - 回调
      - 绿色线程
        - 编程语言将阻塞操作转为无阻塞
        - 将其控制权交到其他的执行线程
    - 在合作型多任务处理中，总有一个处理内核负责所有I/O处理。其在设计模式中称为反应器模式




反应器设计模板的目的是避免为每个消息、请求和连接创建线程的常见问题。它接收来自多个处理程序的事件，并按顺序将它们分发给相应的事件处理程序。原则上，标准 Reactor 允许应用程序在同时发生事件的情况下运行，同时保持单线程处理的简单性。它通常会使用非阻塞同步 I/O（查看I/O 模型中的多路复用）。更有趣的是Proactor 模式。它是 Reactor 模式的异步版本。它通常使用操作系统提供的真正异步 I/O 操作（查看I/O 模型中的 AIO）。





