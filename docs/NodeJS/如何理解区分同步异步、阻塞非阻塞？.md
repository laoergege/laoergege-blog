# 如何理解区分同步/异步、阻塞/非阻塞？

可能很多人会难以区分、混淆两者概念？比如，

- 如果“同步”是发起了一个调用后， 没有得到结果之前不返回， 那它毫无疑问就是被“阻塞”了（即调用进程处于 “waiting” 状态）。
- “异步”调用发出了以后就直接返回了，毫无疑问，这个进程没有被“阻塞”。

上面**在代码调用层面**确实如此，但却不能因为两者给人感觉是一样的，甚至可能会将两者意思等价起来。但回归本质来讲两者是不同的概念:

- **同步/异步关注的是事物之间的行为模式**
  > 一个事物的发生必须等待另一事物的结束，这就是同步，反之亦是异步，说明事物之间没有顺序关系，是独立发生的
- **阻塞/非阻塞描述的是事物的状态**
  > 阻塞/非阻塞描述的是事物的状态，在计算机世界，事物即为线程。阻塞状态时就是只能等待，其他事都做不了

接下来，通过一个系统 I/O 调用过程分层来将同步/异步、阻塞/非阻塞串联起来理解，因为要让一个进程进入阻塞的状态, 要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是它调用 System Call, 而 System Call 因为一般会涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为阻塞状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回就绪状态。

一个 系统 I/O 调用过程需要经历：
1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A 的业务代码

1 和 6 这一层都是我们的用户进程的代码，我

3和4，操作系统内核在执行 System Call 时， CPU 需要与 IO 设备完成一系列物理通信上的交互， 其实再一次会涉及到阻塞和非阻塞的问题， 例如， 操作系统发起了一个读硬盘的请求后， 其实是向硬盘设备通过总线发出了一个请求，它即可以阻塞式地等待IO 设备的返回结果，也可以非阻塞式的继续其他的操作。 在现代计算机中，这些物理通信操作基本都是异步完成的， 即发出请求后， 等待 I/O 设备的中断信号后， 再来读取相应的设备缓冲区。 

但是，大部分操作系统默认为用户级应用程序提供的都是阻塞式的系统调用 （blocking systemcall）接口， 因为阻塞式的调用，使得应用级代码的编写更容易（代码的执行顺序和编写顺序是一致的）。

但同样， 现在的大部分操作系统也会提供非阻塞I/O 系统调用接口（Nonblocking I/O system call）。 一个非阻塞调用不会挂起调用程序， 而是会立即返回一个值， 表示有多少bytes 的数据被成功读取（或写入）。

编程层次







3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。

参考：

- [怎样理解阻塞非阻塞与同步异步的区别？ - 灵剑的回答 - 知乎](https://www.zhihu.com/question/19732473/answer/117012135)


- 编程：计算 + IO调用
- IO 调用模式
  - 同步阻塞
  - 同步非阻塞（主动轮询）
  - 事件驱动
    - IO 多路复用
- 任务调度
  - 同步/异步模式
  - 并发模式
    - 多线程
    - 单线程 + I/O多路复用 + 事件驱动 + 事件循环 + 消息队列
    - 协程 + 调度器

- 单核：分时
- 多核：多线程

并发

- 多线程多进程
- 异步编程

架构
- 分模块可维护
- 扩展性

- 异步体系
  - 硬件
  - 操作系统
  - 异步编程范式



我们终于可以确定“异步编程模型”应该是什么样子了：

1、最上层是进程；进程是持有资源的最小单位

2、中层是线程；线程不持有资源，是CPU调度的最小单位

3、下层是协程；协程既不持有资源、也不必在意CPU调度，它仅仅关注“协作式的、自然的执行流程切换”


函数响应式编程（FRP） ≈ 函数式编程（FP） + 发布订阅模式