# Vue 的响应式系统

## Vue2 vs Vue3

Vue2 和 Vue3 的响应式原理其实没多大区别，本质都是劫持收集依赖，通知变化更新，也就是一个观察者模式。主要是响应式实现的使用到的底层 api 又 `Object.defineProperty` 改为 `Proxy`，

Object.defineProperty 缺点 

- 不能监听对象属性新增和删除
- 对象属性递归响应式化消耗性能

Proxy 优点

- 劫持整个对象

## Map & WeakMap

## 源码分析

Vue 提供了四种响应式类型

- reactive
- readonly
- shallowReactive
- shallowReadonly

其中 readonly，可以把响应式对象设置为只读，这样就不会被依赖收集；shallow，对对象数据不做深层代理。

本文主要分析基础的 reactive 类型

```js
// packages/reactivity/src/effect.ts

```

## 响应式 API 原理实现

```js
function createReactiveObject(target) {
    if(typeof target !== 'object') {
        return target
    }
}
```


 * ```js
 * const count = ref(0)
 * const obj = reactive({
 *   count
 * })
 *
 * obj.count++
 * obj.count // -> 1
 * count.value // -> 1
 * ```


export const enum ReactiveFlags {
  SKIP = '__v_skip', // 跳过响应化
  IS_REACTIVE = '__v_isReactive', // 是否响应式数据
  IS_READONLY = '__v_isReadonly', // 是否只读数据
  RAW = '__v_raw' // 获取原生数据、表明该 target 是 proxy 对象
}

对象类型
缓存重复对象
白名单对象类型才能 响应式
- common 数组、对象
- 集合 set map

- api
  - 响应式
    - reactive
    - ref