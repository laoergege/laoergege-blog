# 视图驱动下的前端业务开发模式

- 前端架构发展
  - 前后端分离模式
  - RestFul 架构
  - 渲染模式
    - CSR
    - SSR
    - SSG 
    - ISR
    - Streaming SSR：让开发人员将应用程序分成块，这些块可以逐步从服务器并行发送到客户端
    - Island
- 视图驱动、组件优先
- 状态管理

## 前端架构发展

如今的前后分离模式已经不能再单纯从代码运行的位置进行划分，而是从分工角度：前端负责渲染逻辑、后端负责业务逻辑。既然是前端

CSR → SSR → NSR → ESR

## RestFul 架构

什么是 RestFul？RestFul 是 3 个单词的合并缩写：

- Re（Representational）：前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation
- st（State）：在 RestFul 架构中，状态仅仅存在于服务端，前端无状态。状态（State）可以理解为业务的状态，这个状态是由服务端管理的
- Ful（Transfer）：即改变状态。

Restful 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。这个方法可以让前后端职责清晰，前端负责渲染， 服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口。

[前后端接口规范 - RESTful 版](https://mp.weixin.qq.com/s/DCQGjHizp88FDX7Vgcqggw)

## 视图驱动、组件优先

视图驱动：在前后分离的模式下，**大多数前端业务开发流程都是以视图驱动为主**，并且在前端框架**组件**概念的设计下，形成了以**组件优先**的开发模式:

1. 先根据 UI 稿子拆分成组件、面向组件写页面
2. 再根据原型文档与接口完成业务交互

### 组件范式

在了解前端组件设计前，得先明白框架渲染原理（React、Vue）

- 主流框架原理（React、Vue）
  - 底层原理
    - 渲染：视图是数据模型的一种映射 `UI = f(state)`
    - 响应
      - 数据驱动：state => UI
      - *事件驱动*
  - 上层范式：状态可以映射到 UI，那么如何管理好状态对应的映射关系？
    - 组件：作为上层范式，将状态与「和他相关的 UI」约束在一起
    - 组件范式
      - 对象形式
      - 函数式

### 逻辑分离、复用

### 对象组件 => 耦合及复用问题

对象组件概念借鉴了“OOP”的封装概念，但抛弃了传统的“OOP”的继承和多态思想，通过面向对象之类的思想来对界面或者业务做模块化尝试复用。

前端框架的组件是应用构成基本单位，但是不是逻辑复用的最小单位，因为**组件 = 视图模板 + 状态逻辑**。



  - 现状问题：主流前端框架以组件为中心的开发范式下，在视图组件里编写越来越多的代码，并成了一个流行趋势，**组件同时承载了业务逻辑和界面逻辑**
- 逻辑分离、复用
  - 
  - 组件耦合及复用问题
    - 逻辑与 UI **耦合**在一起

    - React通过HOC、renderProps
    - Vue2通过mixin
  - 逻辑分离、复用：将可复用的逻辑从组件中抽离出来，放到单独的 Model 层
- 状态管理

## 面向 Model 层

- ui
- 业务
- 对Model层的管理，也就是所谓的「状态管理」



组件以视图为中心、视图驱动，State 是围绕 View 的消费和交互需求而产生的，View 是组件真正核心的部分

- 过去思路：视图驱动，组件优先
  - State/View 放到一个函数里，还是 class 里，State/View 之间都构成了一一对应的绑定关系。State 是围绕 View 的消费和交互需求而产生的，View 是组件真正核心的部分。
  - 当 State 和 View 绑定起来时，难以达到最大化 Model 层代码复用的目标。
   1. state 离不开视图
   2. 需要什么请求什么

## 状态逻辑管理

组件模式下，整个应用最终以组件树的形式组织展示，组件封装状态逻辑，逻辑自治，但分散在组件树，树形结构阻碍了组件数据通信。"状态管理" 的核心就是解决数据通信及规范化问题。

组件通信模式：

- 关联组件（如父子组件）直接通过事件通知
- 跨组件则状态提升
- 深层组件则全局单例
  - 依赖注入，控制反转



状态设计
    - 数据扁平化
    - 状态机
    - 结构化


> 理解「状态」是什么，理解「状态」的类型

- 状态分类
  - 本地 UI 状态
    - 状态提升、自定而下、
  - 远程服务状态
    - [react-query](https://github.com/tannerlinsley/react-query)
  - 应用状态
  - 业务流程状态
    - 状态机
  - 事件流
    - rxjs

1. 如何驱动 UI
2. 组合与抽象
3. 全局单例 vs 树形结构的局部单例
4. 状态订阅
5. 状态更新的方法是同步或异步的、副作用隔离
6. TypeScript
7. 提供异步事件流管理方案
8. 性能优化：运行时重复渲染性能优化
9. 内存优化








## 分层架构

MVC 是一种软件架构模式，通常用于开发用户界面，主要是在解决数据逻辑和视图逻辑的分离问题；**MVC 在不同编程领域有不同的通信模型变化**，而在 web 前端领域里通常是 MVP 和 MVVM 的 MVC 变种模型，并且前端的 MVC 对应整个 web 应用的 MVC 模型中的 V。


主要由三部分组成

- Model：应用的状态管理和业务逻辑
- View：视图渲染和视图逻辑管理
- Controller：控制器，接受、处理用户指令，调度数据模型和视图通信

![图 3](./images/1654518410646.png)  


我觉得全部用外部状态，状态在组件使用的时候和view建立映射响应，是比较合适的方案。好处在于数据逻辑可以脱离视图，而不是只在组件层做复用；有点类似于 mvvm中 vm的概念；但应该是 modelView；而不是react 或者vue组件中所提供的vm





- 数据层
  - 业务 Model
    - 前后分离的，前端本身就没正真意义上的 Model，有也是缓存部分业务数据和用户交互的那部分业务逻辑
  - Service 数据服务
  - VM
    - 框架本身核心就是要提供一个更好用的视图层，框架的 model 还是服务于 view 的。至于业务的 model，并不是他们所关心的，而是要开发者自己去设计
  - UI state
- 逻辑层
- 视图层




## 数据流设计

- Pina
 - TypeScript 支持
 - DevTools 支持
   - 动作、响应追踪
   - 商店出现在使用它们的组件中
   - 时间旅行和更容易的调试
 - 热模块更换
 - SSR 支持
 - 插件扩展
 - 轻量、tree-shaking
 - api
   - defineStore 定义数据模型
- featrue
  - class 范式
  - DI

```js
import { inject, provide, reactive } from "vue";
const STORE_KEY = "xxx";
export function useUserService(options) {
  return inject(STORE_KEY) && createUserService(options);
}
export function createUserService(options) {
  return provide(STORE_KEY, Service, options);
}

@Injectable()
class UserService {
  #name;

  constructor() {
    super();
  }
  get fullName() {
    return;
  }
}

class User {
  userID

  @asyncComputed
  user() {
    return fetch('/api/user/' + this.userID)
  }
}

@Use(User)
class Student {}

export { createStore, useStore };
```

## Vue3 组件开发范式

```js
// 1.对象式 setup 组件
const App = {
  name: "xxx",
  props: ["xxx"],
  setup(props, ctx) {
    // 1.返回状态
    //return {}

    // 2.返回渲染函数
    return () => h("xxx");

    // 探索模板字符串标签
    // return () => vue`<div>{{xxx}}</div>`
  },
};

// 2.函数式组件（本质渲染函数，vue3 后函数组件的函数签名跟状态组件 setup 保持一致）
// const App = (props, ctx) => {
//   return <div>{xxx}</div>
// }

// 3. setup 函数
// const App = (props, ctx) => {
//   return () => <div>{xxx}</div>
// }
// defineComponent(App)

// App.props = ['value']
// App.emits = ['click']
```

## 参考

- [面向 Model 编程的前端架构设计](https://mp.weixin.qq.com/s/g4hnfirDmyeuXAdEt-zk9w)
- [Hooks是否过誉了？前端应该跟着React走还是跟着JS、TS走？ - beeplin的回答 - 知乎](https://www.zhihu.com/question/468249924/answer/1968728853)





