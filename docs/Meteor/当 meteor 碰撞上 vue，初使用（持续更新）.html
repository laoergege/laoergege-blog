<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>akryum:vue-component | laoergege blog</title>
    <meta name="description" content="Just For Fun">
    
    
    <link rel="preload" href="/laoregege-blog/assets/css/0.styles.2731f072.css" as="style"><link rel="preload" href="/laoregege-blog/assets/js/app.41457635.js" as="script"><link rel="preload" href="/laoregege-blog/assets/js/2.afa2900c.js" as="script"><link rel="preload" href="/laoregege-blog/assets/js/28.84568e96.js" as="script"><link rel="prefetch" href="/laoregege-blog/assets/js/10.61c009e0.js"><link rel="prefetch" href="/laoregege-blog/assets/js/11.e738f172.js"><link rel="prefetch" href="/laoregege-blog/assets/js/12.a7a1a835.js"><link rel="prefetch" href="/laoregege-blog/assets/js/13.7f0b0d40.js"><link rel="prefetch" href="/laoregege-blog/assets/js/14.f4eba2ad.js"><link rel="prefetch" href="/laoregege-blog/assets/js/15.a49020dd.js"><link rel="prefetch" href="/laoregege-blog/assets/js/16.de300aad.js"><link rel="prefetch" href="/laoregege-blog/assets/js/17.9b93e00b.js"><link rel="prefetch" href="/laoregege-blog/assets/js/18.31f5b602.js"><link rel="prefetch" href="/laoregege-blog/assets/js/19.2e5bf559.js"><link rel="prefetch" href="/laoregege-blog/assets/js/20.ded01176.js"><link rel="prefetch" href="/laoregege-blog/assets/js/21.c3c259b3.js"><link rel="prefetch" href="/laoregege-blog/assets/js/22.ec116f47.js"><link rel="prefetch" href="/laoregege-blog/assets/js/23.9b9caf0d.js"><link rel="prefetch" href="/laoregege-blog/assets/js/24.fe90e203.js"><link rel="prefetch" href="/laoregege-blog/assets/js/25.234d0588.js"><link rel="prefetch" href="/laoregege-blog/assets/js/26.5eb595a7.js"><link rel="prefetch" href="/laoregege-blog/assets/js/27.4b4e18c8.js"><link rel="prefetch" href="/laoregege-blog/assets/js/29.53c57bcb.js"><link rel="prefetch" href="/laoregege-blog/assets/js/3.7ae5402d.js"><link rel="prefetch" href="/laoregege-blog/assets/js/30.b627bc9a.js"><link rel="prefetch" href="/laoregege-blog/assets/js/31.06573bcc.js"><link rel="prefetch" href="/laoregege-blog/assets/js/32.a85b1687.js"><link rel="prefetch" href="/laoregege-blog/assets/js/33.721f4386.js"><link rel="prefetch" href="/laoregege-blog/assets/js/34.05bffb34.js"><link rel="prefetch" href="/laoregege-blog/assets/js/35.ed6fdcb2.js"><link rel="prefetch" href="/laoregege-blog/assets/js/36.2cbc1004.js"><link rel="prefetch" href="/laoregege-blog/assets/js/37.9fd5bc93.js"><link rel="prefetch" href="/laoregege-blog/assets/js/38.eb936ad6.js"><link rel="prefetch" href="/laoregege-blog/assets/js/39.0d6e486c.js"><link rel="prefetch" href="/laoregege-blog/assets/js/4.59116900.js"><link rel="prefetch" href="/laoregege-blog/assets/js/40.638edff1.js"><link rel="prefetch" href="/laoregege-blog/assets/js/41.dce05572.js"><link rel="prefetch" href="/laoregege-blog/assets/js/42.e49e7c8f.js"><link rel="prefetch" href="/laoregege-blog/assets/js/43.83e0b8db.js"><link rel="prefetch" href="/laoregege-blog/assets/js/44.87de43a7.js"><link rel="prefetch" href="/laoregege-blog/assets/js/45.dfe2bb27.js"><link rel="prefetch" href="/laoregege-blog/assets/js/46.6232cdb0.js"><link rel="prefetch" href="/laoregege-blog/assets/js/47.2e222b75.js"><link rel="prefetch" href="/laoregege-blog/assets/js/48.ccdbe3bc.js"><link rel="prefetch" href="/laoregege-blog/assets/js/5.ffe58514.js"><link rel="prefetch" href="/laoregege-blog/assets/js/6.cdf21dfd.js"><link rel="prefetch" href="/laoregege-blog/assets/js/7.46459a23.js"><link rel="prefetch" href="/laoregege-blog/assets/js/8.57168558.js"><link rel="prefetch" href="/laoregege-blog/assets/js/9.26b4d1f9.js">
    <link rel="stylesheet" href="/laoregege-blog/assets/css/0.styles.2731f072.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/laoregege-blog/" class="home-link router-link-active"><!----> <span class="site-name">laoergege blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="akryum-vue-component"><a href="#akryum-vue-component" class="header-anchor">#</a> akryum:vue-component</h2> <p>使用 <a href="https://github.com/meteor-vue/vue-meteor/tree/master/packages/vue-component" target="_blank" rel="noopener noreferrer">akryum:vue-component<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 包帮助 meteor 识别编译 vue 文件。</p> <div class="language- extra-class"><pre class="language-text"><code>meteor add akryum:vue-component
</code></pre></div><h2 id="vue-meteor-tracker"><a href="#vue-meteor-tracker" class="header-anchor">#</a> vue-meteor-tracker</h2> <p>使用 <a href="https://github.com/meteor-vue/vue-meteor-tracker" target="_blank" rel="noopener noreferrer">vue-meteor-tracker<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 包，在 Vue 组件中集合 Meteor 响应数据。</p> <h3 id="installation"><a href="#installation" class="header-anchor">#</a> Installation</h3> <div class="language- extra-class"><pre class="language-text"><code>meteor npm install --save vue-meteor-tracker
</code></pre></div><h3 id="install-the-plugin-into-vue"><a href="#install-the-plugin-into-vue" class="header-anchor">#</a> Install the plugin into Vue</h3> <div class="language- extra-class"><pre class="language-text"><code>import VueMeteorTracker from 'vue-meteor-tracker';
Vue.use(VueMeteorTracker);
</code></pre></div><h3 id="use"><a href="#use" class="header-anchor">#</a> Use</h3> <p>在你的 vue 组件中添加 meteor 对象属性 :</p> <div class="language- extra-class"><pre class="language-text"><code>new Vue({
  meteor: {
    // Meteor specific options
  }
});
</code></pre></div><h3 id="subscriptions"><a href="#subscriptions" class="header-anchor">#</a> Subscriptions</h3> <p>在 $subscribe object 定义订阅者，key 为发布者名称，value 为数组参数，在订阅的时候传递给发布者。</p> <blockquote><p>当组件销毁时订阅将停止</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>meteor: {
  //在 $subscribe object 定义订阅者
  $subscribe: {
    // 不带参数订阅 'threads' 发布者 
    'threads': [],
    // 带参数订阅 'threads' 发布者 
    'threads': ['new', 10], // The 10 newest threads
    // 带动态参数订阅 'threads' 发布者 
    // 当 vue 响应属性改变时，重新订阅
    'posts': function() {
      // Here you can use Vue reactive properties
      return [this.selectedThreadId] // Subscription params
    }
  }
}
</code></pre></div><p>你能够 $subscribe(name, ...params) 方法在你的组件代码中:</p> <div class="language- extra-class"><pre class="language-text"><code>ready () {
  // Subscribes to the 'threads' publication with two parameters
  this.$subscribe('thread', 'new', 10);
}
</code></pre></div><p>在你的组件中，$subReady 对象属性包含订阅者订阅状态 ，为了获知订阅者是否已订阅，你可以这样做：</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(this.$subReady.thread);
</code></pre></div><p>或者在你的模板中：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div v-if=&quot;!$subReady.thread&quot;&gt;Loading...&lt;/div&gt;
</code></pre></div><h3 id="reactive-data"><a href="#reactive-data" class="header-anchor">#</a> Reactive data</h3> <p>在 meteor 对象里的属性（不在 <em>$subscribe</em> 中）会被转化为 vue 的响应属性（附加到 vue 的 data 属性中） ，你可以在模板中像标准 vue data 属性一样使用，或者在计算属性中。</p> <div class="language- extra-class"><pre class="language-text"><code>...
data() {
      return {
        // 初始化 todos 也不用
        todos: [],
        newTodo: ''
      }
  },
  meteor: {
    $subscribe: {
      ['todos']: []
    },
    // todos 属性会响应更新 meteor 的响应数据源（就像 collections 或者 session ）
    // 当 Todos 集合发生变化时，todos将发生改变
    todos() {
        return Todos.find({}, {sort: {date: -1}});
    }
  },
...
</code></pre></div><p>通过上面做法，仅仅让 vue data 响应更新于 meteor 响应数据源，当 Todos 发生改变，vue 的 todos 数据属性才能获取更新，如下图所示</p> <p><img src="https://api.laoergege.cn//images/ZgLGP1uR4fP4n3NP5SCJ6O0b.PNG" alt="image.png"></p> <p>通过把 meteor 对象属性的值定义为一个对象，我们可以让vue data 不仅响应更新于 meteor 响应数据源，还依赖其他参数（该参数可以为 vue 的响应属性），该对象有以下来个参数：</p> <ul><li>params() (可选), 返回对象的函数, 该对象属性值可以为 vue data 的响应属性</li> <li>update([params]), 但依赖参数发生改变回调的函数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>...
meteor: {
    // 无参订阅 todos 
    $subscribe: {
      [&quot;todos&quot;]: []
    },
    todos: {
      // 声明定义一个依赖 vue 响应属性的参数
      params() {
        // Here you can use Vue reactive properties
        // Don't use Meteor reactive sources!
        return {
          type: this.type
        };
      },
      // 可选项，深度观察嵌套对象属性值，
      // 此处 type 为普通类型，故 false
      deep: false,
      //// Meteor Reactivity
      // param 参数响应 vue 更新时，将刷新 todos 属性值
      // Then it calls Tracker.autorun() to refresh the result
      // each time a Meteor reactive source changes
      update({ type }) {
        //   Here you can use Meteor reactive sources
        //  like cursors or reactive vars
        //  Don't use Vue reactive properties!
        if (type) {
          return Todos.find({checked: true},{sort: {date: -1}});
        } else {
          return Todos.find({checked: false},{sort: {date: -1}});
        }
      }
    }
  },
...
</code></pre></div><p><img src="https://api.laoergege.cn//images/YuPCU1j9e8Up-UmjC-bT0map.PNG" alt="image.png"></p> <h3 id="开启或禁用-meteor-data"><a href="#开启或禁用-meteor-data" class="header-anchor">#</a> 开启或禁用 meteor data</h3> <div class="language- extra-class"><pre class="language-text"><code>export default {
  meteor: {
    // ...
  },

  methods: {
    activate () {
      this.$startMeteor()
    },

    deactivate () {
      this.$stopMeteor()
    },
  },
}
</code></pre></div><h4 id="你能够使用来防止-meteor-data-自启动"><a href="#你能够使用来防止-meteor-data-自启动" class="header-anchor">#</a> 你能够使用来防止 meteor data 自启动</h4> <div class="language- extra-class"><pre class="language-text"><code>export default {
  meteor: {
    $lazy: true,
    // ...
  },
}
</code></pre></div><h3 id="freezing-data"><a href="#freezing-data" class="header-anchor">#</a> Freezing data</h3> <p>此选项将对 Meteor 数据使用 Object.freeze，以防止 Vue 响应。 这样可以在渲染大型集合列表时提高 Vue 的性能。 默认情况下，此选项已关闭。</p> <div class="language- extra-class"><pre class="language-text"><code>// Disable Vue reactivity on Meteor data
Vue.config.meteor.freeze = true;
</code></pre></div><h2 id="vue-supply"><a href="#vue-supply" class="header-anchor">#</a> vue-supply</h2> <h3 id="installation-2"><a href="#installation-2" class="header-anchor">#</a> Installation</h3> <div class="language- extra-class"><pre class="language-text"><code>npm install --save vue-supply
</code></pre></div><h3 id="use-2"><a href="#use-2" class="header-anchor">#</a> Use</h3> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'vue'
import VueSupply from 'vue-supply'

Vue.use(VueSupply)
</code></pre></div><p>当应用变得越来越庞大时，我们需要在每个组件重复定义 meteor 属性，并且我们可能定义同样的值，管理这些响应性数据源就会变得越来越困难。
使用 <a href="https://github.com/Akryum/vue-supply" target="_blank" rel="noopener noreferrer">vue-supply<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，您可以轻松地使用数据并自动激活或停用订阅。</p> <p><img src="https://api.laoergege.cn//images/OZI3m0wNELitR70-1cTCKj85.PNG" alt="image.png"></p> <p>vue-supply 为我们的应用添加了一层 supply，帮助我们管理订阅 meteor 数据，避免在组件重复订阅 meteor 数据。
使用 vue-supply，您可以创建扩展Supply定义的 Vue 实例。定义两个方法: activate 和 deactivate。当在组件或 Vue store 首次消费该 <strong>supply</strong> 时，它会自动激活（使用 <em>grasp</em> 方法）；当没有组件使用它时，它会自动关闭（使用 <em>release</em> 方法）。当激活或关闭时，<strong>supply</strong> 会回调 activate 和 deactivate 方法。</p> <div class="language- extra-class"><pre class="language-text"><code>// base.js
export default {
  extends: Supply,

  methods: {
    activate () {
      // 当激活时，开启 meteor ，订阅发布者
      this.$startMeteor()
    },

    deactivate () {
      // 关闭 meteor ，取消订阅
      this.$stopMeteor();
    },
  },

  meteor: {
     // 关闭 vue-meteor-tracker自启动订阅 meteor data
     // 让 supply 监听组件，管理订阅
    $lazy: true,
  },
}
</code></pre></div><p>当激活或关闭时，<strong>supply</strong> 会发射 consumers 和 active 事件，你可以使用 watch 其属性和 $on 监听其 'is-active' 和 'is-not-active' 事件。</p> <div class="language- extra-class"><pre class="language-text"><code>// xxx.supply.js
import base from &quot;./base&quot;;

export default {
    extends: base,

    data() {
        return {
           ...
        }
    },

    meteor: {
        ...
    },

    watch: {
        // 监听 supply 是否激活
        active(val){
            console.log(val);
        },

        // 监听 组件消费者个数
        consumers(val){
            console.log(val);
        }
    }
}
</code></pre></div><p>你也可以使用 <em>supply.ensureActive()</em>，返回一个 Promise（that resolves as soon as the supply is activated ）</p> <div class="language- extra-class"><pre class="language-text"><code>TestResource.ensureActive().then(() =&gt; {
  // The supply is active
})
</code></pre></div><h3 id="registration"><a href="#registration" class="header-anchor">#</a> Registration</h3> <p>建议注册 <strong>supply 定义</strong>，以便注入到组件和 vuex stroe 中。</p> <div class="language- extra-class"><pre class="language-text"><code>import { register } from 'vue-supply'
import TestResourceDef from 'supply/test-resource'
register('TestResource', TestResourceDef)
</code></pre></div><h3 id="usage-in-components"><a href="#usage-in-components" class="header-anchor">#</a> Usage in components</h3> <p>在组件内部，use（name，manageKeepAlive = true）添加一个mixin，使用注册中使用的名称（如上所述），创建和销毁组件时自动消费或释放 supply：</p> <div class="language- extra-class"><pre class="language-text"><code>// todo-list.component.js
import { use } from &quot;vue-supply&quot;;

export default {
  name: &quot;app&quot;,
  components: {
    &quot;todo-list&quot;: TodoList
  },
  mixins: [use(&quot;TodoSupply&quot;)],
  data() {
    return {
      newTodo: &quot;&quot;
    };
  },
  computed: {
    todos() {
      return this.$supply.TodoSupply.todos;
    },
    ready() {
      return this.$supply.TodoSupply.active;
    },
    type() {
      return this.$supply.TodoSupply.type;
    }
  },
....
</code></pre></div><p>通过计算 <code>this.$supply.TestResource.[someData]</code> 该响应属性获取数据。</p> <h3 id="usage-in-vuex-store"><a href="#usage-in-vuex-store" class="header-anchor">#</a> Usage in Vuex store</h3> <p>see <a href="https://github.com/Akryum/vue-supply#usage-in-vuex-store" target="_blank" rel="noopener noreferrer">Usage in Vuex store<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="加载系统"><a href="#加载系统" class="header-anchor">#</a> 加载系统</h3> <p>每个 <strong>supply</strong> 都有一个 loading 状态，它有两个值状态：</p> <ul><li><code>0</code> 意味着该 <strong>supply</strong> 已经 ready，可以消费了。该值为默认值。</li> <li><code>1 以上</code> 意味着加载状态。</li></ul> <p>你应该改变 loading 属性值在 activate and deactive 方法内，因为一般我们在该方法中发起订阅或取消订阅:</p> <div class="language- extra-class"><pre class="language-text"><code>import { Supply } from 'vue-supply'

export default new Vue({
  extends: Supply,
  methods: {
    activate () {
      console.log('subscribing...')
      // Use the integer `loading` property
      // 0 mean ready
      this.loading ++
      // Faking a server request here :p
      setTimeout(() =&gt; {
        console.log('data is loaded')
        this.loading --
      }, 1000)
    },
  },
})
</code></pre></div><p><strong>supply</strong>有 ready 属性(with a boolean argument), 和 is-ready 、is-not-ready 事件.，你可以去计算 ready 属性或监听事件 。</p> <p>更多详情参考官方 <a href="https://github.com/Akryum/vue-supply#usage-in-vuex-store" target="_blank" rel="noopener noreferrer">vue-supply<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h2 id="collections"><a href="#collections" class="header-anchor">#</a> Collections</h2> <h3 id="aldeed-simple-schema-（设计数据模式）"><a href="#aldeed-simple-schema-（设计数据模式）" class="header-anchor">#</a> aldeed:simple-schema （设计数据模式）</h3> <p>Mongo 数据虽然是无模式，但这不意味着我们就不可以用模式去设计规范验证我们的数据。使用 <a href="https://atmospherejs.com/aldeed/simple-schema" target="_blank" rel="noopener noreferrer">aldeed:simple-schema<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，设计验证我们数据。</p> <h4 id="installation-3"><a href="#installation-3" class="header-anchor">#</a> Installation</h4> <div class="language- extra-class"><pre class="language-text"><code>$ meteor add aldeed:simple-schema
</code></pre></div><h3 id="use-3"><a href="#use-3" class="header-anchor">#</a> Use</h3> <h4 id="定义-schema"><a href="#定义-schema" class="header-anchor">#</a> 定义 Schema</h4> <div class="language- extra-class"><pre class="language-text"><code>// todos.collection.js
export const TodoSchema = new SimpleSchema({
    title: {
        type: String,   
        max: 200,
        min: 1,
        // 自定验证器
        custom: function () {
            if(this.value.trim().length == 0){
                return '不能为空'
            }
        }
    },

    checked: {
        type: Boolean
    },

    date: {
        type: Date
    }
})

todos.schmea = TodoSchema;
</code></pre></div><h4 id="验证"><a href="#验证" class="header-anchor">#</a> 验证</h4> <div class="language- extra-class"><pre class="language-text"><code>// App.vue
data() {
    return {
      newTodo: &quot;&quot;,
      // 定义验证空间，针对不同区域验证
      context: Todos.schmea.namedContext(&quot;myContext&quot;) 
    };
  },
  computed: {
    todos() {
      return this.$supply.TodoSupply.todos;
    },
    ready() {
      return this.$supply.TodoSupply.ready;
    },
    type() {
      return this.$supply.TodoSupply.type;
    }
  },
  methods: {
    submit() {
      let newtodo = {
        title: this.newTodo,
        date: new Date(),
        checked: false
      };
      // 验证
      if (this.context.validate(newtodo)) {
        Todos.insert(newtodo);
      }

       this.newTodo = &quot;&quot;;
    },
</code></pre></div><h4 id="错误信息提示"><a href="#错误信息提示" class="header-anchor">#</a> 错误信息提示</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;span v-show=&quot;context.keyIsInvalid('title')&quot; class=&quot;has-text-danger&quot;&gt;不能为空&lt;/span&gt;
      &lt;div class=&quot;control has-icons-left has-icons-right&quot;&gt;
        &lt;input class=&quot;input is-medium&quot; :class=&quot;{'is-danger': context.keyIsInvalid('title')}&quot; type=&quot;text&quot; placeholder=&quot;write it...&quot; v-model=&quot;newTodo&quot; @keyup.enter=&quot;submit&quot;&gt;
        &lt;span class=&quot;icon is-small is-left&quot;&gt;
          &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;
        &lt;/span&gt;
      &lt;/div&gt;
</code></pre></div><p>这里不多述 <strong>SimpleSchema</strong> 的用法，请自行查看 <a href="https://atmospherejs.com/aldeed/simple-schema" target="_blank" rel="noopener noreferrer">api<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <h3 id="publications-and-data-loading（发布订阅）"><a href="#publications-and-data-loading（发布订阅）" class="header-anchor">#</a> Publications and Data Loading（发布订阅）</h3> <p>为了提高数据安全性，我们不应该直接在客户端使用 Collections ，不应该直接调用 collection.insert() 等方法对数据库进行写入。我们应该服务端发布可访问的共有数据，定义数据写入接口：</p> <ul><li>Meteor.pulish() 定义数据发布接口</li> <li>Meteor.methods() 定义数据操作接口</li></ul> <blockquote><p>publisher 在没有想要返回数据情况下要返回this.ready()</p></blockquote> <p><strong>服务端发布</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// todos.collection.js
if (Meteor.isServer) {
    // 定义数据发布接口
    Meteor.publish('todos', function tasksPublication() {
        return todos.find({});
    });
    // 定义数据操作接口
    Meteor.methods({
        ['todos.insert'](val) {
            todos.insert(val);
        },

        ['todo.update.checked']({_id: _id, checked: _checked}) {
            Todos.update(
                { _id: _id },
                { $set: { checked: _checked } },
                { multi: true }
            );
        }
    })
}
</code></pre></div><p><strong>客户端订阅</strong></p> <div class="language- extra-class"><pre class="language-text"><code>const handle = Meteor.subscribe（'lists.public'）;
/**
handle：
{
.ready()：boolean（true：当this.ready()明确调用，或者返回的游标的初始内容将被发送）
.stop()：停止订阅，清除缓存
}
*/
</code></pre></div><p>你能够自定义错误信息发送到客户端：</p> <div class="language- extra-class"><pre class="language-text"><code>// on the server, pick a code unique to this error
// the reason field should be a useful debug message
throw new Meteor.Error(&quot;logged-out&quot;,
  &quot;The user must be logged in to post a comment.&quot;);

// on the client
Meteor.call(&quot;methodName&quot;, function (error) {
  // identify the error
  if (error &amp;&amp; error.error === &quot;logged-out&quot;) {
    // show a nice error message
    Session.set(&quot;errorMessage&quot;, &quot;Please log in to post a comment.&quot;);
  }
});
</code></pre></div><h3 id="aldeed-collection2（自动验证数据）"><a href="#aldeed-collection2（自动验证数据）" class="header-anchor">#</a> aldeed:collection2（自动验证数据）</h3> <p>扩展 Mongo.Collection，提供对 Collection 指定 Schmea，在进行插入和更新数据时自动验证数据模式。</p> <div class="language- extra-class"><pre class="language-text"><code>// todos.collection.js
if (Meteor.isServer) {
    // 定义数据发布接口
    Meteor.publish('todos', function tasksPublication() {
        return todos.find({});
    });
    // 定义数据操作接口
    Meteor.methods({
        ['todos.insert'](val) {
            try {
                todos.insert(val);
            } catch (error) {

                if (error.sanitizedError.error == 400) {
                     // 由于验证只在服务端，所以必须把验证错误信息反馈给前台  
                    // 发送 验证错误消息
                    error.sanitizedError.error = 'ValidationErrors';
                    throw error.sanitizedError;
                }
            }
        },

        ...
    })
}
...

todos.schema = TodoSchema;

// 指定附加 Schema
todos.attachSchema(TodoSchema);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// app.vue
submit() {
      let newtodo = {
        title: this.newTodo,
        date: new Date(),
        checked: false
      };
      // 重置验证器
      this.context.resetValidation() 

      // 调用远程服务
      Meteor.call(&quot;todos.insert&quot;, newtodo,  (error) =&gt; {
        // 动态添加错误验证消息
        if(error &amp;&amp; error.error == 'ValidationErrors')
          this.context.addInvalidKeys(JSON.parse(error.details))
      });

      this.newTodo = &quot;&quot;;
    },
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 响应反馈错误消息
 &lt;span v-show=&quot;context.keyIsInvalid('title')&quot; class=&quot;has-text-danger&quot;&gt;{{context.keyErrorMessage('title')}}&lt;/span&gt;
</code></pre></div><h3 id="分页"><a href="#分页" class="header-anchor">#</a> 分页</h3> <p>分页是一种非常常见的数据访问模式。通常有两种分页样式，即“逐页”样式，您只能在一段时间只显示一页结果，从某些偏移开始（用户可以控制），以及“无限滚动“样式。
在逐页技术中，如果我们要达到以下效果：</p> <p><img src="https://api.laoergege.cn//images/dJEIssZEspCZRa8IB4dveJn1.PNG" alt="image.png"></p> <p>我至少要关注三个参数：</p> <ul><li>skip，跳过第几页</li> <li>limit，每页显示数据数量</li> <li>pages，总页数</li></ul> <p>通过在 $subscribe 子属性值中返回 vue响应属性数组（订阅参数），我们可以响应式向服务端发布者获取不同页码数据。</p> <div class="language- extra-class"><pre class="language-text"><code>//todos.supply.js
...
data() {
        return {
            // 初始化属性值
            todos: [],
            type: false, // type 用来标志 todos 列表显示完成或未完成
            skip: 0,    // 跳过页数
            limit: 5,   // 显示数据数量
            pages: 0 // 页数
        }
    },

    meteor: {
        // 无参订阅 todos 
        $subscribe: {
            [&quot;todos&quot;]: function () {
                // 响应式订阅
                return [this.type, this.limit, this.skip] //查询 是否已标记， 数据量， 跳跃点
            }
        },
        todos() {
            this.pages = Math.ceil(Counts.get('todosCounts')/this.limit) || 1; // 计算页数
            return Todos.find({}, {sort: { date: -1 }});
        }
    },
...
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// todos.collection.js
 Meteor.publish('todos', function tasksPublication(checked, limit, skip) {
        // 实时订阅 todos 总数
        Counts.publish(this, 'todosCounts', todos.find({ checked: checked }));
        return todos.find({ checked: checked }, { limit: limit, skip: skip * limit, sort: { date: -1 } });
    });
</code></pre></div><h4 id="tmeasday-publish-counts（实时获取-collection-count）"><a href="#tmeasday-publish-counts（实时获取-collection-count）" class="header-anchor">#</a> tmeasday:publish-counts（实时获取 Collection Count）</h4> <p>在上面代码中，使用 <a href="https://atmospherejs.com/tmeasday/publish-counts" target="_blank" rel="noopener noreferrer">tmeasday:publish-counts<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 包，来实时获取 todos 总数量，再计算出总页数。publish-counts 有以下主要方法：</p> <ul><li>Counts.publish [server] ，服务端代码中订阅集合</li> <li>Counts.get [client]<br>
一旦你在服务端调用 Counts.publish , 你就可以在客户端调用 Counts.get('name-of-counter') 去响应获取计数器.
该方法会返回一个整数, 返回 0 意味着你还没发布或订阅不成功。</li> <li>Counts.has [client]，判断是否有指定计数器。</li></ul> <h3 id="集合关联"><a href="#集合关联" class="header-anchor">#</a> 集合关联</h3> <p>非关系型数据库 MongoDB 推荐我们更多的是文档嵌套，把多个文档嵌套成一个文档。但有时在文档的设计规范上，我们需要将数据分成两个或以上的集合储存。</p> <h3 id="用户系统"><a href="#用户系统" class="header-anchor">#</a> 用户系统</h3> <p>meteor 基于 accounts-base 内置有一套用户系统，该用户集合基于标准的模式，大概字段如下：</p> <div class="language- extra-class"><pre class="language-text"><code>{
  _id: 'QwkSmTCZiw5KDx3L6',  // Meteor.userId()
  username: 'cool_kid_13', // Unique name
  emails: [
    // Each email address can only belong to one user.
    { address: 'cool@example.com', verified: true },
    { address: 'another@different.com', verified: false }
  ],
  createdAt: new Date('Wed Aug 21 2013 15:16:52 GMT-0700 (PDT)'),
  profile: {
    // The profile is writable by the user by default.
    name: 'Joe Schmoe'
  },
  //请注意，当用户注册不同的登录服务时，services 模式是不同的。
  services: {
    facebook: {
      id: '709050', // Facebook ID
      accessToken: 'AAACCgdX7G2...AbV9AZDZD'
    },
    resume: {
      loginTokens: [
        { token: '97e8c205-c7e4-47c9-9bea-8e2ccc0694cd',
          when: 1349761684048 }
      ]
    }
  }
}
</code></pre></div><ul><li>通过 <code>Meteor.users</code> 访问用户集合</li> <li>客户端访问 <code>Meteor.userId()</code> 并且 <code>Meteor.user()</code>，其获取用户登录状态及信息。</li> <li>服务端在 publish 和 method 方法里，通过 <code>this.userId()</code> 和 <code>this.user()</code> 访问当前用户。</li></ul> <p>meteor 支持多种第三方登录验证：</p> <div class="language- extra-class"><pre class="language-text"><code># pick one or more of the below
meteor add accounts-facebook
meteor add accounts-google
meteor add accounts-github
meteor add accounts-twitter
meteor add accounts-meetup
meteor add accounts-meteor-developer
</code></pre></div><p>你可以到 <a href="https://atmospherejs.com/useraccounts/core?q=" target="_blank" rel="noopener noreferrer">atmospherejs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，搜索你想要的包及用法，目前很多第三方都支持 OAth，如果上述提供的第三方不满足，你可查看 <a href="https://guide.meteor.com/accounts.html#oauth" target="_blank" rel="noopener noreferrer">官方 OAuth 指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h4 id="accounts-password"><a href="#accounts-password" class="header-anchor">#</a> accounts-password</h4> <p>对于大多数，我们还是以密码登录自己服务器验证方式。</p> <div class="language- extra-class"><pre class="language-text"><code>meteor add accounts-password
</code></pre></div><ul><li><code>Accounts.createUser</code> 创建用户</li> <li><code>Meteor.logout([callback])</code> 注销</li> <li><code>Meteor.loginWithPassword(user, password, [callback])</code> 密码登录</li> <li><code>Accounts.findUserByUsername</code> 和 <code>Accounts.findUserByEmail</code> 方法查找用户</li></ul> <p>更多 api <a href="http://docs.meteor.com/api/passwords.html" target="_blank" rel="noopener noreferrer">查看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>accounts-password 还提供一个有趣的 <a href="https://guide.meteor.com/accounts.html#email-flows" target="_blank" rel="noopener noreferrer">电子邮箱工作流<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <ol><li>重设密码。当用户点击他们的电子邮件中的链接时，他们被带到一个他们可以为他们的帐户输入新密码的页面。</li> <li>用户注册。新用户由管理员创建，但没有设置密码。当用户点击他们的电子邮件中的链接时，他们将被转到一个页面，他们可以为他们的帐户设置一个新的密码。非常类似于密码重置。</li> <li>电子邮件验证。当用户单击其电子邮件中的链接时，应用程序会记录此电子邮件确实属于正确的用户。</li></ol> <h4 id="meteor-user-集合自定义数据"><a href="#meteor-user-集合自定义数据" class="header-anchor">#</a> Meteor user 集合自定义数据</h4> <p>随着您的应用程序变得更加复杂，您将始终需要存储有关个人用户的一些数据，而将这些数据放置在上述 Meteor.users 其他字段中。在更规范情况下，将 Meteor 的用户数据和您的数据保存在两个独立的表中是一个好主意，但由于MongoDB不能很好地处理数据关联，所以只需使用一个集合即可。</p> <h5 id="将顶级字段添加到用户文档中"><a href="#将顶级字段添加到用户文档中" class="header-anchor">#</a> 将顶级字段添加到用户文档中</h5> <div class="language- extra-class"><pre class="language-text"><code>// Using address schema from schema.org
// https://schema.org/PostalAddress
const newMailingAddress = {
  addressCountry: 'US',
  addressLocality: 'Seattle',
  addressRegion: 'WA',
  postalCode: '98052',
  streetAddress: &quot;20341 Whitworth Institute 405 N. Whitworth&quot;
};
Meteor.users.update(userId, {
  $set: {
    mailingAddress: newMailingAddress
  }
</code></pre></div><h4 id="用户权限"><a href="#用户权限" class="header-anchor">#</a> 用户权限</h4> <p>官方文档 <a href="https://guide.meteor.com/accounts.html#roles-and-permissions" target="_blank" rel="noopener noreferrer">查看<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/laoregege-blog/assets/js/app.41457635.js" defer></script><script src="/laoregege-blog/assets/js/2.afa2900c.js" defer></script><script src="/laoregege-blog/assets/js/28.84568e96.js" defer></script>
  </body>
</html>
