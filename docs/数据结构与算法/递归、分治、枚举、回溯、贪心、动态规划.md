---
release: true
tags:
  - 递归
  - 分治
  - 回溯
  - 贪心
  - 动态规划
---
  
# 递归、分治、枚举、回溯、贪心、动态规划

## 递归

递归是一种应用非常广泛的算法思维或者编程技巧。

从计算机角度来看：**递归本质就是循环**，通过函数体，自己调自己来进行的循环。递归需要存在**递归终止条件**，不然会造成堆栈溢出。所以写递归关键：
- 寻找重复问题
- 终止条件

从问题模型思考角度来看：递归可以用于**一种自顶向下分层分解成相似子问题（数据规模不一样）的求解模型**，去的过程叫“递”，回来的过程叫“归”。

递归模板：

```js
function recursion(level) {
  // 1. 终止条件
  // 2. 递归缓存返回（可选）
  // 3. 逻辑处理
  // 4. 递归调用
  // 5. 状态重置（可选）
}
```

题目 [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)，树的结构定义本身就符合“分层分解相似子问题的模型”，所以树的问题一般都采用递归的形式。

![图 1](./images/1658252978768.png)  

相比较于常规循环，**递归写出来的代码更加简洁抽象**，符合人类对问题思考。但当看到递归时，我们要**避免不自觉得剖析递归过程**：把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。因此，**求解时只需要关注重复的问题本身以及如何把原问题与子问题递归关系，而不需要过分关注这个子问题是如何被解决的**。

回到翻转二叉树的题目，专注于单一节点（问题）进行解决思考，就是把当前节点的左右子节点对调，然后再分别对子树递归。

```js
var invertTree = function (root) {
    if (!root) {
        return null
    }

    [root.right, root.left] = [invertTree(root.left), invertTree(root.right)]

    return root
};
```

## 分治

分治算法（divide and conquer）的核心思想其实就是四个字，**分而治之** ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

大概的流程可以分为三步：分解 -> 解决 -> 合并：

1. 分解：将原问题分解成一系列子问题；
2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解，无需再分；
3. 合并：将子问题的结果合并成原问题（合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了）。

![图 3](./images/1658343893199.png)  

从分治模型上看，分治算法适合用递归来实现。

> 分治算法是一种处理问题的思想，递归是一种编程技巧。

分治子问题特征：
- 原问题与分解成的小问题具有相同的模式；
- 该问题具有**最优子结构性质**，利用该问题分解出的子问题的解可以合并为该问题的解。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题（**没有重叠子问题，这一点是分治算法跟动态规划的明显区别**）

## 枚举、回溯、贪心、动态规划

题目[《零钱兑换》](https://leetcode.cn/problems/coin-change/)。

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。  
计算并返回可以凑成总金额所需的**最少**的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 枚举

面对最值问题（求最大、最小、最优之类）的求解，本质上还是需要进行穷举，即**枚举所有的可能，从所有候选答案中去搜索正确的解**（枚举思想）。

如何穷举？除非条件真的客观存在只能一一枚举，否则我们应该持有一种机器思维，寻找重复关系然后用循环、递归的方式去完成。

针对上面题目，我们需要从 `[1, 2, 5]` 中列出不同的组合。

### 回溯

回溯算法本质上就是一种暴力的穷举搜索算法。[搜索算法实际上是根据初始条件和扩展规则构造一棵“解答树”并寻找符合目标状态的节点的过程](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/2988274)。

不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成

回溯算法 = 树的深度优先搜索 + 剪枝函数

我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们采用**试错的思想**，把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，选择另选一种走法继续走。

回溯算法非常适合用递归代码实现，而且递归这种形式，正是赋予了回溯这种可以回退一步的能力：它通过堆栈保存了上一步的当前状态。

![图 1](./images/1660577073814.png)  

```js
var coinChange = function (coins, amount) {
    return dfs(coins, amount, 0)
};
var temp = {}
function dfs(coins, amount, level = 0) {
    if (amount === 0) return level

    if (temp[amount]) return temp[amount]

    let min = Infinity
    for (const c of coins) {
        let _amount = amount - c
        if (_amount >= 0) {
            temp[amount] = dfs(coins, _amount, level + 1)
            min = Math.min(min, temp[amount])
        }
    }

    return min === Infinity ? -1 : min
}
```

- 重叠子问题
  - 备忘录/记忆化搜索
  - 剪枝优化
    - 利用预设条件减少搜索路径，优化最优组合搜索方案
      - 贪心策略
    - 重叠子问题：备忘录

### 动态规划

含有备忘录的递归算法已经与动态规划从效率上说基本相差无几，即都是消除重叠子问题的重复计算。那什么是动态规划？

带备忘录的递归解法使用的是自顶向下的处理方式来解题，它离我们日常看到的动态规划还有差距。可以说：

- 回溯 + 备忘录：递归方式（自顶向下处理模型）
- 动态规划：递推方式（自底向上处理模型）

动态规划问题解题的关键是找出“**状态转移方程**”。在之前我们先看问题是否符合动态规划的三个特征：

1. 最优子结构：即能够通过子问题的最优解，推导出问题的最优解。
   
   这一点跟分治类似，分治通过分解问题、合并子问题得到最终解；动态规划关键是方程，方程也是问题与子问题之间关系式，如 `f(n) = f(n - 1) + f(n - 2)`，所以解题时，**我们需要分析“最优子结构”，从而找出状态转移方程**。

2. 重叠子问题：即存在重复问题。
   
   分治中子问题是独立的，而方程之间 `f(n) = f(n - 1) + f(n - 2)` 我们在递推求解过程总是会存在重复问题，刚好可以利用 DP 表去缓存，避免重复计算。

3. 无后效性：子问题之间的依赖是单向性的，某阶段状态一旦确定，就不受后续决策的影响。

那么如何列出正确的状态转移方程？

1. 确定「状态」，也就是原问题和子问题中会变化的变量。题目中，目标金额 `amount` 是变量，而硬币的面额也是题目给定的，硬币数量是因变量，也就是我们要的解
2. 确定「关系」，也就是导致「状态」产生变化的行为，变量与因变量之间的关系式
3. 定义 DP 表：DP 一般根据变量来定义，有两个变量通常定义为二维数组，一个变量一维数组或者散列表都可
4. 确定 base case，从 base case 递推填 DP 表到最终目标

题目的状态转移方程如下：

```
f(n) = Math.min(f(n - 1), f(n - 2), f(n - 5)) + 1
```

```js
var coinChange = function (coins, amount) {
    if (amount === 0) return 0

    let i = 1;
    let temp = coins.reduce((obj, key) => (obj[key] = 1, obj), {})
    while (i <= amount) {
        temp[i] ??= Math.min(...coins.map(c => (temp[i - c] ??= Infinity))) + 1
        i++
    }

    return temp[amount] === Infinity ? -1 : temp[amount]
};
```

## 总结

分治、贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成**多阶段决策最优解模型**，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。

多阶段决策最优解模型：解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态，然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，经过一组决策序列，能够产生最终期望求解的最优值。


- 回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了
  
  - 尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。
  - 所有贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化而已。回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题,即消除重叠子问题的重复计算。
  
  - 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。
  - 其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。

## 学习参考

- [动态规划解题套路框架](https://labuladong.gitee.io/algo/3/25/69/)
- 极客《数据结构与算法之美》