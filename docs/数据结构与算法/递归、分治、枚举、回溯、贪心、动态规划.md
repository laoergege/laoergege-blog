---
release: true
tags:
  - 递归
  - 分治
  - 回溯
  - 贪心
  - 动态规划
---








- 题目
  - 数组
    - 实现两个有序数组合并为一个有序数组
  - 链表
    - 单链表反转
    - 两个有序的链表合并为一个有序链表
    - 求链表的中间结点
    - 合并 k 个排序链表
    - 环形链表
    - 实现单链表、循环链表、双向链表，支持增删操作
  - 栈、队列
  - 散列表
    - 三数之和、两数之和
  - 分治
    - 二维平面上有 n 个点，如何快速计算出两个距离最近的点对
    - `有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？`
    - 利用分治算法求一组数据的逆序对个数
    - powx-n
  - 回溯
    - 八皇后
    - 子集（不选空的组合）
      - https://leetcode.cn/problems/subsets/
    - 组合
    - 排列
    - 0-1 背包
  - 动规
    - 0-1 背包问题：对于一组**不同重量**、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？
    - 背包问题 2：对于一组**不同重量、不同价值**、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？
    - 路径计数/最小路径和
    - 最长公共子序列
    - 最长回文子串
    - 编程实现莱文斯坦最短编辑距离
    - 斐波那契数列
    - 爬楼梯
    - 买卖股票的最佳时机
    - 乘积最大子序列
    - 三角形最小路径和
    - 零钱兑换/找硬币
    - 最长递增子序列
    - 打家劫舍
  


     
- 动态规划，多阶段决策最优解模型：解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态，然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，经过一组决策序列，能够产生最终期望求解的最优值。
  - 特征
    - 在穷举的过程中（比如通过递归），存在重复计算的现象；（可能会产生重复的状态）
    - **最优子结构：**
      - 子问题之间必须相互独立，或者说后续的计算可以通过前面的状态推导出来
      - 符合最优子结构：可以从子问题的最优结果推出更大规模问题的最优结果

- 那分治、贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型
  - 回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了
  - 尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。
  - 所有贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化而已。回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题,即消除重叠子问题的重复计算。
    - 裁剪、合并
  - 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。
  - 其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。
- 重叠子问题、最优子结构、状态转移方程
- 状态转移方程
  - 递推公式


In a word, 分治法 —— 各子问题独立；动态规划 —— 各子问题重叠。

  
# 递归、分治、枚举、回溯、贪心、动态规划

## 递归

递归是一种应用非常广泛的算法思维或者编程技巧。

从计算机角度来看：**递归本质就是循环**，通过函数体，自己调自己来进行的循环。递归需要存在**递归终止条件**，不然会造成堆栈溢出。所以写递归关键：
- 寻找重复问题
- 终止条件

从问题模型思考角度来看：递归可以用于**一种自顶向下分层分解成相似子问题（数据规模不一样）的求解模型**，去的过程叫“递”，回来的过程叫“归”。

递归模板：

```js
function recursion(level) {
  // 1. 终止条件
  // 2. 递归缓存返回（可选）
  // 3. 逻辑处理
  // 4. 递归调用
  // 5. 状态重置（可选）
}
```

题目 [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)，树的结构定义本身就符合“分层分解相似子问题的模型”，所以树的问题一般都采用递归的形式。

![图 1](./images/1658252978768.png)  

相比较于常规循环，**递归写出来的代码更加简洁抽象**，符合人类对问题思考。但当看到递归时，我们要**避免不自觉得剖析递归过程**：把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。因此，**求解时只需要关注重复的问题本身以及如何把原问题与子问题递归关系，而不需要过分关注这个子问题是如何被解决的**。

回到翻转二叉树的题目，专注于单一节点（问题）进行解决思考，就是把当前节点的左右子节点对调，然后再分别对子树递归。

```js
var invertTree = function (root) {
    if (!root) {
        return null
    }

    [root.right, root.left] = [invertTree(root.left), invertTree(root.right)]

    return root
};
```

## 分治

分治算法（divide and conquer）的核心思想其实就是四个字，**分而治之** ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

大概的流程可以分为三步：分解 -> 解决 -> 合并：

1. 分解：将原问题分解成一系列子问题；
2. 解决：递归地求解各个子问题，若子问题足够小，则直接求解，无需再分；
3. 合并：将子问题的结果合并成原问题（合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了）。

![图 3](./images/1658343893199.png)  

从分治模型上看，分治算法适合用递归来实现。

> 分治算法是一种处理问题的思想，递归是一种编程技巧。

分治子问题特征：
- 原问题与分解成的小问题具有相同的模式；
- 该问题具有**最优子结构性质**，利用该问题分解出的子问题的解可以合并为该问题的解。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题（**没有重叠子问题，这一点是分治算法跟动态规划的明显区别**）

## 枚举、回溯、贪心、动态规划

题目[《零钱兑换》](https://leetcode.cn/problems/coin-change/)。

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。  
计算并返回可以凑成总金额所需的**最少**的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

### 枚举

面对最值问题（求最大、最小、最优之类）的求解，本质上还是需要进行穷举，即**枚举所有的可能，从所有候选答案中去搜索正确的解**（枚举思想）。

如何穷举？除非条件真的客观存在只能一一枚举，否则我们应该持有一种机器思维，寻找重复关系然后用循环、递归的方式去完成。

针对上面题目，我们需要从 `[1, 2, 5]` 中组合出不同复合

### 回溯

回溯算法的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们采用**试错的思想**，把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，选择另选一种走法继续走。

![图 1](./images/1660577073814.png)  

回溯算法非常适合用递归代码实现，而且递归这种形式，正是赋予了回溯这种可以回退一步的能力：它通过堆栈保存了上一步的当前状态。

- 重叠子问题
  - 备忘录/记忆化搜索
  - 剪枝优化
    - 利用预设条件减少搜索路径，优化最优组合搜索方案
      - 贪心策略
    - 重叠子问题：备忘录

### 动态规划

含有备忘录的递归算法已经与动态规划从效率上说基本相差无几，即都是消除重叠子问题的重复计算。那什么是动态规划？

带备忘录的递归解法使用的是自顶向下的处理方式来解题，它离我们日常看到的动态规划还有差距。可以说：

- 回溯 + 备忘录：递归方式（自顶向下处理模型）
- 动态规划：递推方式（自底向上处理模型）

动态规划问题解题的关键是找出“状态转移方程”，而使用前提是问题要符合动态规划的特征：

1. 最优子结构：通过子问题的最优解，能够推导出问题的最优解
2. 重叠子问题：即存在重复问题
3. 无后效性：子问题之间的依赖是单向性的，某阶段状态一旦确定，就不受后续决策的影响。前面阶段状态一旦确定，就不受之后阶段的决策影响（只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性）

解题思路
  - 状态转移表法：回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码
  - 状态转移方程法：状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。
    - 找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码
      - 递归 + “备忘录”
      - 迭代递推 + dp table


使用数学归纳法推导**递推公式**


- 动态规划问题特征
  - 最优子结构
    - 因为动态规划问题拥有 最优子结构，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。
    - 最优子结构 => 递推方程（dp，状态转移方程）
  - 重叠子问题
  - 无后效性
- 问题模型：多阶段决策最优解模型
- 解题关键：状态转移方程
  - 递归
  - 递推
- 狮子
  - 确定「状态」，也就是原问题和子问题中会变化的变量
  - 确定「选择」，也就是导致「状态」产生变化的行为

```py
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```




题目：[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

生成 n 对有效括号（阶段），即为 2\*n 个占位需要写入左括号或者右括号（这就是一个重复操作问题）

```javascript
var generateParenthesis = function (n) {
  const res = [];
  dfs((str = ""), n, n, res);
  return res;
};

// 生成左括号或者右括号
var dfs = function (str, left, right, res) {
  // 左边括号数等于右边括号数
  if (left === 0 && right === 0) {
    res.push(str);
    return;
  }
  // 生成左括号或者右括号
  if (left !== 0) {
    dfs(str + "(", left - 1, right, res);
  }

  // 生成右括号
  // 右括号大于左括号
  if (right !== 0 && right > left) {
    dfs(str + ")", left, right - 1, res);
  }
};
```









动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。
动态规划方法要寻找符合“最优子结构“的状态和状态转移方程的定义，在找到之后，这个问题就可以以“记忆化地求解递推式”的方法来解决。而寻找到的定义，才是动态规划的本质。


回溯法也可以说是树形图法，解题的时候使用类似于树状图的结构，使用 自顶而下 的方法。

## 学习参考

- [动态规划解题套路框架](https://labuladong.gitee.io/algo/3/25/69/)
- 极客《数据结构与算法之美》