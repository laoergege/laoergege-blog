<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.5/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.5/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"paragraph","d":1,"p":{"lines":[1,2]},"v":"tags:"},{"t":"bullet_list","d":1,"p":{"lines":[2,5]},"v":"","c":[{"t":"list_item","d":2,"p":{"lines":[2,3]},"v":"递归"},{"t":"list_item","d":2,"p":{"lines":[3,4]},"v":"分治"},{"t":"list_item","d":2,"p":{"lines":[4,5]},"v":"回溯"}]},{"t":"heading","d":1,"p":{"lines":[6,7]},"v":"递归、分治、回溯","c":[{"t":"heading","d":2,"p":{"lines":[7,8]},"v":"递归","c":[{"t":"bullet_list","d":3,"p":{"lines":[9,13]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[9,10]},"v":"递归","c":[{"t":"list_item","d":6,"p":{"lines":[10,11]},"v":"递归思路"},{"t":"list_item","d":6,"p":{"lines":[11,12]},"v":"注意 堆栈溢出、重复计算"},{"t":"list_item","d":6,"p":{"lines":[12,13]},"v":"递归模板"}]}]},{"t":"heading","d":3,"p":{"lines":[13,14]},"v":"什么是递归"},{"t":"heading","d":3,"p":{"lines":[18,19]},"v":"如何使用递归编写代码？","c":[{"t":"ordered_list","d":4,"p":{"lines":[20,33],"start":1},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[20,21],"index":1},"v":"1. 抵制人肉递归、人肉枚举","c":[{"t":"paragraph","d":7,"p":{"lines":[21,22]},"v":"相比较"},{"t":"ordered_list","d":7,"p":{"lines":[22,24],"start":1},"v":"","c":[{"t":"list_item","d":8,"p":{"lines":[22,23],"index":1},"v":"1. 不要总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。你只需要思考大问题跟小问题之间的关系，屏蔽掉递归细节，这样子理解起来就简单多了。"},{"t":"list_item","d":8,"p":{"lines":[23,24],"index":2},"v":"2. 计算机擅长做重复的事情，递归本身也是循环重复。遇到问题时，切勿去人脑枚举多种情况，寻找最优解，人脑枚举想象是有限制的，一旦陷入穷举，就容易头脑空白，从而不知如何求解。"}]}]},{"t":"list_item","d":5,"p":{"lines":[24,25],"index":2},"v":"2. 分解 n 阶段问题求解、找最近重复性问题","c":[{"t":"paragraph","d":7,"p":{"lines":[25,26]},"v":"递归是一种编程技巧，使用递归解题时，首先找问题的重复性，找到了问题的最近重复性，才能把相似操作写在一起作为递归使用"}]},{"t":"list_item","d":5,"p":{"lines":[26,27],"index":3},"v":"3. 数学归纳法、递推公式","c":[{"t":"paragraph","d":7,"p":{"lines":[27,29]},"v":"递归是自顶向下的求解问题，从未知到已知。<br>\n递推是从初值出发反复进行某一运算得到所需结果，从已知到未知。"},{"t":"paragraph","d":7,"p":{"lines":[30,32]},"v":"递归是数学归纳法衍生出来的，利用递推的原理。当你无法通过自顶向下求解，可通过归纳法，寻找递推公式。<br>\n<a href=\"https://www.cnblogs.com/GODYCA/archive/2013/01/15/2861545.html\">《递归和数学归纳法》</a>"}]}]},{"t":"fence","d":4,"v":"<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">generateParenthesis</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>str <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword control-flow\">return</span> res\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 生成左括号或者右括号</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">dfs</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">str<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 左边括号数等于右边括号数</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> right <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">push</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword control-flow\">return</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 生成左括号或者右括号</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">!==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>str <span class=\"token operator\">+</span> <span class=\"token string\">'('</span><span class=\"token punctuation\">,</span> left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 生成右括号</span>\n    <span class=\"token comment\">// 右括号大于左括号</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">!==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> right <span class=\"token operator\">></span> left<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>str <span class=\"token operator\">+</span> <span class=\"token string\">')'</span><span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"t":"fence","d":4,"v":"<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">climbStairs</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword control-flow\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword control-flow\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword control-flow\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword control-flow\">return</span> <span class=\"token number\">2</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 缓存计算</span>\n    <span class=\"token keyword control-flow\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>climbStairs<span class=\"token punctuation\">.</span><span class=\"token property-access\">tmp</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        climbStairs<span class=\"token punctuation\">.</span><span class=\"token property-access\">tmp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword control-flow\">return</span> climbStairs<span class=\"token punctuation\">.</span><span class=\"token property-access\">tmp</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>climbStairs<span class=\"token punctuation\">.</span><span class=\"token property-access\">tmp</span><span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[90,91]},"v":"递归模板","c":[{"t":"fence","d":4,"v":"<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">level</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 终止条件</span>\n  <span class=\"token comment\">// 递归缓存返回（可选）</span>\n  <span class=\"token comment\">// 逻辑处理</span>\n  <span class=\"token comment\">// 递归调用</span>\n  <span class=\"token comment\">// 结果返回（可选）</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"t":"heading","d":4,"p":{"lines":[101,102]},"v":"深度优先","c":[{"t":"bullet_list","d":5,"p":{"lines":[104,107]},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[104,105]},"v":"代码好写，使用递归的方法，直接借助系统栈完成<strong>状态的转移</strong>；"},{"t":"list_item","d":6,"p":{"lines":[105,106]},"v":"广度优先遍历得自己编写结点类和借助队列。"}]},{"t":"fence","d":5,"v":"<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#Python</span>\n\n<span class=\"token comment\"># 缓存计算，防止重复计算</span>\nvisited <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n\n<span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> visited<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>    \n    <span class=\"token keyword\">if</span> node <span class=\"token keyword\">in</span> visited<span class=\"token punctuation\">:</span> <span class=\"token comment\"># terminator        </span>\n        <span class=\"token comment\"># already visited       </span>\n        <span class=\"token keyword\">return</span>  visited<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>   \n        \n    <span class=\"token comment\"># process current node here.    </span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> \n     \n    <span class=\"token keyword\">for</span> next_node <span class=\"token keyword\">in</span> node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>       \n        <span class=\"token keyword\">if</span> next_node <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> visited<span class=\"token punctuation\">:</span>            \n            dfs<span class=\"token punctuation\">(</span>next_node<span class=\"token punctuation\">,</span> visited<span class=\"token punctuation\">)</span>\n</code></pre>\n"},{"t":"fence","d":5,"v":"<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#Pythondef DFS(self, tree):     </span>\n    <span class=\"token keyword\">if</span> tree<span class=\"token punctuation\">.</span>root <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>       \n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>   \n\n    visited<span class=\"token punctuation\">,</span> stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>tree<span class=\"token punctuation\">.</span>root<span class=\"token punctuation\">]</span>    \n\n    <span class=\"token keyword\">while</span> stack<span class=\"token punctuation\">:</span>        \n        node <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>      \n        visited<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>       \n\n        process <span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>      \n        nodes <span class=\"token operator\">=</span> generate_related_nodes<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>        \n        stack<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">(</span>nodes<span class=\"token punctuation\">)</span>   \n    \n    <span class=\"token comment\"># other processing work     </span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n</code></pre>\n"}]},{"t":"heading","d":4,"p":{"lines":[146,147]},"v":"广度优先","c":[{"t":"fence","d":5,"v":"<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Python</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">BFS</span><span class=\"token punctuation\">(</span>graph<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 队列    </span>\n    queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>  \n    queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>   \n    \n    <span class=\"token keyword\">while</span> queue<span class=\"token punctuation\">:</span>        \n        node <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>      \n        process<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>       \n        \n        <span class=\"token comment\"># 将 children 排进下一队列中</span>\n        nodes <span class=\"token operator\">=</span> generate_related_nodes<span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>        \n        queue<span class=\"token punctuation\">.</span>push<span class=\"token punctuation\">(</span>nodes<span class=\"token punctuation\">)</span>   \n        \n        <span class=\"token comment\"># other processing work     ...</span>\n</code></pre>\n"}]}]}]},{"t":"heading","d":2,"p":{"lines":[166,167]},"v":"分治","c":[{"t":"paragraph","d":4,"p":{"lines":[172,173]},"v":"分治相比递归，就是多了不断重复分治合并的处理"}]},{"t":"heading","d":2,"p":{"lines":[175,176]},"v":"回溯","c":[{"t":"ordered_list","d":3,"p":{"lines":[186,189],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[186,187],"index":1},"v":"1. 最近重复性：涉及到各种办法"},{"t":"list_item","d":4,"p":{"lines":[187,188],"index":2},"v":"2. 最有重复性：即为动态规划"}]},{"t":"ordered_list","d":3,"p":{"lines":[192,199],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[192,193],"index":1},"v":"1. 找重复性"},{"t":"list_item","d":4,"p":{"lines":[193,194],"index":2},"v":"2. 分n阶段","c":[{"t":"list_item","d":6,"p":{"lines":[194,195],"index":1},"v":"1. 回溯"},{"t":"list_item","d":6,"p":{"lines":[195,196],"index":2},"v":"2. 最优解 动态规划"}]},{"t":"list_item","d":4,"p":{"lines":[196,197],"index":3},"v":"3. 分治问题、缩小数据规模、缩小问题"},{"t":"list_item","d":4,"p":{"lines":[197,198],"index":4},"v":"4. 归纳法、递推"}]}]},{"t":"heading","d":2,"p":{"lines":[201,202]},"v":"贪心算法","c":[{"t":"blockquote","d":3,"p":{"lines":[205,206]},"v":"","c":[{"t":"paragraph","d":4,"p":{"lines":[205,206]},"v":"局部最优、希望结果最优，说明贪心算法在日常生活和工程中一般不能得到我们想要的结果"}]},{"t":"bullet_list","d":3,"p":{"lines":[207,211]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[207,208]},"v":"回溯，能够回退"},{"t":"list_item","d":4,"p":{"lines":[208,209]},"v":"贪心算法，当下做局部最优判断，不能回退"},{"t":"list_item","d":4,"p":{"lines":[209,210]},"v":"动态规划，根据以前结果做选择 + 回退"}]}]},{"t":"heading","d":2,"p":{"lines":[215,216]},"v":"分治算法","c":[{"t":"paragraph","d":4,"p":{"lines":[219,220]},"v":"这和递归的概念很吻合，所以在分治算法通常以递归的方式实现(当然也有非递归的实现方式)。"}]},{"t":"heading","d":2,"p":{"lines":[226,227]},"v":"动态规划","c":[{"t":"bullet_list","d":3,"p":{"lines":[239,242]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[239,240]},"v":"独立"},{"t":"list_item","d":4,"p":{"lines":[240,241]},"v":"最优"}]},{"t":"bullet_list","d":3,"p":{"lines":[246,250]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[246,247]},"v":"最优子结构"},{"t":"list_item","d":4,"p":{"lines":[247,248]},"v":"中间状态（dp table）"},{"t":"list_item","d":4,"p":{"lines":[248,249]},"v":"递推方程（dp，状态转移方程）"}]},{"t":"ordered_list","d":3,"p":{"lines":[254,266],"start":1},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[254,255],"index":1},"v":"1. 计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举"},{"t":"list_item","d":4,"p":{"lines":[255,256],"index":2},"v":"2. 但抵制人肉枚举、人肉递归"},{"t":"list_item","d":4,"p":{"lines":[256,257],"index":3},"v":"3. 找最近重复性","c":[{"t":"list_item","d":6,"p":{"lines":[257,258],"index":1},"v":"1. 枚举：选择组合"},{"t":"list_item","d":6,"p":{"lines":[258,259],"index":2},"v":"2. 从问题分解相似子问题角度"}]},{"t":"list_item","d":4,"p":{"lines":[259,260],"index":4},"v":"4. 数学归纳法（找递推公式，又称 状态转移方程、DP 方程）","c":[{"t":"list_item","d":6,"p":{"lines":[260,261],"index":1},"v":"1. 自顶向下（递归 + 记忆化搜索）"},{"t":"list_item","d":6,"p":{"lines":[261,262],"index":2},"v":"2. 自底向上 循环","c":[{"t":"list_item","d":8,"p":{"lines":[262,263],"index":1},"v":"1. 最优子结构"},{"t":"list_item","d":8,"p":{"lines":[263,264],"index":2},"v":"2. 中间状态（子问题的值）"},{"t":"list_item","d":8,"p":{"lines":[264,265],"index":3},"v":"3. 递推方程"}]}]}]}]}]}],"p":{}})</script>
</body>
</html>
