# 数据结构与算法

- 数据结构与算法
  - 复杂度
    - 时间复杂度
    - 空间复杂度
  - 数据结构
    - [数组、链表](./底层存储结构：数组、链表.md)
      > 数据结构种类很多，底层实现无非数组或者链表，但它们存在的目的都是在不同的应用场景合理组织数据，尽可能高效地增删查改，也就是更好的时间换空间策略
      1.  数组
          > 由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。
      2.  链表
          > 因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。 
      > 数据查找：遍历 + 索引；  
      > 遍历：线性就是 for/while 迭代为代表，非线性就是递归为代表
    - 栈、队列、优先队列
    - 哈希表
    - [树、二叉树、二叉搜索树](./树和二叉树、堆和二叉堆.md)
    - 堆和二叉树、图
  - 算法
    - [排序算法](./排序算法.md)
    - 搜索算法
      - 二分查找（分治）
    - 动态规划
  - 问题分类
    - 区间
      - 重叠判断
      - 区间合并

## 解题方法

1. 暴力解法
2. 时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。
3. 升维，比如数组操作 O(n), 二叉树操作 logN
4. 分治

## 复杂度

复杂度是一个关于输入数据量 n 的函数，用 O(n) 表示。

通常，复杂度的计算方法遵循以下几个原则：

1. 复杂度与具体的常系数无关
2. 多项式级的复杂度相加的时候，选择高者作为结果
3. O(1) 也是表示一个特殊复杂度，表示与输入数据量 n 无关

## 问题分类

### Top K 问题

### 区间

`[[2,6], [1,3],[8,10],[15,18]]`

#### 区间重叠判断

```txt
a = 区间1
b = 区间2

b[0] > a[1] 没有重叠
```

#### 区间合并

[leetcode 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

1. 按区间的开始进行递增排序，保证合并区间的开始为最小
2. 区间重叠判断，否放入结果集
3. 是则区间合并，选择最大的结束点为合并区间的结点



## 二分查找

前提

- 单调性（递增、递减)
- 存在上下边界
- 索引查找（最好是数组索引，操作起来方便）

数据单调性是**二分查找从中间位置往左往右的判断依据**，但不一定，有些题目，如果能根据条件得到判断条件还是可以使用二分法
[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

代码模板

```txt
left, right = 0, len(array) - 1
while left <= right # 可能没有等于，不需要 if array[mid] == target 时就不要等于
  mid = (left + right) / 2
  if array[mid] == target:
    # break or return
  # 大于等于、加一减一的边界，如果数据已经判断使用过了就不需要等于
  elif array[mid] < target:
    left = mid + 1
  else
    right = mid - 1
```