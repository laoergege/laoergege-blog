---
tags:
 - 数据结构
 - 算法
---

# 数据结构与算法

- 数据结构与算法
  - 数据结构
    - [底层存储结构：数组、链表](./底层存储结构：数组、链表.md)
    - 散列表/哈希表
      - 原理：数组（利用数组支持按照下标随机访问数据的特性） + hash 函数 
        - Array[index = hash(key)]  ![图 4](./images/1647795833834.png)  
      - 散列冲突/哈希碰撞
        - 开放寻址法：发生散列冲突，我们就重新探测一个空闲位置，将其插入（不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高）
          - [线性探测](#线性探测)
          - 二次探测
          - 双重散列
        - 链表法（最坏情况：插入、删除、查询都是 O(n)）  ![图 5](./images/1650352201666.png) 
    - 栈、队列、优先队列
      - 栈：先进后出
        - 用数组实现的栈，我们叫作**顺序栈**
        - 用链表实现的栈，我们叫作**链式栈**
      - 队列：先进先出
        - 用数组实现的队列叫作**顺序队列**
        - 用链表实现的队列叫作**链式队列**
        - **循环队列**
      - 优先队列：实现资源**排队等待**以及**优先关系**
        - 优先队列可以使用数组、链表、堆数据结构或二叉搜索树来实现 
    - [树和二叉树、二叉堆](./树和二叉树、二叉堆.md)
      - 堆是一种特殊的基于树的数据结构，主要有二叉堆
      - 树
        - 前序遍历
        - 中序遍历
        - 后序遍历
    - 图
  - 复杂度
    - 时间复杂度
      - 递归算法的时间复杂度计算：就是用子问题个数乘以解决一个子问题需要的时间
    - 空间复杂度
  - 算法
    - [排序算法](./排序算法.md)
      - 快排
      - 归并排序
        - 归并算法：交替合并有序序列
      - 堆排序
    - 查找：遍历 or 索引
      - 散列表：索引
      - 线性表：以迭代为代表
        - 优化
          - 记忆化搜索：**散列表**
          - 结构升维：多维数据结构比如 跳表，或者像树形结构，如二叉搜索树（logN）
          - 滑动窗口/双指针：压缩遍历，同一层循环中同时查找多个数
            - 需要确定多指针间的关系，从问题发现规律
            - 常见模式
              - 基于排序大小：夹包或者扩撒
              - 基于序号：快慢指针
          - [二分查找（分治）](./二分查找.md)
      - 非线性表：以递归为代表
        - 递归
          - 递归模板
            ```js
            function recursion(level) {
              // 1. 终止条件
              // 2. 递归缓存返回（可选）
              // 3. 逻辑处理
              // 4. 递归调用
              // 5. 状态重置（可选）
            }
            ```
          - 堆栈溢出
          - 递归转循环（模拟栈）
    - 搜索算法：尝试问题中所有的可能性，在所有的可能性中找到正确的结果
      - 深度优先搜索
      - 广度优先搜素
      - A*启发式搜索
    - [算法思想：递归、分治、枚举、回溯、贪心、动态规划](./递归、分治、枚举、回溯、贪心、动态规划.md)
    - 字符串匹配
    - 缓存算法
      - LRU，最近最少使用（淘汰旧数据）
      - LFU，最不经常使用（淘汰频率次数最少的数据）
    - 其他
      - 位运算
      - 布隆过滤器
  - 经典工程问题
    - 海量数据排序问题：处理的数据量非常大，没法一次性放到内存中进行排序
      - 分治的思想：将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合
      - 多路归并排序
    - 最值问题
      - 多轮决策模型
      - 组合排序模型
      - 枚举搜索
    - 字符串匹配
    - 区间
      - 重叠判断
      - 区间合并
    - 子序
      - 子序列，不是子串
    - 枚举类
      - 多少
      - 最优解

1. 算法题技巧较多，难以整活儿，这也是为什么我说一开始刷算法题不要死磕，因为技巧储备还不够

## 复杂度

复杂度是一个关于输入数据量 n 的函数，用 O(n) 表示。

通常，复杂度的计算方法遵循以下几个原则：

1. 复杂度与具体的常系数无关
2. 多项式级的复杂度相加的时候，选择高者作为结果
3. O(1) 也是表示一个特殊复杂度，表示与输入数据量 n 无关


用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值

## 线性探测

![图 6](./images/1650352728220.png)  

将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测，直到空才停止查找。

![图 7](./images/1650352748489.png)  


## 问题分类

### 区间

`[[2,6], [1,3],[8,10],[15,18]]`

#### 区间重叠判断

```
a = 区间1
b = 区间2

b[0] > a[1] 没有重叠
```

#### 区间合并

[leetcode 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

1. 按区间的开始进行递增排序，保证合并区间的开始为最小
2. 区间重叠判断，否放入结果集
3. 是则区间合并，选择最大的结束点为合并区间的结点


#### 广度优先

```python
# Python

def BFS(graph, start, end):
    # 队列   
    queue = [] 
    queue.append([start]) 

    while queue: 
        node = queue.pop() 
        process(node) 

        # 将 children 排进下一队列中
        nodes = generate_related_nodes(node) 
        queue.push(nodes)

        # other processing work 	...
```


#### 深度优先

一般用深度优先遍历：

- 代码好写，使用递归的方法，直接借助系统栈完成**状态的转移**；
- 广度优先遍历得自己编写结点类和借助队列。

```python
#Python

# 缓存计算，防止重复计算
visited = set() 

def dfs(node, visited):
    if node in visited: # terminator
        # already visited 
        return 	visited.add(node) 

    # process current node here. 
    ...

    for next_node in node.children(): 
        if next_node not in visited: 
            dfs(next_node, visited)
```

非递归写法，模拟栈调用

```python
#Pythondef DFS(self, tree): 
    if tree.root is None: 
        return [] 

    visited, stack = [], [tree.root]

    while stack: 
        node = stack.pop() 
        visited.add(node)

        process (node) 
        nodes = generate_related_nodes(node) 
        stack.push(nodes) 

    # other processing work 
    ...
```


## 题目

- 数组
  - 实现两个有序数组合并为一个有序数组
- 链表
  - 单链表反转
  - 两个有序的链表合并为一个有序链表
  - 求链表的中间结点
  - 合并 k 个排序链表
  - 环形链表
  - 实现单链表、循环链表、双向链表，支持增删操作
- 栈、队列
- 散列表
  - 三数之和、两数之和
- 分治
  - 二维平面上有 n 个点，如何快速计算出两个距离最近的点对
  - `有两个 n*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A*B？`
  - 利用分治算法求一组数据的逆序对个数
  - powx-n
- 回溯
  - 八皇后
  - 子集（不选空的组合）
    - https://leetcode.cn/problems/subsets/
  - 组合
  - 排列
  - 0-1 背包
  - 括号生成
- 动规
  - 0-1 背包问题：对于一组**不同重量**、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？
  - 背包问题 2：对于一组**不同重量、不同价值**、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？
  - 路径计数/最小路径和
  - 最长公共子序列
  - 最长回文子串
  - 编程实现莱文斯坦最短编辑距离
  - 爬楼梯
  - 买卖股票的最佳时机
  - 乘积最大子序列
  - 三角形最小路径和
  - 零钱兑换/找硬币
  - 最长递增子序列
  - 打家劫舍