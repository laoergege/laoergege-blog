---
tags:
 - 数据结构
 - 算法
---

# 数据结构与算法

- 数据结构与算法
  - 复杂度
    - 时间复杂度
    - 空间复杂度
  - 数据结构
    - [数组、链表](./底层存储结构：数组、链表.md)
    - 散列表/哈希表
      - 原理：数组（利用数组支持按照下标随机访问数据的特性） + hash 函数 
        - Array[index = hash(key)]  ![图 4](./images/1647795833834.png)  
      - 散列冲突/哈希碰撞
        - 开放寻址法：发生散列冲突，我们就重新探测一个空闲位置，将其插入（不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高）
          - [线性探测](#线性探测)
          - 二次探测
          - 双重散列
        - 链表法（最坏情况：插入、删除、查询都是 O(n)）  ![图 5](./images/1650352201666.png) 
    - 栈、队列、优先队列
      - 栈：先进后出
      - 队列：先进先出
        - 循环队列
      - 优先队列：实现资源**排队等待**以及**优先关系**
        - 优先队列可以使用数组、链表、堆数据结构或二叉搜索树来实现 
    - [树和二叉树、二叉堆](./树和二叉树、二叉堆.md)
      - 堆是一种特殊的基于树的数据结构，主要有二叉堆
    - 图
  - 算法
    - [排序算法](./排序算法.md)
      - 快排
      - 归并排序
        - 归并算法：交替合并有序序列
      - 堆排序
    - 查找算法
      - 散列表：索引
      - 线性表：循环迭代
        - 优化
          - 搜索记忆：**散列表**
          - 结构升维：多维数据结构比如 跳表，或者像树形结构，如二叉搜索树（logN）
          - 滑动窗口/双指针：压缩遍历，同一层循环中同时查找多个数
            - 需要确定多指针间的关系，从问题发现规律
            - 常见模式
              - 基于排序大小：夹包或者扩撒
              - 基于序号：快慢指针
          - [二分查找（分治）](./二分查找.md)
      - 非线性表：递归
        - 树
          - 前序遍历
          - 中序遍历
          - 后序遍历
    - 搜索算法
      - 深度优先搜索
      - 广度优先搜素
      - 启发式搜索
    - 算法思想：[递归、分治、枚举、回溯、贪心、动态规划](./%E9%80%92%E5%BD%92%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E5%9B%9E%E6%BA%AF%E3%80%81%E8%B4%AA%E5%BF%83%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md)
    - 字符串匹配
    - 缓存算法
      - LRU，最近最少使用（淘汰旧数据）
      - LFU，最不经常使用（淘汰频率次数最少的数据）
    - 其他
      - 位运算
      - 布隆过滤器
  - 经典工程问题
    - 超大量数据排序问题：处理的数据量非常大，没法一次性放到内存中进行排序
      - 利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合
      - 多路归并排序
    - 最值问题
      - 枚举搜索
      - 
    - 分治算法如何降低时间复杂度、理解及应用
    - 字符串
    - 区间
      - 重叠判断
      - 区间合并
    - 子序
      - 子序列，不是子串
    - 枚举类
      - 多少
      - 最优解

1. 算法题技巧较多，难以整活儿，这也是为什么我说一开始刷算法题不要死磕，因为技巧储备还不够

## 复杂度

复杂度是一个关于输入数据量 n 的函数，用 O(n) 表示。

通常，复杂度的计算方法遵循以下几个原则：

1. 复杂度与具体的常系数无关
2. 多项式级的复杂度相加的时候，选择高者作为结果
3. O(1) 也是表示一个特殊复杂度，表示与输入数据量 n 无关


用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值

## 线性探测

![图 6](./images/1650352728220.png)  

将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测，直到空才停止查找。

![图 7](./images/1650352748489.png)  


## 问题分类

### 区间

`[[2,6], [1,3],[8,10],[15,18]]`

#### 区间重叠判断

```
a = 区间1
b = 区间2

b[0] > a[1] 没有重叠
```

#### 区间合并

[leetcode 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

1. 按区间的开始进行递增排序，保证合并区间的开始为最小
2. 区间重叠判断，否放入结果集
3. 是则区间合并，选择最大的结束点为合并区间的结点


#### 广度优先

```python
# Python

def BFS(graph, start, end):
    # 队列   
    queue = [] 
    queue.append([start]) 

    while queue: 
        node = queue.pop() 
        process(node) 

        # 将 children 排进下一队列中
        nodes = generate_related_nodes(node) 
        queue.push(nodes)

        # other processing work 	...
```


#### 深度优先

一般用深度优先遍历：

- 代码好写，使用递归的方法，直接借助系统栈完成**状态的转移**；
- 广度优先遍历得自己编写结点类和借助队列。

```python
#Python

# 缓存计算，防止重复计算
visited = set() 

def dfs(node, visited):
    if node in visited: # terminator
        # already visited 
        return 	visited.add(node) 

    # process current node here. 
    ...

    for next_node in node.children(): 
        if next_node not in visited: 
            dfs(next_node, visited)
```

非递归写法，模拟栈调用

```python
#Pythondef DFS(self, tree): 
    if tree.root is None: 
        return [] 

    visited, stack = [], [tree.root]

    while stack: 
        node = stack.pop() 
        visited.add(node)

        process (node) 
        nodes = generate_related_nodes(node) 
        stack.push(nodes) 

    # other processing work 
    ...
```
