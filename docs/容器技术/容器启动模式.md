---
tags:
 - 容器
---

# 容器启动模式及 attach 与 exec 区别

## 容器启动模式

在制作镜像时，Dockerfile 必须至少指定 CMD 或 ENTRYPOINT 其中的一个来启动默认程序，通常我们会有以下三种程序运行模型：

- 默认模式：直接运行一个可执行程序，输出结果即完
- 交互模式：前台启动一个可持续交互运行的程序
- 后台模式：启动一个后台持续运行的程序

### 默认模式

```shell
$ podman run --rm ubuntu pwd
/
```

执行完 pwd 命令后容器就结束退出，然后在 `--rm` 效果下自动删除容器：

```shell
$ podman ps -a              
CONTAINER ID  IMAGE       COMMAND     CREATED     STATUS      PORTS       NAMES

```

### 交互模式

`-a|--attach`：即将终端连接上容器的标准流（STDIN, STDOUT和STDERR），这意味着我们可以通过终端输入输出与进程交互。如果没有指定 `-a` 选项，默认会 attach stdout 和 stderr。上面的命令效果相当于下面：

```shell
$ podman run --rm -a stdout -a stderr ubuntu pwd
/
```

但是当我们执行以下命令开启与 bash 交互，却发现容器给停止了。

> ubunut 镜像默认启动程序 Bash

```shell
$ podman run --rm -a stdin -a stdout ubuntu
```

尽管我们 attach 容器的 stdin，**但容器的输入流实际上是关闭的**：

先通过 sleep 启动阻塞程序，

```shell
$ podman run --rm -a stdin -a stdout ubuntu sleep 30000
```

再通过另一个终端查看详情：

```shell
[core@localhost ~]$ lsns
        NS TYPE   NPROCS   PID USER COMMAND
4026531834 time       13  1460 core /usr/lib/systemd/systemd --user
4026531835 cgroup     12  1460 core /usr/lib/systemd/systemd --user
4026531836 pid       129  1460 core /usr/lib/systemd/systemd --user
4026531837 user        7  1460 core /usr/lib/systemd/systemd --user
4026531838 uts        12  1460 core /usr/lib/systemd/systemd --user
4026531839 ipc        12  1460 core /usr/lib/systemd/systemd --user
4026531840 net        12  1460 core /usr/lib/systemd/systemd --user
4026531841 mnt         7  1460 core /usr/lib/systemd/systemd --user
4026532285 user      123  1649 core catatonit -P
4026532351 mnt         4  1649 core catatonit -P
4026532422 net         1 25717 core sleep 30000
4026532545 mnt         1 25717 core sleep 30000
4026532546 mnt         1 25679 core /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp --enable-ipv6 -c -r 3 --netns-t
4026532550 uts         1 25717 core sleep 30000
4026532551 ipc         1 25717 core sleep 30000
4026532552 pid         1 25717 core sleep 30000
4026532553 cgroup      1 25717 core sleep 30000
```

进程 25717 即我们刚刚启动的容器。

```shell
[core@localhost ~]$ lsof -p 25717
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME
sleep   25717 core  cwd    DIR   0,49       28  41943573 /
sleep   25717 core  rtd    DIR   0,49       28  41943573 /
sleep   25717 core  txt    REG   0,49    35000 134218012 /bin/sleep
sleep   25717 core  mem    REG  252,4          134218012 /bin/sleep (path dev=0,46, inode=2885535)
sleep   25717 core  mem    REG  252,4          202375315 /lib/x86_64-linux-gnu/libc-2.27.so (stat: No such file or directory)
sleep   25717 core  mem    REG  252,4          202375297 /lib/x86_64-linux-gnu/ld-2.27.so (stat: No such file or directory)
sleep   25717 core    0u   CHR    1,3      0t0         4 /dev/null
sleep   25717 core    1w  FIFO   0,13      0t0   2328957 pipe
sleep   25717 core    2w  FIFO   0,13      0t0   2328958 pipe
```

其中 `sleep   25717 core    0u   CHR    1,3      0t0         4 /dev/null` 的 `0u` 即是容器的输入流，发现是字符设备 `/dev/null`。

> Linux 中的 `/dev/null` 是一个空设备文件。这将丢弃任何写入它的内容，并在读取时返回 EOF。

#### interactive 选项

`-i|--interactive`：让容器的标准输入保持打开状态，即使容器的标准输入，输出和错误流没有被附加。

附带 `-i` 时 `-a stdin` 相当默认带上。重复上面实验操作：

```shell
[core@localhost ~]$ podman run --rm -i ubuntus
```

```shell
[core@localhost ~]$ lsns
        NS TYPE   NPROCS   PID USER COMMAND
4026531834 time       13  1460 core /usr/lib/systemd/systemd --user
4026531835 cgroup     12  1460 core /usr/lib/systemd/systemd --user
4026531836 pid       129  1460 core /usr/lib/systemd/systemd --user
4026531837 user        7  1460 core /usr/lib/systemd/systemd --user
4026531838 uts        12  1460 core /usr/lib/systemd/systemd --user
4026531839 ipc        12  1460 core /usr/lib/systemd/systemd --user
4026531840 net        12  1460 core /usr/lib/systemd/systemd --user
4026531841 mnt         7  1460 core /usr/lib/systemd/systemd --user
4026532285 user      123  1649 core catatonit -P
4026532351 mnt         4  1649 core catatonit -P
4026532422 net         1 25827 core bash
4026532545 mnt         1 25827 core bash
4026532546 mnt         1 25791 core /usr/bin/slirp4netns --disable-host-loopback --mtu=65520 --enable-sandbox --enable-seccomp --enable-ipv6 -c -r 3 --netns-t
4026532550 uts         1 25827 core bash
4026532551 ipc         1 25827 core bash
4026532552 pid         1 25827 core bash
4026532553 cgroup      1 25827 core bash
```

```shell
[core@localhost ~]$ lsof -p 25827
COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME
bash    25827 core  cwd    DIR   0,49       28  57671966 /
bash    25827 core  rtd    DIR   0,49       28  57671966 /
bash    25827 core  txt    REG   0,49  1113504 134217858 /bin/bash
bash    25827 core  mem    REG  252,4          134217858 /bin/bash (path dev=0,46, inode=2117823)
bash    25827 core  mem    REG  252,4          202375451 /lib/x86_64-linux-gnu/libnss_files-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375445 /lib/x86_64-linux-gnu/libnsl-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375455 /lib/x86_64-linux-gnu/libnss_nis-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375447 /lib/x86_64-linux-gnu/libnss_compat-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375315 /lib/x86_64-linux-gnu/libc-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375355 /lib/x86_64-linux-gnu/libdl-2.27.so (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375489 /lib/x86_64-linux-gnu/libtinfo.so.5.9 (stat: No such file or directory)
bash    25827 core  mem    REG  252,4          202375297 /lib/x86_64-linux-gnu/ld-2.27.so (stat: No such file or directory)
bash    25827 core    0r  FIFO   0,13      0t0   2329821 pipe
bash    25827 core    1w  FIFO   0,13      0t0   2329822 pipe
bash    25827 core    2w  FIFO   0,13      0t0   2329823 pipe
```

这次发现输入流是一个命名管道，终端与容器之间的交互是通过管道文件！实际上除了通过管道文件进行交互，还能通过 TTY 设备文件。

#### tty 选项

> 了解更多 [TTY](../操作系统/TTY.md)

Linux 的中 TTY 是一个软件仿真终端的概念，当我们打开一个终端软件如 zsh，在“一切皆文件”的 Linux 中有着对应的设备文件，输入 `tty` 可查到对应的设备文件：

```shell
$ tty
/dev/ttys003

```

为此，我们只需要把容器的标准流绑定到 TTY 上，对着 TTY 设备文件读写即可与用户终端进行交互。当用户在控制台中启动普通程序时，通常其 stdin、stdout 和 stderr 流将连接到会话的控制终端：

```shell
$ tty
/dev/ttys003

$ cat            

```

然后在打开另一个终端，查找 cat 进程相关信息

```shell
$ tty
/dev/ttys004
$ lsof -p 18825     
...
cat     18825 lianyuansheng    0u   CHR   16,3    0t373                1525 /dev/ttys003
cat     18825 lianyuansheng    1u   CHR   16,3    0t373                1525 /dev/ttys003
cat     18825 lianyuansheng    2u   CHR   16,3    0t373                1525 /dev/ttys003
...
```

可以看出 cat 子进程的标准流自动绑定到 ttys003 上。但进程的控制终端不一定与它的流所连接的终端相同。您可以使用以下ps命令查看这些内容：

```shell
$ sudo ps -ax -o pid,tty
  PID TTY
    1 ??
   50 ttys003
   51 ??
```

- TTY 列表示进程的控制终端
- ?? 意味着守护进程

回到容器的启动选项：

`-t｜--tty`：为容器分配一个伪 TTY 终端并绑定到容器的标准输上。伪终端 PTY（pseudo TTY）是运行在用户态，通过打开特殊的设备文件 /dev/ptmx 创建，由一对双向的字符设备构成，称为 PTY master 和 PTY slave。

```shell
[core@localhost ~]$ podman run --rm -t -a stdout -a stdin ubuntu
root@f1dc70c90896:/# pwd
/
root@f1dc70c90896:/# 
```

启动另一个终端查看进程绑定到了 PTY slave：

```shell
[core@localhost ~]$ lsof -p 28257
...
bash    28257 core    0u   CHR  136,0      0t0         3 /dev/pts/0
bash    28257 core    1u   CHR  136,0      0t0         3 /dev/pts/0
bash    28257 core    2u   CHR  136,0      0t0         3 /dev/pts/0
...
```

#### `-i` 、`-t` 区别以及 `-it`

与容器交互

TTY 会处理特殊键，发送进程信号
当用户按 CTRL+c 时，它向连接到 PTY slave 的进程发送 kill -2（SIGINT） 信号
当用户按 CTRL+z 时，它向连接到 PTY slave 的进程发送 kill -STOP信号

### 后台模式

守护进程与会话的控制终端分离