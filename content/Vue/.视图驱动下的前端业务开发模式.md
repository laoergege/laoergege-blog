---
discussionID: 6NMtpBiYy1pyEAOlJ7YFw
---
# 现代化前端框架下的业务开发思考

- 前后分离：RestFul 架构
- 视图驱动、组件优先
  - 组件
    - 组件 = UI + 逻辑
      - 逻辑复用及耦合问题
      - 复用
        - UI
          - 模板
          - 原子 css

## RestFul 架构

什么是 RestFul？RestFul 是 3 个单词的合并缩写：

- Re（Representational）：前端（浏览器、应用等）没有业务状态，却又要展示内容，因此前端拥有的是状态的表示，也就是 Representation
- st（State）：在 RestFul 架构中，状态仅仅存在于服务端，前端无状态。状态（State）可以理解为业务的状态，这个状态是由服务端管理的
- Ful（Transfer）：即改变状态。

Restful 讲的是一套前端无状态、服务端管理状态，中间设计转化途径（请求、函数等）的架构方法。这个方法可以让前后端职责清晰，前端负责渲染， 服务端负责业务。前端不需要业务状态，只需要展示。服务端除了关心状态，还要提供状态的转换接口。

## 视图驱动、组件优先

在前后分离的模式下，**大多数前端业务开发流程都是以视图驱动为主**，并且在前端框架**组件**概念的设计下，形成了以**组件优先**的开发模式:

1. 先根据 UI 稿子拆分成组件、面向组件写页面
2. 再根据原型文档与接口完成业务交互

那么在面向组件开发的模式下如何做好业务开发？

- 了解前端组件
- 业务模型如何与前端组件对接

### 前端组件

在了解前端组件设计前，得先明白框架渲染原理（React、Vue）

- 主流框架理念（React、Vue）
  - 底层原理
    - 视图渲染
      - 视图是数据模型的一种映射 `UI = f(state)`
      - 演变过程：
        - `html = template(vars)`
        - `vdom = render(viewModel)`
          - vdom 是面向浏览器的领域模型
          - viewModel 是基于业务领域概念所建立的页面显示模型
            - redux 和 vuex 从某种意义上可以看作是面向领域的消息总线，它们一般都是直接派发到具体的监听器，而且这些监听器的入口函数不再是某种通用的、与业务无关的Event对象，而是具体的领域状态对象state和业务参数param
    - 响应式更新、MD
      - 数据驱动：State => UI
      - *事件驱动*
  - 上层范式：状态可以映射到 UI，那么如何管理好状态对应的映射关系？
    - 组件：作为上层范式，将状态与「和他相关的 UI」约束在一起
    - 组件范式
      - 对象式
      - 函数式

总的来说：`组件 = UI + 状态逻辑`。但存在以下主要问题：

- 逻辑耦合及复用问题
  - 组件概念借鉴了“OOP”的封装概念，通过面向对象之类的思想来对界面或者业务做模块化尝试复用。但**前端框架的组件是应用构成基本单位，而不是逻辑复用的最小单位**
    - **组件包含视图渲染逻辑和状态交互逻辑**：比如在某些业务场景下，视图一样但面对用户角色不同需要的业务交互逻辑不一样；反之，同样的业务逻辑在移动端和 PC 端表现的视图又不一样的情况
  - 在视图驱动下，State 是围绕 View 的消费和交互需求而产生的，View 是组件真正核心的部分，这就导致在视图组件里编写越来越多的代码，并成了一个流行趋势，**组件同时承载了界面逻辑和业务逻辑**
- 状态管理困难
  - 整个应用最终以组件树的形式组织展示，组件封装状态逻辑，逻辑自治，但分散在组件树，树形结构阻碍了组件数据通信。"状态管理" 的核心就是解决数据通信及规范化问题。

### 逻辑分离及复用

- 关注点分离：UI 层与业务逻辑层分离的模式
- 面向 Model 层
- 函数组合模式
  - 组件：组合逻辑状态、渲染 UI
  - hooks 分离逻辑
    - useXXX/createXXX
  - reducer 组合逻辑状态
  - context 共享上下文状态
    - createXXXCtx
    - useXXXCtx

### 状态管理

对Model层的管理，也就是所谓的「状态管理」



- 状态设计
  - 驱动 UI
  - 状态分类
    - 异步状态
    - 流程状态
      - 状态机
    - 事件流
      - rxjs
  - 扩张
    - 组合
    - 领域
    - 插件
  - 性能
    - 轻量、tree-shaking
  - 开发
    - 热模块更换
    - DevTools 支持
     - 动作、响应追踪
     - 商店出现在使用它们的组件中
     - 时间旅行和更容易的调试







```js
export const useTags = () => {
  const tags$ = computedAsync(async () => {
    //...
  }, [])

  const selectedTags$ = ref<string[]>([]);
  const selectTag = (tag: string) => {
    selectedTags$.value.push(tag)
  }
  const isSelected = (key: string) => {
    return selectedTags$.value.includes(key)
  }

  return {
    dic$,
    tags$,
    selectedTags$,
    selectTag,
    isSelected
  }
}

const key = Symbol("tag") as InjectionKey<ReturnType<typeof useTags>>
export const createTagsCtx = () => {
  const all = useTags();
  provide(key, all);
  return all;
};
export const useTagsCtx = () => (inject(key) || createTagsCtx());
```

## Vue3 组件开发范式

```js
// 1.对象式 setup 组件
const App = {
  name: "xxx",
  props: ["xxx"],
  setup(props, ctx) {
    // 1.返回状态
    //return {}

    // 2.返回渲染函数
    return () => h("xxx");

    // 探索模板字符串标签
    // return () => vue`<div>{{xxx}}</div>`
  },
};

// 2.函数式组件（本质渲染函数，vue3 后函数组件的函数签名跟状态组件 setup 保持一致）
// const App = (props, ctx) => {
//   return <div>{xxx}</div>
// }

// 3. setup 函数
// const App = (props, ctx) => {
//   return () => <div>{xxx}</div>
// }
// defineComponent(App)

// App.props = ['value']
// App.emits = ['click']
```

## 参考

- [面向 Model 编程的前端架构设计](https://mp.weixin.qq.com/s/g4hnfirDmyeuXAdEt-zk9w)
- [Hooks是否过誉了？前端应该跟着React走还是跟着JS、TS走？ - beeplin的回答 - 知乎](https://www.zhihu.com/question/468249924/answer/1968728853)



MVC 是一种软件架构模式，通常用于开发用户界面，主要是在解决数据逻辑和视图逻辑的分离问题；**MVC 在不同编程领域有不同的通信模型变化**，而在 web 前端领域里通常是 MVP 和 MVVM 的 MVC 变种模型，并且前端的 MVC 对应整个 web 应用的 MVC 模型中的 V。

主要由三部分组成

- Model：应用的状态管理和业务逻辑
- View：视图渲染和视图逻辑管理
- Controller：控制器，接受、处理用户指令，调度数据模型和视图通信



  - 状态通信
    - 状态管理
      - 组件级
      - 页面路由级/业务级
      - 应用会话级
    - 组件树 + 层级栈：区域状态


- rest
  - REST更像是一种范式，而不是API标准
  - REST API”用于基于HTTP的JSON API
  - 使用 REST，一切都以资源为中心，可以检索和操作资源

