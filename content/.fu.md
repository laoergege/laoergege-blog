- 今
  <!-- - 整理简历 -->
  - 整理文章
  - 刷题
    <!-- - JS
    - 框架
    - 网络 -->
    - 算法
  - 学习
    <!-- - 《面向对象是如何工作的》 -->
    <!-- - 《设计模式之美》 -->
    <!-- - 《可视化入门：从 0 到 1 开发一个图表库》 -->
    - 编译原理
      - [Crafting Interpreters](https://craftinginterpreters.com/introduction.html)
      - SICP
    - Rust 程序设计语言 简体中文版
    - CSAPP
      - [深入理解计算机系统（CSAPP）](https://hansimov.gitbook.io/csapp)
      - [CSAPP重点解读](https://fengmuzi2003.gitbook.io/csapp3e)
      - [CS自学指南](https://csdiy.wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/CSAPP/)
        - [2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频](https://www.bilibili.com/video/BV1iW411d7hd/?vd_source=5e3f59e2a50994ae58323e0f75a50d48)
  - 博客
    - PWA
- 主
  - 找工作
    - 面试
    - 远程
      - https://zhuanlan.zhihu.com/p/682257969
  - 戒色
    - 每半个月下载一次
    - 每天删除三部
    - 每星期dfj一次
- 次
  - [计算机教育中缺失的一课](https://missing-semester-cn.github.io/)
  - 计算机原理
    - [趣话计算机底层技术](https://book.douban.com/subject/36428782/)
  - 编译原理
    - [如何用JavaScript实现一门编程语言 - 前言](https://zhuanlan.zhihu.com/p/449735557)
    - [程序员的自我修养](https://book.douban.com/subject/3652388/)
    - https://www3.nd.edu/~dthain/compilerbook/
    - [自己动手写编译器](https://pandolia.net/tinyc/)
  - [图解 Google V8](https://time.geekbang.org/column/article/211682)
  - fastify ts react prisma pg
    - Prisma 从数据库模型中为后端应用程序生成类型，而 tRPC 则从后端为前端 API 层维护类型安全
    - tRPC 使用 JSON-RPC 作为规范，HTTP 作为传输层
  - 金融知识、投资理财
  - js 插件机制
  - 重拾英语学习
    - 英语基础的音标、词汇和语法
      - 英语兔
      - 词典
        - 单词本
    - 听说读写
      - 阅读
      - 口语
        - AI Myshell
  - Node 服务、RPC、TypeScript、BFF
    - [基于 RPC 和 TypeScript 的 BFF 设计与实践](https://mp.weixin.qq.com/s/b9rCxSsTFqCZ9HPEGSfU-w)
    - [@fastify/vite](https://fastify-vite.dev/)
    - [prisma](https://www.prisma.io/)
  - [React Native](https://reactnative.dev/docs/set-up-your-environment)
  - 《Tony Bai · Go语言第一课》
  - 博客
    - 修复图片失败，zoom 失效
    - 样式优化
      - 工具栏
        - 图标标亮
        - 侧边栏
  - Coze
    - 搭建知识库
      - API 文档联动
  - Cursor
    - [Cursor 一个真正让程序员产生危机感的 AI 编程工具](https://mp.weixin.qq.com/s?__biz=MzI3Njk5ODg4OQ==&mid=2247489537&idx=1&sn=147a299e76c9d6147caf097c21fb1bb5)
    - https://zhuanlan.zhihu.com/p/721118284
  - 音视频
    - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/攻克视频技术
    - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/快手 · 音视频技术入门课
    - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/从 0 打造音视频直播系统
    - [【第3251期】Webcodecs音视频编解码与封装技术探索](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651270524&idx=1&sn=821eba7bee6f154b2c78c536841bd9db&chksm=bd48f4f88a3f7deeabd9648f784e99d7b5ffac4a97a5d5a6aad5e9947440f871e87f1027effe&scene=21#wechat_redirect)
- 经验总结
  - 编码思想
    - 面向对象思想
      - 封装
        - 单一职责
      - 扩展
        - 不要修改原有代码，在现有代码的基础上做扩展（开闭原则）
        - 行为覆盖：接口继承、保持行为一致，不破坏原有继承逻辑的正确性（ Liskov 替换）
      - 依赖
        - 最小依赖（接口隔离）
        - 依赖抽象（依赖倒置）
        - 单向依赖
    - 代码复用思想
      - 复制优于复用
      - 组合优于继承
  - 代码模式
    - 封拆
    - 封 => 接口抽象 => 拆
  - 工程优化
    - 数量
    - 链路
    - 拆并
- 技术栈
  - web
    - 图表
    - jsruntime
      - node
      - winterjs
      - wasm
    - vue、react
    - http
    - js、ts
    - html、css
  - 软件工程及架构
  - 跨端 
    - react-native
    - electron
  - 系统 Rust
  - 计算机基础
    - 编译原理
      - SICP
    - 计算机原理
      - CSAPP
- 学习
  - 计算机专业
    - 应用开发
      - 软件设计、架构、工程
        - 《设计模式之美》
      - [Web 开发](#web-应用开发)
        - 后端服务
          - https://www.bilibili.com/read/cv21266100/
      - Web3、区块链、比特币
        - TODO: 了解Web3、区块链、比特币
        - Web3
          - 技术
            - 区块链技术：Web3 开发的核心是区块链技术，开发者需要了解区块链的基本原理、共识机制、加密算法等基础知识
            - 智能合约开发：智能合约是在区块链上运行的程序，开发者需要了解智能合约的编写语言（如 Solidity）和开发工具，以及合约的部署和调用方法
            - 去中心化应用设计：Web3 应用需要具备去中心化的特点，开发者需要了解去中心化应用的设计原则、用户体验和开发流程等
            - 分布式存储技术：Web3 应用通常需要使用分布式存储技术来存储和管理数据，开发者需要了解常见的分布式存储方案，如 IPFS
          - 以太坊是 Web3 中应用最广泛的区块链平台，学习以太坊的白皮书是了解区块链和智能合约的重要基础
            - [以太坊白皮书](https://ethereum.org/zh/whitepaper/#decentralized-file-storage)
            - Solidity 官方文档：Solidity 是以太坊智能合约的编程语言，学习 Solidity 官方文档可以快速入门智能合约的编写和部署
            - Web3.js 官方文档：Web3.js 是以太坊 JavaScript API，学习 Web3.js 官方文档可以了解如何使用 JavaScript 与以太坊进行交互
            - https://ethereum.org/zh/
    - 计算机
      - 数据结构与算法
      - 计算机组成原理
        - https://csapp.cs.cmu.edu/3e/home.html
      - 编程语言
      - 编译原理
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/编译原理实战课
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/编译原理之美
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/手把手带你写一门编程语言
        - https://sarabander.github.io/sicp/html/index.xhtml
        - [Introduction to Compilers and Language Design](https://www3.nd.edu/~dthain/compilerbook/)
      - 操作系统
        - https://pages.cs.wisc.edu/~remzi/OSTEP/
      - 资料
        - https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8
        - https://github.com/ForrestKnight/open-source-cs
    - 人工智能
      - TODO: 了解人工智能 AI、机械学习 ML、深度学习 DL、大模型 MML
      - TODO: LLM 应用
      - TODO: 探索豆包使用
      - TODO: ocr 服务s

## 房

- 押金 5w
- 维修基金 10094
- 律师费 2960
- 首付
  - 父母 860025
  - 老二 10w
  - 老小 10w
- 每月还贷
  - 11898.76（2023.10.1 - 至今）
    - 老二 还至 2023.3.1
  - 12998（2022.8.1 - 2023.9.1）
  - 13288.48（2021.8.1 - 2022.7.1）
- 房税+面积差价
- 装修

## Web 开发

- Web 开发
  - 工作原理
    - 请求 -> 中间件 -> 服务、RPC -> 数据库 -> 页面渲染
  - RPC
    - 序列化
      - API
        - RESTFul
          - 基于 http 特性的架构
            - 资源请求
              - **将接口以资源的形式表达**
            - 请求独立性
            - 无状态
          - 解决互联网级别的信息共享和互操作问题。写接口的目标各自不同。而REST的目标是“实现互联网级别的信息共享系统”
            - “开放接口”。因此可以看到有些开放接口用REST实现还是很不错的，比如github的接口，AWS S3的接口等。
          - [前后端接口规范 - RESTful 版](https://github.com/olivewind/restful-api-specification)
        - JSON-RPC
        - protobuf
      - 序列化原理
    - 传输协议
    - 服务注册和服务发现
  - 中间件
    - WAF 防火墙
    - DNS
    - CDN
    - 消息队列
    - 缓存系统
      - Redis
    - 安全框架
      - 用户认证及授权
      - HTTPS
      - Web
        - CSRF（跨站请求伪造）保护
        - CORS（跨源资源共享）配置
        - 安全头部和内容安全政策
          - 了解如何配置 HTTP 安全头部，如 HSTS、X-Frame-Options。学习内容安全政策（CSP）的基本原理
          - Helmet
    - 搜索引擎
      - Elasticsearch
    - 日志框架
    - API 网关
      - 请求路由
      - 反向代理
      - API聚合
      - 服务发现
      - 负载均衡
      - 限流和熔断
  - Web 服务
    - 参数验证
    - URL 路由
  - 测试
    - 压测 http 服务（ab）
      - QPS
      - 吞吐率
  - 后端服务
    - 高并发
    - 数据库，网络等 IO
  - 性能优化
    - 数据库
      - 索引
      - 分库分表
    - 请求
      - RPC 链路优化
      - 限流
      - 缓存
      - 负载均衡
    - 服务
      - 集群化 + 负载均衡
      - 消息队列

## 其他

- 音视频
  - [freeswitch](https://github.com/signalwire/freeswitch)
  - - 输入
    - 输入源可以是物理设备，例如麦克风、网络摄像头或来自用户硬盘或远程网络对等点的本地或远程文件。
  - 媒体流
  - 元素、RTC
  - TCP 传送可靠、有序的数据流：如果中间数据包丢失，则 TCP 会缓冲其后的所有数据包，等待重传，然后按顺序将数据流传送给应用程序
  - 不保证交货顺序
  - 没有确认、重传或超时
  - 无连接状态跟踪
  - 无拥塞控制
  - 信令服务
    - 会话发起协议 (SIP)
  - 连接建立后，应用程序仍然可以在 RTCPeerConnection 对象中添加和删除流。每次发生这种情况时，都会调用自动 SDP 重新协商，并重复相同的初始化过程。
- 内网服务外网用
  - 动态公网 IP + DDNS
  - 内网穿透
  - IPv6

## 项目、框架、架构、模式

- 动效
  - 初始状态
  - 过渡速率 = 曲线函数 + 时长
    - https://cubic-bezier.com/
  - 结束状态
  - 方案
    - 序列帧
    - CSS 动画
    - After Effects
      - [lottie](https://github.com/airbnb/lottie)
- 缓存策略
  - 预缓存
  - 按需缓存：指在运行时从网络请求资源时的缓存策略（[代码示例](https://web.dev/learn/pwa/serving/)）
    - 仅缓存  
    - 仅限网络
    - 缓存优先：优先使用缓存，资源不存在则退为网络请求 
    - 网络优先：优先网络请求，网络失败则退为使用缓存 
    - SWR(Stale-while-revalidate)
  - 缓存置换算法
    - FIFO：先进先出算法，当缓存空间不足时，优先删除最先加入缓存的数据项，该算法主要适用于实时性较强的数据
    - LRU：最近最少使用算法，当缓存空间不足时，优先删除最久没有被使用到的数据，该算法主要适用于热点数据
    - LFU：最不常使用算法，当缓存空间不足时，优先删除使用频率较少的数据，该算法主要适用于数据访问模式不会频繁发生变化的数据
- 字典
  - 缓存优先
  - swr
  - 乐观UI
- Electron
  - 基于 Chromium 和 Node.js 的跨平台桌面应用框架
  - 架构：Main Process（Nodejs 主进程）和多个 Renderer Process（渲染进程）
  - 主进程（Main Process）：负责控制应用生命周期、创建窗口等。主进程和 Node.js 运行在一起，可以直接访问 Node.js 的所有模块。
    - 使用 BrowserWindow 类创建窗口。
    - 使用 ipcMain 处理来自渲染进程的消息。
  - 渲染进程（Renderer Process）：每个窗口都有独立的渲染进程，使用 ipcRenderer 和主进程通信。
    - 类似于 Web 页面的环境，但可以通过 nodeIntegration 访问 Node.js API。
    - 通过 ipcMain 和 ipcRenderer 进行进程间通信，实现主进程和渲染进程的数据交互
  - 构建打包
- Web 体验设计之开发者标准
  - 移动优先、响应式设计
  - 渐进增强，功能检测
    - 使用 `@supports` 检查浏览器是否支持 CSS 功能
    - 发布现代 JavaScript，您可以使用 module/nomodule 模式
  - 提供快速且良好的用户体验
    - Web Vitals
  - 动画
    - [【第3239期】基于afx透明视频的视觉增强前端方案](https://mp.weixin.qq.com/s/fkDKfzHqCIDUH8C36KNcvA)
  - UI
- Admin 系统模块
  - 列表
  - 表单
  - 文件
    - [【第2848期】web端pdf编辑能力设计与实践](https://mp.weixin.qq.com/s/HVfJafQazaZzelmZqXVOgg)
    - [How to Build a JavaScript PDF Editor with pdf-lib](https://pspdfkit.com/blog/2021/how-to-build-a-javascript-pdf-editor/)
  - 权限设计
  - 登陆验证
  - 工作流
  - canvas
    - canvas table
      - [glide-data-grid](https://grid.glideapps.com/)
    - canvas text
      - [Canvas-Txt](https://github.com/geongeorge/Canvas-Txt/)
      - [canvas-hypertxt](https://github.com/quicktype/canvas-hypertxt)
- 发布 - 消费 - 生产
- Vue
  - [深入理解单文件组件编译](https://www.bilibili.com/video/BV1Zb421n7dR/?spm_id_from=333.788&vd_source=5e3f59e2a50994ae58323e0f75a50d48)
  - 指令
  - 插槽
    - 作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能
    - 子节点会被编译成，`{ default: () => [123] }`
  - watch vs. watchEffect
    - https://cn.vuejs.org/guide/essentials/watchers.html#watch-vs-watcheffect
    - watch：state sync pre effect post

## 计算机技术栈

- 计算机技术栈
  - 领域
    - Web
      - HTML/CSS
      - WebAPI
        - [ ] PWA：博客 + PWA
      - HTTP
        - [ ]《透视 HTTP 协议》
        - [图解 QUIC 连接](https://cangsdarm.github.io/illustrate/quic)
      - 浏览器
        - [ ] 《浏览器原理及实践》
      - 前端框架及工程化
        - [Vue](./前端框架/README.md)
        - React
        - [前端工程化](./content/前端工程化/README.md)
      - Web 服务
        - [NodeJS 服务开发](./NodeJS)
      - 音视频
        - [ ] 《从 0 打造音视频直播系统》
      - 图表
      - 可视化
        - [I want to talk about WebGPU](https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu)
    - 容器
      - [ ] 《Kubernetes 入门实战课》
  - 软件设计及架构、软件工程及软件工具
    - 软件设计及架构
      - [ ]《软件设计之美》
    - 软件工程及软件工具
      - DevOps
      - Git
      - [SSH](./软件设计及架构、软件工程、软件工具/SSH.md)
        - [ ] [ssh-tutorial](https://github.com/wangdoc/ssh-tutorial)
  - 程序设计语言与实现原理、编译原理
    - [JavaScript](./JavaScript/README.md)
      - [ ] 《JavaScript 核心原理精讲》
      - [ ] 《ES6 入门教程》
      - Typescript
    - Rust
      - [ ] [《Rust 程序设计语言》](https://kaisery.github.io/trpl-zh-cn/title-page.html)
      - [ ] 如何用 napi-rs 搭建一个 Node.js 可以调用的 Rust 库
      - [ ] WebAssembly + 前端
      - [ ] Rust CLI
    - 语言实现原理、编译原理
      - [ ] https://craftinginterpreters.com/contents.html
      - [ ] 《手把手带你写一门编程语言》
      - SICP
        - [ ] https://sourceacademy.org/sicpjs/acknowledgements
        - [MIT 计算机程序的构造和解释](https://github.com/DeathKing/Learning-SICP)
        - [Berkeley 的 61A 课程](https://www.bilibili.com/video/av40460492/?vd_source=5e3f59e2a50994ae58323e0f75a50d48)
      - [《程序语言理论与实现》](https://bobzhang.github.io/courses/)
      - 《编译原理》龙书
      - https://www.edx.org/course/compilers
  - 计算机系统
    - 计算机网络
      - [ ] 《计算机网络通关 29 讲》
      - [ ] 《趣谈网络协议》
      - [ ] 《计算机网络-自顶向下方法》
      - [The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm)
        - RFC：https://datatracker.ietf.org/doc/rfc1644/
    - 操作系统
      - [ ] 《重学操作系统》
      - [ ]《趣谈 Linux 操作系统》
      - 《现代操作系统：原理与实现》
    - [数据结构与算法](./数据结构与算法/README.md)
      - [ ] leetcode 200 道
      - [ ] 《数据结构与算法之美》
      - [ ] 《算法面试通关 40 讲》
      - [ ] [Hello 算法](https://www.hello-algo.com/)
    - 计算机组成原理（计算机体系结构）
      - [ ]《程序是怎样跑起来的》
      - [ ] https://www.bilibili.com/video/BV1iW411d7hd
    - 编译原理
    - 分布式系统
    - 操作系统
    - 数据库系统
    - 存储系统
  - 数学与应用

## 编程语言

- 概览
  - 语言
    - 语法学习
    - 语言设计与实现
  - 语言工具
    - 代码风格及质量 formatter、linter
    - 包管理
    - 调试工具
    - 测试工具
    - 编译工具
    - 构建工具
      - resolve
      - transform
      - link
      - minifer
  - 库、框架：面向领域开发的工具
  - 工程化
- 语言学习路线
  - 了解
    - 历史现状
    - 思想特点
    - 缺陷
  - 变量、值和类型
    - 变量重声明：同名变量遮蔽问题
    - 变量提升
    - 动态语言
      - 运行检测类型
      - 动态赋值
    - 类型
      - 基本类型
        - 指针
      - 复合类型
        - 引用
          - 引用（reference）和指针
            - 引用就是个胖指针，内部比正常指针携带更多信息
            - 引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用
        - 结构体
      - 联合类型
        - 标签联合：标签集合 + 联合类型
        - 枚举
          - 枚举是标签联合的子类型，只提供标签部分
          - 一个由有限数量常量所构成的集合
  - 语句、表达式及运算符
    - 表达式：计算；语句：控制
    - 控制流
      - 顺序
      - 跳转
        - 分支
        - 循环
          - 一直
          - 次数
          - 条件
          - 迭代
        - 中断
          - 跳出循环、循环标签
    - 解构
      - 模式匹配：基于类型的分支
  - 函数
    - 将大问题分解为若干小任务与代码复用
    - 闭包：闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分
  - 程序结构
    - 程序入口
    - 代码块和作用域
      - 作用域是一个编译期的概念，也就是说，编译器在编译过程中会对每个标识符的作用域进行检查，对于在标识符作用域外使用该标识符的行为会给出编译错误的报错
      - 静态作用域、动态作用域
  - 模块系统
  - 内置数据结构
  - 错误处理
    - 错误的处理流程
      - 生成表达
      - 传递、捕获
      - 处理
        - 忽略
        - 反馈
        - 重试
        - 日志
        - 上报
    - 语言的错误处理机制
      - 错误码 + 返回值
        - 错误码机制，容易忽略错误，需要显式的传播和捕获 ❌
        - 错误返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
          - 可类似 Golang **多值**返回，区分开错误返回和正常返回
      - 异常抛出
        - 异常可以通过栈回溯（stack unwind）被一层层自动传递，直到遇到捕获异常的地方，如果回溯到 main 函数还无人捕获，程序就会崩溃
          - 异常看成一种关注点分离（Separation of Concerns）：错误的产生和错误的处理完全被分隔开，调用者不必关心错误，而被调者也不强求调用者关心错误
          - 使用异常来返回错误可以极大地简化错误处理的流程，它解决了返回值的传播问题
      - 错误类型 + 返回值
        - 错误类型检测，强制显示处理
        - 继承扩展 Error 接口类型
          ```js
          // 根据自定义错误类型或者错误行为做决策处理

          // 错误类型
          if( xxx instanceof XxxError) ...

          // 错误行为
          error.ifNoAuth(callBack)
          ```
    - 错误处理实践原则
      - 正确区分错误和异常
        - 异常是不可恢复的错误，是程序员无法预期或者不在意的错误
        - 面对异常，异常上报，停止执行
      - 尽量不要忽略任何一个错误
        - 错误类型化，通过类型系统检查 ✅
      - 错误类型扩展上下文信息
      - 将正确逻辑和错误处理分隔开
        - 比如 `try-catch`、模式匹配 `match` 等语法机制
    - 错误调试
      - 堆栈追踪
      - 日志记录、打印
      - 调试器
  - 面向对象
    - 方法
  - 接口抽象
  - 并发、异步
    - 并发
      - 如果逻辑控制流在时间上重叠，那么它们就是并发的（concurrent）。这种常见的现象称为并发（concurrency），出现在计算机系统的许多不同层面上
      - 层面
        - 应用级并发
          - 异步IO
          - 操作延迟
          - 并行计算
          - 异步事件处理: Linux 信号处理程序
        - 系统内核层面
        - 硬件层面
      - 使用应用级并发的应用程序称为并发程序（concurrent program）。现代操作系统提供了三种基本的构造并发程序的方法
        - 进程
        - 线程
        - I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间
    - 并发编程
      - 异步编程：语言或框架层面实现的并发功能
      - 多线程编程
    - 并发模型
      - 线程模型
        - *基于系统线程的多线程*
          - 线程数量限制
          - 线程切换消耗
        - 协程（用户线程）
      - 事件驱动模型
        - 事件循环 + 回调队列
    - 并发设计
      - 并发调度
      - 状态竞争、逻辑同步
        - 同步原语（互斥锁、条件变量、读写锁）
          - 死锁
    - 异步能力
      - 上下文切换和现场保存工作
      - 事务
        - 逻辑完整性
        - redo/undo
  - 泛型
    - 数据结构的泛型
    - 代码的泛型化
  - 元编程
    - 宏编程
    - 反射
  - 语言互操
    - FFI 外部函数接口（foreign function interface）
    - IPC 进程间通信（inter-process communication）
      - shell
  - 指针操作
- 语言设计与实现
  - 实现：编译原理与运行时
  - 运行机制（高级语言 -> ... -> 汇编语言 -> 机器语言）
    - 编译方式
    - 解释方式
    - IR + 虚拟机
  - 变量的内存结构
    - 内存布局结构
      - 函数调用栈
      - 动态数据堆
      - 静态区
        - 代码
        - 常量
    - 分配原则
      - 栈
        - 固定大小、少量数据
        - 固定生命周期
      - 堆
        - 动态大小
        - 动态生命周期
    - 内存对齐
  - 垃圾回收
  - 代码复用
    - 代码拷贝
    - 代码指针
      - 指针拷贝
      - 委托
        - 隐式 继承
        - 显示 组合
  - 多态
    - 编译时多态
      - 函数重载
    - 运行时多态
      - 子类型多态
        - 方法表
      - 泛型
- 软件分类
  - 开发者定位
    - 应用开发者
    - 系统开发者
    - 硬件开发者
  - 业务应用系统
  - 嵌入式软件
  - 工具应用软件
  - 基础软件
- 应用开发
  - shell
    - glob 语法
      - `*`：任何路径段
        - 星号不匹配名称以点开头的“不可见文件”，如果我们想匹配这些，我们必须在星号前加上一个点：`.*`
      - `**`：匹配零个或多个路径段
      - `!`：排除
      - `\{xx,xx\}`：可选匹配
  - 二进制操作、编解码
  - 字符串、文本操作
    - 文本
      - 字符串拆分成行
        - RE_SPLIT_EOL = /\r?\n/;
        - /(?<=\r?\n)/
    - 文本编码
      - Unicode
        - Unicode 只是一个符号集，它只规定了符号的二进制代码
      - 二进制存储格式编码
        - UTF-8
          - 一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度
      - 阅读推荐
        - [字符编码笔记：ASCII，Unicode 和 UTF-8](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
  - 协议、编译原理
  - 操作系统交互
    - 可执行程序
      - 脚本
      - 二进制可执行程序
    - I/O
      - 软连接
        - 实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息
        - A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。
    - IPC
      - 命名管道
      - Unix Domain Sockets
      - Unix 信号
      - 消息队列
      - 共享内存
      - 内存映射文件
      - I/O 文件（文件和 TCP 套接字）
- 软件工程
  - 项目管理
  - 语言工程
    - 代码管理 Git
    - 语言工具
  - 软件开发
    - 分析
      - 方案（最小原则） -> 提出问题 -> 优化 -> 迭代
    - 设计
    - 编码
    - 测试
      - 单元测试
      - 端对端测试
  - 运维工程
    - devop
    - CICD
    - 监控
      - 服务监控
      - 错误监控
      - 性能监控
        - CPU Usage
        - Memory Usage
        - Disk Usage
        - Network Usage
- 性能优化工程
  - 性能指标
  - 性能监控
  - 性能排查
    - 获得 I/O、CPU、内存等信息
    - 进程/线程
    - 方法火焰图
  - 性能优化方法论
    - 思路
      - 数量
      - 链路
    - CPU
      - 减少不必要的计算
      - 空间换时间，即缓存计算结果
      - 提高计算能力
      - 并发，多进程、多线程
    - 内存
      - 减少内存使用
      - 防止内存泄漏
      - *注意内存安全*
    - IO
      - 缓存
      - 吞吐率
- 编译原理
  - 前端
    - parser
      - lexer
      - ast
    - traverser
      - processor
      - verifier
    - codegen
- 软件指标
  - 功能性
  - 性能性
  - 可用性
  - 编码
    - 可维护性
    - 可扩展性
    - 可重用性
  - 安全性
- 软件架构
  - 角度
    - 业务架构
    - 代码架构
    - 运行架构
  - 架构
    - 解耦、分离责任
    - 通信流程方向
  - 模式
    - 分层架构，自上而下单向依赖关系架构
- 编程范式
  - 程序 = 数据结构 + 算法
  - 范式 = 状态表达 + 计算表达
  - 结构化编程
    - 无 goto，控制结构：限制使用 goto 语句，**对程序控制权的直接转移施加了约束**
    - 调用栈、局部变量和按值传递：提高子程序独立性
    - 功能化分解：结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度
    - 缺点
      - 自定而下功能分解，这种结构下模块具有**强依赖性**、**抽象性不够**：一旦需求变动，经常是牵一发而动全身，关联的模块由于依赖关系的存在都需要变动，**无法有效隔离变化**
      - **可测试性不够**
      - 全局变量问题
  - 面向对象侧重状态表达：对象 = 属性 + 行为
  - 函数式侧重计算表达
  - （函数）响应式：数据流
- 函数式编程
  - 函数式编程（lambda演算）的确和图灵机等价
  - 要素
    - 表达式
    - 映射
    - 代数
  - 范畴论
    - 范畴论提供了一种高层次的框架，用来理解数学和其他学科中的结构和变换
    - 主要研究对象、态射（对象之间的关系）
    - 态射
      - 复合运算
        - 结合律：在数学中，结合律是指：只要运算数字的位置没有发生改变，运算顺序的调整不会改变运算的结果。对于所有 a, b, c ∈ S，都有:(a·b)·c=a'(b·c)
      - 恒等态射（Identity Morphism）：对于每个对象，都存在一个从该对象到它自己的恒等态射，它与任何态射组合时都不会改变原态射的效果
  - Functor（函子）：函子是范畴之间的映射，它将一个范畴的对象和态射映射到另一个范畴中，同时保持态射的组合和恒等态射
    - 恒等性
    - 结合律
  - Semigroup（半群）
    - 半群是集合 S 和其上的二元运算·:S×S→S 的代数结构，二元运算符合条件：
      - 封闭性: 对于集合 S 中的任意两个元素 a 和 b，它们的运算结果 a * b 也一定属于集合 S。也就是说，在这个集合内进行运算，结果不会“跑出”集合
      - 结合律
  - Monoid（幺半群）= Semigroup + identity element
    - identity element（单位元），单位元的特点在于，它和任何运算数相结合时，都不会改变那个运算数
- JavaScript
  - 二进制
    - ArrayBuffer
      - ArrayBuffer 对象表示通用的、固定长度的二进制数据缓冲区
      - 必须使用其封装类 ArrayBufferView 进行实例化后才能进行访问
      - ArrayBuffer 只是描述有这样一块空间可以用来存放二进制数据，但在计算机的内存中并没有真正地为其分配空间。只有当具体类型化后，它才真正地存在于内存中
    - ArrayBufferView
      - ArrayBufferView 并不是一个具体的类型，而是代表不同类型的 Array 的描述。这些类型包括：Int8Array、Uint8Array、DataView 等
    - Blob
      - Blob（Binary Large Object）是 JavaScript 的大型二进制对象类型，它代表了一段二进制数据。它可以包含文本、图像、音频、视频等多种类型的数据。Blob 对象可以通过 URL 进行引用，也可以通过 FileReader 进行读取。
- http
  - WebSocket
    - WebSocket 的握手
      - 利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制
      - WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：
        - “Connection: Upgrade”，表示要求协议“升级”；
        - “Upgrade: websocket”，表示要“升级”成 WebSocket 协议
  - URL
    - QueryString
      - 结构：`field1=value1&field2=value2&field3=value3...`
      - 多个 value 关联到同一个 field（无明确处理规范）
        - `key=a&key=b`（建议优先此形式）
    - URL 编码：将非 ASCII 字符转换为百分号编码形式（`%HH`：先转成 UTF-8 编码，再对每个字节进行%HH 的编码）
      - `encodeURI`
      - `encodeURIComponent`：URL 中有特殊含义的字符（如 空格、%、&、=、?、# 等）无法直接在 Query String 中使用
        - % 百分号编码为 %25
        - 空格编码为 %20（建议优先）或 +；
          - decodeURIComponent，是无法解析 + 为 空格的
      - qs
        - 自定义性强
        - 多层嵌套对象（Nested object）的支持
        - 使用场景：拥有强大的序列化能力，可以处理复杂的类 JSON 数据。
      - URL/URLSearchParams
        - 适合常规的 Web 端数据传输，处理平面数据结构
        - URLSearchParams 采用了 application/x-www-form-urlencoded 编码模式，而这个编码采用了一个非常早期（RFC 1738）的通用百分号编码方法——就是将 空格转换为+
    - x-www-form-urlencoded：是一种常见的编码格式，用于将表单数据编码为 URL 查询字符串
    - 空格编码为 +；
- 面向对象分析 OOA
  - 面向对象设计 OOD
    - 对事物进行分类整理的结构和表示职责分配的结构的通用的归纳整理法
      - 集合论，对数据结构归纳
        - 根据集合论进行分类整理的现实世界的事物之间的关系
      - 职责分配，行为抽象、接口
    - UML 是 Unified Modeling Language（统一建模语言）的缩写
      - 领域建模
        - 类图
          - 类图表示 OOP 程序的结构
          - 对类与类之间的关系：泛化、实现、组合、依赖
        - 使用时序图和通信图表示动作
      - 业务建模
        - 用例图
          - 确定角色与系统功能：用于以分析对象为维度，去找出它希望在系统里能做什么
        - 活动图
          - 业务活动流程
        - 状态机
          - 表示外部动作事件导致状态变迁


## 其他







- 依赖说明符
  - 相对说明符
  - 目录索引文件
    - package.json
    - index.js 或 index.ts
  - 裸说明符/包
    - node_modules 目录从导入文件向上搜索。搜索停止于项目根目录
    - 包子路径
      - 文件
      - 目录
  - 内置模块
  - 绝对说明符
    - 绝对说明符以 / 开头，并解析相对于项目根目录的文件。
  - 波形符说明符
    - 波形符说明符以 ~ 开头，并相对于导入文件中最近的包根进行解析
  - 哈希说明符




- vue
  -  @vue/reactivity
  -  Vue.js 3.0 在设计内建组件和模块时也花费了很多精力，配合构建
工具以及 Tree-Shaking 机制，实现了内建能力的按需引入，从而实现
了用户 bundle 的体积最小化
  - 特性开关
  - 可以编写自定义的渲染器，甚
至可以编写编译器插件来自定义模板语法
- 框架设计
  - 警告、提示信息、美化信息
- 想要实现 Tree-Shaking，必须满足一个条件，即模块必须是
ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构
- /*#__PURE__*/ 注释
  -  JavaScript 是一门动态语言，通过纯静态
分析的手段进行 Tree-Shaking 难度较大，因此大部分工具能够识别
/*#__PURE__*/ 注释，在编写框架代码时，我们可以利用
/*#__PURE__*/ 来辅助构建工具进行 Tree-Shaking。
- 错误处理
  - callWithErrorHandling：
- 组件
  - 虚拟 DOM 和渲染器
    - 渲染器的作用是，把虚
拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚
拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染
器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会
更新需要更新的内容。后面我们会专门讲解渲染器的相关知识
  - 渲染函数
  - 组件
  - 渲染
器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函
数并得到其返回值，我们称之为 subtree，最后再递归地调用渲染器
将 subtree 渲染出来即可
- 响应式系统
  - 响应式数据、副作用
    - WeakMap、Map 和 Set 
      - map =》 target keymap
      - keymap =》 set
  - 分支切换与 cleanup
    - 解决这个问题的思路很简单，每次副作用函数执行时，我们可以
先把它从所有与之关联的依赖集合中删除
  - 嵌套的 effect 与 effect 栈
  - 避免无限递归循环
  - 调度执行


```
01 // 定义一个任务队列
02 const jobQueue = new Set()
03 // 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加
到微任务队列
04 const p = Promise.resolve()
05
06 // 一个标志代表是否正在刷新队列
07 let isFlushing = false
08 function flushJob() {
09 // 如果队列正在刷新，则什么都不做
10 if (isFlushing) return
11 // 设置为 true，代表正在刷新
12 isFlushing = true
13 // 在微任务队列中刷新 jobQueue 队列
14 p.then(() => {
15 jobQueue.forEach(job => job())
16 }).finally(() => {
17 // 结束后重置 isFlushing
18 isFlushing = false
19 })
20 }
21
22
23 effect(() => {
24 console.log(obj.foo)
25 }, {
26 scheduler(fn) {
27 // 每次调度时，将副作用函数添加到 jobQueue 队列中
28 jobQueue.add(fn)
29 // 调用 flushJob 刷新队列
30 flushJob()
31 }
32 })
33
34 obj.foo++
35 obj.foo++
```









- 简历
  - 明确的职业目标
    - 寻求高级工程师角色，能够运用我经过验证的能力来交付规模化服务，为业务带来有价值的创新
  - 只描述活动而非成果
    - 在 Project X 中编写 Java 代码，实现了几个关键的微服务，使其能够支持企业环境，从而吸引了几个关键的新客户购买产品
  - 未能展示个人对团队或业务的影响
    - 简历应该展示求职者如何为团队、产品或业务底线带来积极变化。
    - 强调个人贡献和领导力，而不仅仅是职责描述
  - 提升简历质量的小技巧
链接到具体的项目或成果，以增加可信度。

使用粗体字突出最重要的成就。

使用强有力的动词来描述成就，如 “拥有”、“构建”、“推动” 或 “交付”。

在可能的情况下，包含具体的数字和金钱价值来量化成果。

- Promise
  - [[PromiseState]]、[[PromiseResult]]、[[PromiseIsHandled]]、[[PromiseFulfillReactions]] 和 [[PromiseRejectReactions]]
- 正则
  - 字符类
  - 范围
  - 或:
  - 量词
  - 分组
    - 反向引用
      - number
      - name
    - 断言







- TypeScript 
  - 类型系统
    - 集合特性
      - never 空集
      - & 交集
      - | 并集
      - extends 检查一个集合是否是另一个集合的子集
      - {
  [key: string]: boolean | number;
}
    - 类型层级
  - 类型编程
    - 泛型
      - 类型参数
        - 当使用类型参数时，TypeScript 决定分别对联合的每个成员执行子集检查，而不是首先将联合解析为构造的集合
          - type Result = IntrospectT<number | string>;
          - type Result = IntrospectFoo<number> | IntrospectFoo<string>;
          - 元组语法强
    - 条件
      - ?:
    - 类型映射
      - infer
        - ```ts
          type InsideArray<T> = T extends Array<infer R>
            ? R
            : "T is not a subset of Array<unknown>";
          type TheNumberInside = InsideArray<Array<number>>;
          // TheNumberInside = number
          ```
          ```
          type SetToMapOver = "string" | "bar";
          type FirstChacter<T> = T extends `${infer R}${infer _}` ? R : never;
          type Foo = {
            [K in SetToMapOver as `IM A ${FirstChacter<K>}`]: FirstChacter<K>;
          };
          ```
      - in
    - 递归
  - 类型推导










- JS
  - 对象
    - 原型
      - 原型链
    - 面向对象
      - instanceof 运算符原理及实现
      - new 运算符原理及实现
      - 原型继承
  - API
    - 正则
      - String.prototype.replace(pattern, replacement)
        - replacement
          - replacer(match, p1, p2, /* …, */ pN, offset, string, groups)
    - 数组
    - 字符串
  - 手写代码
    - 判断两个对象是否相等
      ```js
      const isEqual = (obj1, obj2) => {
        const isObj = typeof obj1 === "object" && typeof obj2 === "object";

        if (!isObj) {
          return obj1 === obj2
        } else {
          const keys1 = Object.keys(obj1);
          const keys2 = Object.keys(obj2);

          if (keys1.length !== keys2.length) {
            return false;
          }

          return keys1.every(key => isEqual(obj1[key], obj2[key]))
        }
      }
      ```
    - 如何实现一个深拷贝 (cloneDeep)
    - 实现一个数组扁平化的函数 flatten
    - 什么是防抖和节流，他们的应用场景有哪些
    - 浏览器获取地址栏参数
    - 函数式
      - 部分应用函数
      - 柯里化
      - 组合
      - 管道







- `new Function`
  - `new Function ([arg1, arg2, …argN], functionBody)`
  - 上下文是全局的
  - 场景：动态生成代码、计算




mqtt

zigbee modbus




- 内存泄漏
  - 内存泄漏的本质是：**没有及时释放不再使用的内存**
  - 常见的内存泄漏
    - 全局变量
    - 闭包
    - 定时器
    - 事件监听
    - 循环引用
  - 如何避免内存泄漏
    - 减少全局变量
    - 减少闭包
    - 减少定时器


- vnode 抽象
- render 渲染
- instance 状态维护

- 函数与状态分离
  - 函数是功能
  - main 启动功能
- 对象则是方法与状态的集合
  - 交互


- React
  - 设计理念
    - 数据驱动视图
      - UI = f(data)
    - data = state
    - f = 组件
      - 组件即函数 范式
      - **为什么 React 要推崇函数式组件？**
        - react 原生的响应式方案是非常依赖数据不可变性的，函数式编程理念与 react 更为接近
        - 隐藏 state、分离 state
          - 函数执行的上下文、每次执行 state 都只是一次映射
  - React 模式
    - 代码重用
      - 高阶组件（HOC）
        - 高阶组件和 render props 
          - 嵌套地狱
      - Render Props
      - React Hooks
        - 闭包陷阱
    - 容器组件/展示组件
      - “关注点分离”
  - Hooks
    - Hooks 的使用规则
      - 只能在 React 的函数组件中调用 Hooks
      - 只能在组件函数的最顶层调用 Hooks
      - FiberNode 上会保存一个记录 Hooks 状态的单向链表，链表的长度与执行组件函数时调用的 Hooks 个数相同
    - 组件状态：useState、useEffect、useContext、useReducer
    - 性能优化 Hooks：useMemo 和 useCallback
    - 当需要封装组件，对外提供命令式接口时，学习掌握 useRef 加 useImperativeHandle
    - 当页面上用户操作直接相关的紧急更新（Urgent Updates，如输入文字、点击、拖拽等），受到异步渲染拖累而产生卡顿，需要优化时，学习掌握 useDeferredValue 和 useTransition 
  - React 原理
    - 并发渲染
      - 运行时用 Fiber 架构重写不依赖原生调用栈，这使 React 能够在渲染阶段暂停工作以允许浏览器处理事件
      - Hooks 解决 Class API 在纯度上约束力不够的问题；不纯的组件在 React 并发模式下很容易出现数据竞态（data race）的问题
    - 渲染原理
      - 虚拟 DOM
        - **why React 为什么要使用虚拟 DOM？**
          - 为了可以使用声明式的程序代码来描述你的 UI，以及跨平台的能力
          - 减少 DOM 操作
            - 相比过去全量更新，React 只更新变化的部分
      - 虚拟 DOM 的 diff 算法
        - 同层对比
        - type 变了就不再对比子节点
        - 移动：复用元素、尽量减少创建新元素
          - 判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的
          - 每个节点都是有唯一的标识 key，利用 key 复用
          - vue2 双端对比、vue3 最小递增子序列
    - 更新
      - 异步、批量更新
      - 更新调度
        - 时间切片
      - 渲染更新
        - React 循环遍历整个组件树，查找标记为更新的组件
        - 对于每个标记的组件，从它开始，React 将递归渲染其中的所有子组件
          - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件
    - 事件系统
- React VS Vue
  - 阿里三面：灵魂拷问——有 react fiber，为什么不需要 vue fiber 呢？
    - vue 基于数据劫持 + 编译优化，能够更加精确更新
    - why react fiber
      - 在数据更新时，react 生成了一棵更大的虚拟 dom 树，给第二步的 diff 带来了很大压力，树的递归过程没法暂时停止，阻塞用户响应
      - diff 过程切片，react fiber 使得 diff 阶段有了被保存工作进度的能力
        - 为什么有了 react fiber 就能断点恢复呢；
          - fiber 是链表结构，只要保留下中断的节点索引，就可以恢复之前的工作进度；
  - Vue 与 React 框架的对比
    - 范式
    - 生态
    - 原理


- hr
  - 你觉得你最大的缺点是什么?




- HTTP/0.9
  - request 只有一行且只有一个 GET 命令
- HTTP/1.0
  - 增加状态码
  - 在 request 和 response 中添加 header 的概念
  - 在 header 中添加 content-type 以此可以传输 html 之外类型的文件
  - bad
    - http 队头阻塞
    - 短连接
- HTTP/1.1

  - 长链接 keep-alive
  - chunked 机制，分块响应
  - 缓存控制
  - 内容协商，包括语言、编码和类型，客户端和服务器现在可以就交换哪些内容达成一致
  - 请求头域中新增了 Host 字段：处理一个 IP 地址上面多个虚拟主机



- 为什么 0.1+0.2 不等于 0.3？
  - 解决
- 如何判断一个值是不是数字


没有 arguments
          - 无法通过 apply、call、bind 改变 this 指向
          - 箭头函数的 this 绑定外层上下文中的 this
          - 箭头函数不能通过 new 关键字调用


- 可迭代对象
- 剩余参数、扩展运算符
  - 解构
  - 函数参数

- cuowu 
  - 联合
  - 可选



- 将 table / list 抽象，用类似 scheme 驱动的方式
- ui 都有差异,在设计层面，可能由于业务需求，很难做到统一，不得已自带设计体系
- 后端数据模型没有统一，因此对接数据前后涉及到的前端状态管理、数据流转也未能统一，复用性大打折扣。


- css
  - bfc 布局规则
- js
  - 说一下原型链，原型链实现继承。
  - vue 中 nextTick 的实现，结合浏览器事件循环机制说一下？
  - 说说 commonjs 和 esmodule？
  - 手写简版 promise，基础架子，不用写 all、race 等 api
  - 手写 bind
- 框架原理
  - vue 模板编译原理
- http
  - http 和 tcp 协议？
  - 缓存相关（对比缓存？强缓存？对应请求头）
  - cookie 有哪些属性？
  - options
  - 简单请求？
  - 跨域？
- 浏览器
  - 为甚么要有同源策略？dns 劫持？
  - 渲染原理
- 算法
  - 回文字符串个数
  - 猴子吃香蕉
  - 爬楼梯
  - 最长公共子串
- 项目
  - 项目怎么做的移动端适配？
    - flexible 原理
    - 移动端的 1 像素问题怎么解决
  - 团队协作，以前的开发流程？
- 其他
  - 职业规划？
  - 有什么问题吗？
  - 为什么要离职？
  - 怎么学习的？








- 拆分-按需加载
- 缩小
  - 混淆
  - 代码升级
  - Removing unused code.
    - DevTools code coverage.
    - analysis of their webpack bundles
- 压缩
- 缓存
  - http
  - V8’s code cache
- PRPL（推送、渲染、预缓存、延迟加载）是一种通过积极的代码拆分和缓存来优化互动的模式：



- 正则
  - 分割行而不包含行终止符 str.split(/\r?\n/)
  - 分割行同时包含行终止符 /(?<=\r?\n)/
  - 多行文本消除首尾**空白符**：`string.replace(/^\s+|\s+$/g,"")`
  - js 正则相关 api
- 框架 xss 防范
  - xss
    - js
    - 拼接 HTML + encode
  - script
    - 逃逸



- HTTP 缓存
  - 浏览器发出的所有 HTTP 请求首先会转至浏览器缓存，用于检查是否存在可满足请求的有效缓存响应。如果存在匹配，则从缓存中读取响应，从而消除网络延迟和传输产生的数据成本。
  - HTTP 缓存的行为由请求标头和响应标头的一起控制
  - 策略
    - 版本化 URL 的长期缓存
    - 非版本化 URL 的服务器重新验证
  - 通过设置 ETag 或 Last-Modified ，您可以让重新验证请求更加高效。它们最终会触发在请求标头中提到 If-Modified-Since 或 If-None-Match 请求标头。







- 构建DOM树；
样式计算；
布局定位；
图层分层；
图层绘制；
合成显示；
- 在CSS属性改变时，重渲染会分为“回流”、“重绘”和“直接合成”三种情况，分别对应从“布局定位”/“图层绘制”/“合成显示”开始，再走一遍上面的流程。


- Typescript 项目架构
  - 构建
    - AST
      - [ts-morph](https://github.com/dsherret/ts-morph)
    - 类型加载
      - [typesync](https://github.com/jeffijoe/typesync)
    - 类型工具
      - [type-fest](https://github.com/sindresorhus/type-fest)
    - 类型检查
      - [ezno](https://github.com/kaleidawave/ezno)
    - 运行时类型检查
      - [tsd](https://github.com/SamVerschueren/tsd)
      - [zod](https://github.com/colinhacks/zod)
    - 类型协议及生成
      - [quicktype](https://github.com/quicktype/quicktype)
      - [typespec](https://github.com/microsoft/typespec)
  - 类型查找
    - 模块
    - tsconfig
  - TS 只做类型功能，由其他编译器编译代码、消除类型
    - ts
      - tsconfig
        - Language and Environment
          - target
          - lib
            - ["es2022", "dom", "dom.iterable"]
            - ["es2022"]
        - Emit
        - Modules
          - "module": "preserve",
          - moduleResolution
          - allowSyntheticDefaultImports
          - "declaration": true,
        - JS
          - "allowJs": true,
          - "checkJs": true, 
        - Emit
          - "declaration": true,   
          - "declarationMap": true,  
          - "noEmit": true,
      - package.json
        - "type": "module"
          - 路径名-扩展名 写全
        - exports
          - 将目录映射到文件
            - "./util": "./dist/src/util/errors.js"
  - 类型系统
    - 集合运算
      - 映射
    - 类型工具
    - 注释指令
      - [TypeScript 的注释指令](https://wangdoc.com/typescript/comment#-ts-expect-error)
      - [JS Projects Utilizing TypeScript](https://typescriptlang.org/docs/handbook/intro-to-js-ts.html)
    - 类型声明
      - 类型声明
        - 变量声明：用来告诉编译器，某个类型的变量的存在，可以在当前文件中使用
        - 声明增强：为外部模块扩展新的类型或类型声明合并
      - 声明文件 d.ts
  - 题目
    - type 和 interface 区别
    - any、unknown 和 never 区别



- 项目经验
  - 调试、抓包
    - 抓包
      - whistle
      - Charles
      - Wireshark
    - 调试
      - vConsole
      - eruda
      - Chrome、Safari 远程调试
  - 项目
    - Monorepo 工具，用于降低多项目的维护成本
    - 所有的项目都能够在一个仓库中统一维护，通过复用一套基建（比如 CI 配置、Lint 规则、构建脚本等），从而降低多项目维护成本
    - 其次是通过代码共享，让开发人员能够低成本地复用代码：
    - CI
  - 前端工具
    - - git
    - husky
    - lint-staged
    - commitlint
    - 版本发布：发版与 CHANGELOG 自动化
      - standard-version
      - 根据指定规则自动升级项目不同级别（major、minor、patch）的版本并打 tag
      - 对比历史 commit 提交自动生成不同版本间的可阅读、分类的 CHANGELOG 日志
  - 混合 H5
    - schema 协议做前端与原生交互通信
      - 原生拦截带有我们约定好的schema格式的url
    - Bridge 方案



- pro
  - 关闭 sourcemap
  - 分析大文件，找出内鬼
    - webpack-bunle-a
    - 拆包
    - 外置
    - cdn 加速
    - 压缩


- webpack
  - hash
    - hash 每个构建生成的唯一哈希
    - chunkhash 基于每个块的内容
    - contenthash 最终生成的文件内容



- Web 服务遇到的威胁
  - 第一种叫“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”
  - 代码注入
    - “SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。
    - HTTP 头注入
    - JS 代码注入
      - 跨站脚本”（XSS）
        - 利用 JavaScript 脚本获取未设防的 Cookie。
      - CSP内容安全策略，CSRF防御



- HTTP 是一种无状态协议
  - 状态：应用会话状态
  - 每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更
- Cookies 
  - 作用
    - 本质目的：在浏览器能够持久化少量数据
    - 通常用于
      - 会话管理
      - 第三方行为跟踪
  - 特征
    - 可跨站设置、同站共享、跨站请求自动携带
    - 大小、数量：不超过 4K，每个域下最多允许有 20+ 个左右的 cookie
  - 属性
    - 生命周期
      - Expires 绝对过期时间
      - MaxAge 相对过期时间，单位是秒
    - 可见性
      - Domain
        - 默认为当前文档域名
        - set-cookie 限制
          - 如果 Set-Cookie 的 Domain 跟请求源不是同站，则代理会拒绝设置
          - document.cookie 设置了 cookie，那么无论脚本来自何处，这个 cookie 都属于当前网页的域
      - Path 默认为当前路径
    - 安全性
      - HttpOnly 不允许 js 操作，以防范跨站脚本攻击（XSS）
      - Secure 只允许通过 HTTPS 安全协议通道发送给服务器
      - SameSite 限制跨站请求附带 Cookie，从而可以阻止跨站请求伪造攻击（CSRF）
        - Strict：严格禁止在跨站请求时发送 cookie
        - Lax（默认）：只允许顶级导航请求时发送 cookie
        - None：允许跨站请求时发送 cookie
          - 具有`SameSite=None` 的 cookie 还必须指定 Secure
  - 第三方 Cookie
    - [第三方 cookie](https://zh.javascript.info/cookie#fu-lu-di-san-fang-cookie)
  - [Cookie策略真是越来越复杂了](https://mp.weixin.qq.com/s/o2ujRN5LQCIrcobESUhWAg)





- 项目经验
  - pnpm（依赖管理）+ Turborepo（任务管理）
  - PNPM + Monorepo
    - PNPM
      - 节省磁盘：全局安装、而且基于内容寻址的方式可以做到同个包不同版本内容文件只需差异存储
      - 安装速度快：软链构建依赖结构、然后硬链到全局存储
      - 消除幻影依赖
  - 页面适配




Cache-Control: no-cache 作为请求头，表示即便在客户端拥有未过期的缓存，「也要向服务器请求获得最新的资源」。类似响应头 Cache-Control: no-store。

Cache-Control: max-age=0 作为请求头，将会「验证服务器资源的新鲜度，如果缓存未过期，则利用缓存，返回 304 状态码，否则重新获取资源返回 200 状态码」。类似响应头 Cache-Control: no-cache。



Cache-Control: no-cache 适用于每次使用前应与服务器重新验证的资源。
Cache-Control: no-store 适用于永远不要缓存的资源。
Cache-Control: max-age=31536000 适用于版本化的资源



编辑器集成
            - `"typescript.tsdk": "node_modules/typescript/lib"`



- 组件样式
    - 组件级别的样式隔离
    - 组件样式需要响应组件数据变化
  - UI 组件库
    - 设计体系
    - 主题定制



- 项目经验
  - 海报生成
  - SSR：由服务端直接渲染输出 HTML 内容到客户端，再在客户端将静态的 HTML“激活”(hydrate) ，使之能够交互
    - good
      - 更快的首屏加载
      - 更好的 SEO
    - bad
      - 开发中的限制
        - 限定组件生命周期钩子 onMounted 或者 onUpdated 这样的生命周期钩子不会在
        - 访问平台特有 API
      - 需要更多的服务端负载及运维
  - 组件库调试
  - H5
  - pwa


- git
  - release(changelog & tag & publish)
    - [release-it](https://github.com/release-it/release-it)
    - [semantic-release](https://github.com/semantic-release/semantic-release)
    - [release-please](https://github.com/googleapis/release-please)
    - changelog
      - https://git-cliff.org/
      - [conventional-changelog](https://github.com/conventional-changelog/conventional-changelog)
    - tag
      - [beachball](https://github.com/microsoft/beachball)



- JS
  - Object
    - valueOf
    - [Symbol.toPrimitive]() 





- 表单
  - [jsonforms](https://github.com/eclipsesource/jsonforms)
  - [react-jsonschema-form](https://github.com/rjsf-team/react-jsonschema-form)