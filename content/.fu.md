- 今
  <!-- - 整理简历 -->
  - 整理文章
  - 刷题
    <!-- - JS
    - 框架
    - 网络 -->
    - 算法
  - 学习
    <!-- - 《面向对象是如何工作的》 -->
    <!-- - 《设计模式之美》 -->
    <!-- - 《可视化入门：从 0 到 1 开发一个图表库》 -->
- 主
  - 找工作
    - 面试
  - 戒色
    - 每半个月下载一次
    - 每天删除三部
    - 每星期dfj一次
- 次
  - [React Native](https://reactnative.dev/docs/set-up-your-environment)
  - 《Tony Bai · Go语言第一课》
  - 博客
    - [x] tree list
    - [x] 搜索
    - [x] 图像功能
    - [ ] PWA
    - [ ] 修复图片失败，zoom 失效
  - Coze
    - 搭建知识库
      - API 文档联动
  - Cursor
    - [Cursor 一个真正让程序员产生危机感的 AI 编程工具](https://mp.weixin.qq.com/s?__biz=MzI3Njk5ODg4OQ==&mid=2247489537&idx=1&sn=147a299e76c9d6147caf097c21fb1bb5)
- 学习
  - 比特币，股票，金融
    - TODO: 怎么入手
  - 互联网营销
    - 渠道
      - “SEO”（搜索引擎优化）
      - 短视频
    - TODO: 如何利用 GPT 快速做营销图文、视频？
  - 计算机专业
    - 应用开发
      - 软件设计、架构、工程
        - 《设计模式之美》
      - [Web 开发](#web-应用开发)
        - JavaScript
        - 前端框架
          - [@fastify/vite](https://fastify-vite.dev/)
        - 可视化图表、3D
        - 后端服务
          - https://www.bilibili.com/read/cv21266100/
          - Go
            - 《The Go Programming Language》
            - 《Go 语言项目实战》
      - Rust
        - tauri
        - WASM
      - TODO: 音视频
        - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/攻克视频技术
        - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/快手 · 音视频技术入门课
        - file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/从 0 打造音视频直播系统
      - Web3、区块链、比特币
        - TODO: 了解Web3、区块链、比特币
        - Web3
          - 技术
            - 区块链技术：Web3 开发的核心是区块链技术，开发者需要了解区块链的基本原理、共识机制、加密算法等基础知识
            - 智能合约开发：智能合约是在区块链上运行的程序，开发者需要了解智能合约的编写语言（如 Solidity）和开发工具，以及合约的部署和调用方法
            - 去中心化应用设计：Web3 应用需要具备去中心化的特点，开发者需要了解去中心化应用的设计原则、用户体验和开发流程等
            - 分布式存储技术：Web3 应用通常需要使用分布式存储技术来存储和管理数据，开发者需要了解常见的分布式存储方案，如 IPFS
          - 以太坊是 Web3 中应用最广泛的区块链平台，学习以太坊的白皮书是了解区块链和智能合约的重要基础
            - [以太坊白皮书](https://ethereum.org/zh/whitepaper/#decentralized-file-storage)
            - Solidity 官方文档：Solidity 是以太坊智能合约的编程语言，学习 Solidity 官方文档可以快速入门智能合约的编写和部署
            - Web3.js 官方文档：Web3.js 是以太坊 JavaScript API，学习 Web3.js 官方文档可以了解如何使用 JavaScript 与以太坊进行交互
            - https://ethereum.org/zh/
    - 计算机
      - 数据结构与算法
      - 计算机组成原理
        - https://csapp.cs.cmu.edu/3e/home.html
      - 编程语言
      - 编译原理
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/编译原理实战课
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/编译原理之美
        - TODO: file:///Users/lianyuansheng/GitHub/爬取极客时间课程/download/手把手带你写一门编程语言
        - https://sarabander.github.io/sicp/html/index.xhtml
        - [Introduction to Compilers and Language Design](https://www3.nd.edu/~dthain/compilerbook/)
      - 操作系统
        - https://pages.cs.wisc.edu/~remzi/OSTEP/
      - 计算机图形学
      - 计算机网络
      - 数据库
      - 资料
        - https://github.com/izackwu/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8
    - 人工智能
      - TODO: 了解人工智能 AI、机械学习 ML、深度学习 DL、大模型 MML
      - TODO: LLM 应用
      - TODO: 探索豆包使用
      - TODO: ocr 服务s
    - 数学
      - 微积分、概率与统计、随机过程



## 房

- 押金 5w
- 维修基金 10094
- 律师费 2960
- 首付
  - 父母 860025
  - 老二 10w
  - 老小 10w
- 每月还贷
  - 11898.76（2023.10.1 - 至今）
    - 老二 还至 2023.3.1
  - 12998（2022.8.1 - 2023.9.1）
  - 13288.48（2021.8.1 - 2022.7.1）
- 房税+面积差价
- 装修

## Web 应用开发

- Web 应用开发
  - 工作原理
    - 请求 -> 中间件 -> 服务、RPC -> 数据库 -> UI 渲染
  - RPC
    - 序列化
      - API
        - RESTFul
          - 基于 http 特性的架构
            - 资源请求
              - **将接口以资源的形式表达**
            - 请求独立性
            - 无状态
          - 解决互联网级别的信息共享和互操作问题。写接口的目标各自不同。而REST的目标是“实现互联网级别的信息共享系统”
            - “开放接口”。因此可以看到有些开放接口用REST实现还是很不错的，比如github的接口，AWS S3的接口等。
          - [前后端接口规范 - RESTful 版](https://github.com/olivewind/restful-api-specification)
        - JSON-RPC
        - protobuf
      - 序列化原理
    - 传输协议
    - 服务注册和服务发现
  - 中间件
    - WAF 防火墙
    - DNS
    - CDN
    - 消息队列
    - 缓存系统
      - Redis
    - 安全框架
      - 用户认证及授权
      - HTTPS
      - Web
        - CSRF（跨站请求伪造）保护
        - CORS（跨源资源共享）配置
        - 安全头部和内容安全政策
          - 了解如何配置 HTTP 安全头部，如 HSTS、X-Frame-Options。学习内容安全政策（CSP）的基本原理
          - Helmet
    - 搜索引擎
      - Elasticsearch
    - 日志框架
    - API 网关
      - 请求路由
      - 反向代理
      - API聚合
      - 服务发现
      - 负载均衡
      - 限流和熔断
  - Web 服务
    - 参数验证
    - URL 路由
  - 测试
    - 压测 http 服务（ab）
      - QPS
      - 吞吐率
  - 后端
    - 高并发
    - 数据库，网络
    - 业务本身
      - 依赖后端人员对业务的理解来设计架构，拆分业务
    - TODO: fastify ts react prisma pg
      - Prisma 从数据库模型中为后端应用程序生成类型，而 tRPC 则从后端为前端 API 层维护类型安全
      - tRPC 使用 JSON-RPC 作为规范，HTTP 作为传输层
  - 性能优化
    - 数据库
      - 索引
      - 分库分表
    - 请求
      - RPC 链路优化
      - 限流
      - 缓存
      - 负载均衡
    - 服务

## 其他

- 音视频
  - [freeswitch](https://github.com/signalwire/freeswitch)
  - - 输入
    - 输入源可以是物理设备，例如麦克风、网络摄像头或来自用户硬盘或远程网络对等点的本地或远程文件。
  - 媒体流
  - 元素、RTC
  - TCP 传送可靠、有序的数据流：如果中间数据包丢失，则 TCP 会缓冲其后的所有数据包，等待重传，然后按顺序将数据流传送给应用程序
  - 不保证交货顺序
  - 没有确认、重传或超时
  - 无连接状态跟踪
  - 无拥塞控制
  - 信令服务
    - 会话发起协议 (SIP)
  - 连接建立后，应用程序仍然可以在 RTCPeerConnection 对象中添加和删除流。每次发生这种情况时，都会调用自动 SDP 重新协商，并重复相同的初始化过程。
- Cloudflare
  - DNS
  - CDN
  - SSL
  - DDOS防护
  - Cloudflare Pages
  - Cloudflare Workers
  - R2
  - Cloudflare Tunnel
  - Images
- 内网服务外网用
  - 动态公网 IP + DDNS
  - 内网穿透
  - IPv6
- 低代码
  - 表单数据描述模型
  - 表单 UI 描述模型
  - `表单设计器 => 表单 UI 描述模型 => 表单渲染器 => [UI 模型(VNode) => Vue Render =>] UI`
    - 表单 UI 描述模型
      - 表单组件描述
      - 交互逻辑描述
        - 数据校验
          - 必填
          - 大小
          - 格式
          - 联动数据校验
        - 错误提示
  - `表单 UI 描述模型 => 表单数据描述模型`
    - 表单数据描述模型
  - `表单数据描述模型 => 数据模型校验器 check 数据`
  - `表单数据描述模型 => 表格 UI 模型描述 => 表格渲染器 => [UI 模型(VNode) => Vue Render =>] UI`
  - 其他
    - [JSON Schema](https://json-schema.org/)
    - JSON Schema 验证器：[ajv](https://github.com/ajv-validator/ajv)



## 项目、框架、架构、模式

- Admin 系统模块
  - 列表
  - 表单
  - 权限设计
  - 登陆验证
  - 工作流
- 发布 - 消费 - 生产
- 软件架构
  - 业务架构
  - 代码架构
    - 解耦、分离责任
      - 抽象
    - 分层架构
      - 用户界面（UI）：负责与用户进行交互。
      - 应用层
      - 业务逻辑层（BLL）：表示业务概念。它定义了应用程序的行为，使其与其他应用程序独特区别开来。
      - 数据访问层（DAL）：在内存中持久化数据并维护应用程序的状态
    - DDD（领域驱动设计）
  - 物理架构
- 前端业务
  - 用户与UI交互
  - 后端交互
  - 业务逻辑数据处理
  - UI 渲染
- Pina、状态管理设计
  - 状态分类
    - 组件级
      - 通信
        - 父子
        - 跨组件
          - 提升
          - 单例
        - 原生
          - label+for
          - dispatchEvent 和 addEventListener
    - 页面路由级/业务级
      - 栈
    - 应用会话级
      - 全局状态
  - 异步加载
  - 生命周期
- Vue
  - [深入理解单文件组件编译](https://www.bilibili.com/video/BV1Zb421n7dR/?spm_id_from=333.788&vd_source=5e3f59e2a50994ae58323e0f75a50d48)

## 计算机技术栈

- 计算机技术栈
  - 领域
    - Web
      - HTML/CSS
      - WebAPI
        - [ ] PWA：博客 + PWA
      - HTTP
        - [ ]《透视 HTTP 协议》
        - [图解 QUIC 连接](https://cangsdarm.github.io/illustrate/quic)
      - 浏览器
        - [ ] 《浏览器原理及实践》
      - 前端框架及工程化
        - [Vue](./前端框架/README.md)
        - React
        - [前端工程化](./content/前端工程化/README.md)
      - Web 服务
        - [NodeJS 服务开发](./NodeJS)
      - 音视频
        - [ ] 《从 0 打造音视频直播系统》
      - 图表
      - 可视化
        - [I want to talk about WebGPU](https://cohost.org/mcc/post/1406157-i-want-to-talk-about-webgpu)
    - 容器
      - [ ] 《Kubernetes 入门实战课》
  - 软件设计及架构、软件工程及软件工具
    - 软件设计及架构
      - [ ]《软件设计之美》
    - 软件工程及软件工具
      - DevOps
      - Git
      - [SSH](./软件设计及架构、软件工程、软件工具/SSH.md)
        - [ ] [ssh-tutorial](https://github.com/wangdoc/ssh-tutorial)
  - 程序设计语言与实现原理、编译原理
    - [JavaScript](./JavaScript/README.md)
      - [ ] 《JavaScript 核心原理精讲》
      - [ ] 《ES6 入门教程》
      - Typescript
    - Rust
      - [ ] [《Rust 程序设计语言》](https://kaisery.github.io/trpl-zh-cn/title-page.html)
      - [ ] 如何用 napi-rs 搭建一个 Node.js 可以调用的 Rust 库
      - [ ] WebAssembly + 前端
      - [ ] Rust CLI
    - 语言实现原理、编译原理
      - [ ] https://craftinginterpreters.com/contents.html
      - [ ] 《手把手带你写一门编程语言》
      - SICP
        - [ ] https://sourceacademy.org/sicpjs/acknowledgements
        - [MIT 计算机程序的构造和解释](https://github.com/DeathKing/Learning-SICP)
        - [Berkeley 的 61A 课程](https://www.bilibili.com/video/av40460492/?vd_source=5e3f59e2a50994ae58323e0f75a50d48)
      - [《程序语言理论与实现》](https://bobzhang.github.io/courses/)
      - 《编译原理》龙书
      - https://www.edx.org/course/compilers
  - 计算机基础
    - 计算机网络
      - [ ] 《计算机网络通关 29 讲》
      - [ ] 《趣谈网络协议》
      - [ ] 《计算机网络-自顶向下方法》
      - [The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm)
        - RFC：https://datatracker.ietf.org/doc/rfc1644/
    - 操作系统
      - [ ] 《重学操作系统》
      - [ ]《趣谈 Linux 操作系统》
      - 《现代操作系统：原理与实现》
    - [数据结构与算法](./数据结构与算法/README.md)
      - [ ] leetcode 200 道
      - [ ] 《数据结构与算法之美》
      - [ ] 《算法面试通关 40 讲》
      - [ ] [Hello 算法](https://www.hello-algo.com/)
    - 计算机组成原理
      - [ ]《程序是怎样跑起来的》
      - [ ] https://www.bilibili.com/video/BV1iW411d7hd
  - 数学与应用

## 编程语言

- 概览
  - 语言
    - 语法学习
    - 语言设计与实现
  - 语言工具
    - 代码风格及质量 formatter、linter
    - 包管理
    - 调试工具
    - 测试工具
    - 构建工具
      - resolver
      - 编译
      - link
      - minifer
  - 库、框架：面向领域开发的工具
  - 工程化
- 软件工程
  - 项目管理
  - 语言工程
    - 代码管理 Git
    - 语言工具
  - 软件开发
    - 分析
    - 设计
    - 编码
    - 测试
      - 单元测试
      - 端对端测试
  - 运行部署
    - devop
    - CICD
  - 监控优化
    - 服务监控
      - 错误监控
    - 性能监控
      - CPU Usage
      - Memory Usage
      - Disk Usage
      - Network Usage
    - 日志上报
- 语言学习路线
  - 了解
    - 历史现状
    - 思想特点
    - 缺陷
  - 基础
    - 变量、值和类型
      - 动态语言
        - 运行检测类型
        - 动态赋值
      - 类型
        - 基本数据类型
        - 复合数据类型
          - 结构体及方法
          - 引用类型
            - 接口类型
      - 枚举：枚举类型本质上就是一个由有限数量常量所构成的集合
    - 运算符、表达式、语句
      - 表达式：计算
      - 语句
        - 控制
        - 赋值
    - 函数
      - 将大问题分解为若干小任务与代码复用
    - 程序结构
      - 代码块和作用域
        - 作用域是一个编译期的概念，也就是说，编译器在编译过程中会对每个标识符的作用域进行检查，对于在标识符作用域外使用该标识符的行为会给出编译错误的报错
        - 静态作用域、动态作用域
        - 变量重声明
          - 同名变量遮蔽问题
      - 模块系统
    - 内置数据结构
  - 错误处理
    - 错误的处理流程
      - 生成表达
      - 传递、捕获
      - 处理
        - 忽略
        - 反馈给用户
        - 重试
        - 记录错误日志
    - 语言的错误处理机制
      - 错误码 + 返回值
        - 错误码机制，容易忽略错误，需要显式的传播和捕获 ❌
        - 错误返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
          - 可类似 Golang **多值**返回，区分开错误返回和正常返回
      - 异常抛出
        - 异常可以通过栈回溯（stack unwind）被一层层自动传递，直到遇到捕获异常的地方，如果回溯到 main 函数还无人捕获，程序就会崩溃
          - 异常看成一种关注点分离（Separation of Concerns）：错误的产生和错误的处理完全被分隔开，调用者不必关心错误，而被调者也不强求调用者关心错误
          - 使用异常来返回错误可以极大地简化错误处理的流程，它解决了返回值的传播问题
      - 错误类型 + 返回值
        - 错误类型提示，强制显示处理
        - 继承扩展 Error 接口类型
          - 根据自定义错误类型或者错误行为做决策处理
            ```js
            // 错误类型
            if( xxx instanceof XxxError) ...

            // 错误行为
            error.ifNoAuth(callBack)
            ```
    - 实践原则
      - 遇到错误，**停止执行，异常反馈**
      - 尽量不要忽略任何一个异常
        - 错误类型化，通过类型系统检查 ✅
      - 区分错误和异常
      - 将正确逻辑和错误处理分隔开
        - 比如 `try-catch`、模式匹配 `match` 等语法机制
      - 异常抛出
  - 接口
  - 并发、异步
    - 并发编程
      - 异步编程
        - 语言层面实现的并发模型 + 异步运行时
      - 多线程编程
    - 并发模型
      - 线程模型
        - *基于系统线程的多线程*
          - 线程数量限制
          - 线程切换消耗
        - 协程（用户线程）
      - 事件驱动模型
        - 事件循环 + 回调队列
    - 并发设计
      - 并发模型
      - 编排调度
      - 协同：并发 -> 数据共享 -> 状态竞争 -> 同步通信
        - 同步原语（互斥锁、条件变量、读写锁）
          - 死锁
    - 异步能力
      - 上下文切换和现场保存工作
      - 事务
        - 逻辑完整性
        - redo/undo
  - 泛型
  - 元编程
    - 宏编程
    - 反射
  - 语言互操
    - FFI 外部函数接口（foreign function interface）
    - IPC 进程间通信（inter-process communication）
  - 指针操作
- 语言设计与实现
  - 编译原理与运行时实现
  - 运行机制
    - 编译方式
    - 解释方式
    - IR + 虚拟机
  - 变量的内存结构
    - 内存布局结构
      - 函数调用栈
      - 动态数据堆
      - 静态区
        - 代码
        - 常量
    - 内存对齐
  - 垃圾回收
  - 代码复用
    - 代码拷贝
    - 代码指针
      - 指针拷贝
      - 委托
        - 隐式 继承
        - 显示 组合
- 软件分类
  - 业务应用系统
  - 嵌入式软件
  - 工具应用软件
  - 基础软件
- 应用开发
  - shell
    - glob 语法
      - `*`：任何路径段
        - 星号不匹配名称以点开头的“不可见文件”，如果我们想匹配这些，我们必须在星号前加上一个点：`.*`
      - `**`：匹配零个或多个路径段
      - `!`：排除
      - `\{xx,xx\}`：可选匹配
  - 二进制操作、编解码
  - 字符串、文本操作
    - 文本
      - 字符串拆分成行
        - RE_SPLIT_EOL = /\r?\n/;
        - /(?<=\r?\n)/
    - 文本编码
      - Unicode
        - Unicode 只是一个符号集，它只规定了符号的二进制代码
      - 二进制存储格式编码
        - UTF-8
          - 一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度
      - 阅读推荐
        - [字符编码笔记：ASCII，Unicode 和 UTF-8](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
  - 协议、编译原理
  - 操作系统交互
    - 可执行程序
      - shell 脚本
      - 二进制可执行程序
    - I/O
      - 网络
      - 文件
        - 软连接
          - 实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息
          - A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。
    - IPC
      - 命名管道
      - Unix Domain Sockets
      - Unix 信号
      - 消息队列
      - 共享内存
      - 内存映射文件
      - I/O 文件（文件和 TCP 套接字）
- 性能优化
  - CPU 计算
    - 减少不必要的计算
    - 空间换时间，即缓存计算结果
    - 提高计算能力
    - 并发，多进程、多线程
  - 内存
    - 减少内存使用
    - 防止内存泄漏
    - *注意内存安全*
- 编译原理
  - 前端
    - parser
      - lexer
      - ast
    - traverser
      - processor
      - verifier
    - codegen
- 软件指标
  - 功能性
  - 性能性
  - 可用性
  - 编码：可维护性和可扩展性指标
  - 安全性
- 编程范式
  - 程序 = 数据 + 算法
  - 面向对象：对象 = 属性 + 行为
  - 函数式：计算表达式
  - （函数）响应式：数据流
  - 结构化编程
    - 无 goto，控制结构：限制使用 goto 语句，**对程序控制权的直接转移施加了约束**
    - 调用栈、局部变量和按值传递：提高子程序独立性
    - 功能化分解：结构化程序设计本质上还是一种面向过程的设计思想，但通过“自顶向下、逐步细化、模块化”的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度
      - 缺点
        - 自定而下功能分解，这种结构下模块具有**强依赖性**、**抽象性不够**：一旦需求变动，经常是牵一发而动全身，关联的模块由于依赖关系的存在都需要变动，**无法有效隔离变化**
        - **可测试性不够**
    - 有两个无法解决的问题，那就是全局变量问题和可重用性差的问题

## 其他


- VSCode & 项目配置工具
  - [Vue](https://github.com/vuejs/language-tools)
    - [Vue Language Features (Volar)](https://marketplace.visualstudio.com/items?itemName=Vue.volar)
    - [TypeScript Vue Plugin (Volar)：支持在 TS 文件中引入 Vue 单文件组件](https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin)
      - [Volar Takeover 模式：项目只用 Vue 的 TS 语言服务实例](https://cn.vuejs.org/guide/typescript/overview)
    - [Vue VSCode Snippets](https://marketplace.visualstudio.com/items?itemName=sdras.vue-vscode-snippets)
    - 组件文档
      - [vue-component-meta](https://github.com/vuejs/language-tools/tree/master/packages/component-meta)
      - [vite-plugin-vue-component-preview](https://github.com/johnsoncodehk/vite-plugin-vue-component-preview)
  - Typescript
    - 只启用项目 TS 
  - JS
    - [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
  - 格式化
    - [Prettier - Code formatter](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)








- 亮点
  - 看你项目规模，业务领域，用户量，创造效益，是否使用哪些组件框架，哪些进行定制化改造
  - 我一般面试中意的公司都会看一下他们公司干嘛的  项目有啥需求 往他招人的需求方向上扯犊子







- 依赖说明符
  - 相对说明符
  - 目录索引文件
    - package.json
    - index.js 或 index.ts
  - 裸说明符/包
    - node_modules 目录从导入文件向上搜索。搜索停止于项目根目录
    - 包子路径
      - 文件
      - 目录
  - 内置模块
  - 绝对说明符
    - 绝对说明符以 / 开头，并解析相对于项目根目录的文件。
  - 波形符说明符
    - 波形符说明符以 ~ 开头，并相对于导入文件中最近的包根进行解析
  - 哈希说明符




- vue
  -  @vue/reactivity
  -  Vue.js 3.0 在设计内建组件和模块时也花费了很多精力，配合构建
工具以及 Tree-Shaking 机制，实现了内建能力的按需引入，从而实现
了用户 bundle 的体积最小化
  - 特性开关
  - 可以编写自定义的渲染器，甚
至可以编写编译器插件来自定义模板语法
- 框架设计
  - 警告、提示信息、美化信息
- 想要实现 Tree-Shaking，必须满足一个条件，即模块必须是
ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构
- /*#__PURE__*/ 注释
  -  JavaScript 是一门动态语言，通过纯静态
分析的手段进行 Tree-Shaking 难度较大，因此大部分工具能够识别
/*#__PURE__*/ 注释，在编写框架代码时，我们可以利用
/*#__PURE__*/ 来辅助构建工具进行 Tree-Shaking。
- 错误处理
  - callWithErrorHandling：
- 组件
  - 虚拟 DOM 和渲染器
    - 渲染器的作用是，把虚
拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚
拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染
器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会
更新需要更新的内容。后面我们会专门讲解渲染器的相关知识
  - 渲染函数
  - 组件
  - 渲染
器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函
数并得到其返回值，我们称之为 subtree，最后再递归地调用渲染器
将 subtree 渲染出来即可
- 响应式系统
  - 响应式数据、副作用
    - WeakMap、Map 和 Set 
      - map =》 target keymap
      - keymap =》 set
  - 分支切换与 cleanup
    - 解决这个问题的思路很简单，每次副作用函数执行时，我们可以
先把它从所有与之关联的依赖集合中删除
  - 嵌套的 effect 与 effect 栈
  - 避免无限递归循环
  - 调度执行


```
01 // 定义一个任务队列
02 const jobQueue = new Set()
03 // 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加
到微任务队列
04 const p = Promise.resolve()
05
06 // 一个标志代表是否正在刷新队列
07 let isFlushing = false
08 function flushJob() {
09 // 如果队列正在刷新，则什么都不做
10 if (isFlushing) return
11 // 设置为 true，代表正在刷新
12 isFlushing = true
13 // 在微任务队列中刷新 jobQueue 队列
14 p.then(() => {
15 jobQueue.forEach(job => job())
16 }).finally(() => {
17 // 结束后重置 isFlushing
18 isFlushing = false
19 })
20 }
21
22
23 effect(() => {
24 console.log(obj.foo)
25 }, {
26 scheduler(fn) {
27 // 每次调度时，将副作用函数添加到 jobQueue 队列中
28 jobQueue.add(fn)
29 // 调用 flushJob 刷新队列
30 flushJob()
31 }
32 })
33
34 obj.foo++
35 obj.foo++
```









- 简历
  - 明确的职业目标
    - 寻求高级工程师角色，能够运用我经过验证的能力来交付规模化服务，为业务带来有价值的创新
  - 只描述活动而非成果
    - 在 Project X 中编写 Java 代码，实现了几个关键的微服务，使其能够支持企业环境，从而吸引了几个关键的新客户购买产品
  - 未能展示个人对团队或业务的影响
    - 简历应该展示求职者如何为团队、产品或业务底线带来积极变化。
    - 强调个人贡献和领导力，而不仅仅是职责描述
  - 提升简历质量的小技巧
链接到具体的项目或成果，以增加可信度。

使用粗体字突出最重要的成就。

使用强有力的动词来描述成就，如 “拥有”、“构建”、“推动” 或 “交付”。

在可能的情况下，包含具体的数字和金钱价值来量化成果。

- Promise
  - [[PromiseState]]、[[PromiseResult]]、[[PromiseIsHandled]]、[[PromiseFulfillReactions]] 和 [[PromiseRejectReactions]]
- 正则
  - 字符类
  - 范围
  - 或:
  - 量词
  - 分组
    - 反向引用
      - number
      - name
    - 断言







- TypeScript 
  - 类型系统
    - 集合特性
      - never 空集
      - & 交集
      - | 并集
      - extends 检查一个集合是否是另一个集合的子集
      - {
  [key: string]: boolean | number;
}
    - 类型层级
  - 类型编程
    - 泛型
      - 类型参数
        - 当使用类型参数时，TypeScript 决定分别对联合的每个成员执行子集检查，而不是首先将联合解析为构造的集合
          - type Result = IntrospectT<number | string>;
          - type Result = IntrospectFoo<number> | IntrospectFoo<string>;
          - 元组语法强
    - 条件
      - ?:
    - 类型映射
      - infer
        - ```ts
          type InsideArray<T> = T extends Array<infer R>
            ? R
            : "T is not a subset of Array<unknown>";
          type TheNumberInside = InsideArray<Array<number>>;
          // TheNumberInside = number
          ```
          ```
          type SetToMapOver = "string" | "bar";
          type FirstChacter<T> = T extends `${infer R}${infer _}` ? R : never;
          type Foo = {
            [K in SetToMapOver as `IM A ${FirstChacter<K>}`]: FirstChacter<K>;
          };
          ```
      - in
    - 递归
  - 类型推导






- 为什么说HTTP是无状态的协议呢？因为它的每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更








- JS
  - 函数
    - 作用域链
    - 闭包
  - 对象
    - 原型
      - 原型链
    - 面向对象
      - instanceof 运算符原理及实现
      - new 运算符原理及实现
      - 原型继承
  - 异步
    - 递归 setTimeout: 模拟 setInterval
    - 手写 EventEmitter
  - API
    - 正则
      - String.prototype.replace(pattern, replacement)
        - replacement
          - replacer(match, p1, p2, /* …, */ pN, offset, string, groups)
    - 数组
    - 字符串







- `new Function`
  - `new Function ([arg1, arg2, …argN], functionBody)`
  - 上下文是全局的
  - 场景：动态生成代码、计算


- Q640】如何实现数组函数 reduce #658
- const reduce = (list, fn, ...init) => {
  let next = init.length ? init[0] : list[0]
  for (let i = init.length ? 0 : 1; i < list.length; i++) {
  next = fn(next, list[i], i)
  }
  return next
  }
- 什么是防抖和节流，他们的应用场景有哪些
- 实现一个数组扁平化的函数 flatten
- const flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])
- 如何实现一个深拷贝 (cloneDeep)







- Rest 参数与 Spread 语法
  - spread 语法这样操作任何可迭代对象
  - Array.from 适用于类数组对象也适用于可迭代对象。
Spread 语法只适用于可迭代对象






- HTTP 协议是无状态的，也就是说每次请求和响应之间是没有关联的，服务器不会记住之前的任何信息，所以会导致每次请求都要重新建立连接





- 内存泄漏
  - 内存泄漏的本质是：**没有及时释放不再使用的内存**
  - 常见的内存泄漏
    - 全局变量
    - 闭包
    - 定时器
    - 事件监听
    - 循环引用
  - 如何避免内存泄漏
    - 减少全局变量
    - 减少闭包
    - 减少定时器



- React
  - 设计理念
    - 数据驱动视图
      - UI = f(data)
    - data = state
    - f = 组件
      - 组件即函数 范式
      - **为什么 React 要推崇函数式组件？**
        - react 原生的响应式方案是非常依赖数据不可变性的，函数式编程理念与 react 更为接近
        - 隐藏 state、分离 state
          - 函数执行的上下文、每次执行 state 都只是一次映射
  - React 模式
    - 代码重用
      - 高阶组件（HOC）
        - 高阶组件和 render props 
          - 嵌套地狱
      - Render Props
      - React Hooks
        - 闭包陷阱
    - 容器组件/展示组件
      - “关注点分离”
  - Hooks
    - Hooks 的使用规则
      - 只能在 React 的函数组件中调用 Hooks
      - 只能在组件函数的最顶层调用 Hooks
      - FiberNode 上会保存一个记录 Hooks 状态的单向链表，链表的长度与执行组件函数时调用的 Hooks 个数相同
    - 组件状态：useState、useEffect、useContext、useReducer
    - 性能优化 Hooks：useMemo 和 useCallback
    - 当需要封装组件，对外提供命令式接口时，学习掌握 useRef 加 useImperativeHandle
    - 当页面上用户操作直接相关的紧急更新（Urgent Updates，如输入文字、点击、拖拽等），受到异步渲染拖累而产生卡顿，需要优化时，学习掌握 useDeferredValue 和 useTransition 
  - React 原理
    - 并发渲染
      - 运行时用 Fiber 架构重写不依赖原生调用栈，这使 React 能够在渲染阶段暂停工作以允许浏览器处理事件
      - Hooks 解决 Class API 在纯度上约束力不够的问题；不纯的组件在 React 并发模式下很容易出现数据竞态（data race）的问题
    - 渲染原理
      - 虚拟 DOM
        - **why React 为什么要使用虚拟 DOM？**
          - 为了可以使用声明式的程序代码来描述你的 UI，以及跨平台的能力
          - 减少 DOM 操作
            - 相比过去全量更新，React 只更新变化的部分
      - 虚拟 DOM 的 diff 算法
        - 同层对比
        - type 变了就不再对比子节点
        - 移动：复用元素、尽量减少创建新元素
          - 判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的
          - 每个节点都是有唯一的标识 key，利用 key 复用
          - vue2 双端对比、vue3 最小递增子序列
    - 更新
      - 异步、批量更新
      - 更新调度
        - 时间切片
      - 渲染更新
        - React 循环遍历整个组件树，查找标记为更新的组件
        - 对于每个标记的组件，从它开始，React 将递归渲染其中的所有子组件
          - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件
    - 事件系统
- React VS Vue
  - 阿里三面：灵魂拷问——有 react fiber，为什么不需要 vue fiber 呢？
    - vue 基于数据劫持 + 编译优化，能够更加精确更新
    - why react fiber
      - 在数据更新时，react 生成了一棵更大的虚拟 dom 树，给第二步的 diff 带来了很大压力，树的递归过程没法暂时停止，阻塞用户响应
      - diff 过程切片，react fiber 使得 diff 阶段有了被保存工作进度的能力
        - 为什么有了 react fiber 就能断点恢复呢；
          - fiber 是链表结构，只要保留下中断的节点索引，就可以恢复之前的工作进度；
  - Vue 与 React 框架的对比
    - 范式
    - 生态
    - 原理


- CSS
  - 样式方案
    - CSS Modules
    - CSS-in-JS
      - emotion
      - [styled-jsx](https://github.com/vercel/styled-jsx?tab=readme-ov-file#how-it-works)
    - Atom CSS
  - 主题切换
    - 主题生成：CSS 原生变量/预构建 + 样式覆盖
    - 切换触发
      - 跟随系统偏好
        - `prefers-color-scheme`
        - `window.matchMedia("(prefers-color-scheme: dark)").matches`
      - 切换模式
        - `class.dark`
        - `[data-theme]=dark`
      - [支持系统偏好和手动选择](https://tailwindcss.com/docs/dark-mode#supporting-system-preference-and-manual-selection)
        - https://color-mode.nuxtjs.org/






- 前端架构
  - 视图
    - MDV
    - 组件化
      - 组件是对视图以及与视图相关的逻辑、数据、交互等的封装
      - **组件拆分**并无唯一标准。拆分时需要你理解业务和交互，设计组件层次结构（Hierarchy），以关注点分离（Separation Of Concern）原则检验每次拆分。
      - 组件复用
        - **前端框架的组件是应用构成基本单位，而不是逻辑复用的最小单位**：组件包含视图渲染逻辑和状态交互逻辑，比如在某些业务场景下，视图一样但面对用户角色不同需要的业务交互逻辑不一样；反之，同样的业务逻辑在移动端和 PC 端表现的视图又不一样的情况
        - **视图组件、逻辑组件**
      - 视图驱动、组件优先的开发模式
        - 在前后分离的模式下，**大多数前端业务开发流程都是以视图驱动为主**，并且在前端框架**组件**概念的设计下，形成了以**组件优先**的开发模式:
          - 先根据 UI 稿子拆分成组件、面向组件写页面
          - 再根据原型文档与接口完成业务交互
        - 在视图驱动下，State 是围绕 View 的消费和交互需求而产生的，View 是组件真正核心的部分，这就导致在视图组件里编写越来越多的代码，并成了一个流行趋势，**组件同时承载了界面逻辑和业务逻辑**
  - 组件驱动下的前端状态管理
    - 组件化
      - Component Tree => state tree + 单向数据流
      - 通信困难：整个应用最终以组件树的形式组织展示，组件封装状态逻辑，逻辑自治，但分散在组件树，树形结构阻碍了组件数据通信
        - 状态提升、分层
          - 容器模式
          - 单向数据流
    - 全局化
      - 状态与 UI 的分离
        - 状态逻辑分离
        - UI = f(state)，单向数据流 state -> UI
      - 全局状态的生命周期管理很麻烦
        - DI、DI 组件
        - 状态分层
    - 职责分类：业务状态、UI 状态、应用状态
      - 业务状态倾向于放到高层模块里
      - UI 状态作为 UI 的映射关系适合放到组件等局部状态里
      - 应用状态则作为全局状态
  - 项目架构
    - MVC
    - MV*、前后分离
      - View：展示数据、用户交互
        - Event => Logic => State => UI => Event => ...
          - **事件驱动业务逻辑**：人机交互的业务逻辑本身，是【针对人的行为做出反馈】
          - **数据驱动视图**
      - Store：存储应用状态和状态逻辑
      - Servcie：后端接口交互
        - Model 贫血的 data
  - 组件样式
    - 组件级别的样式隔离
    - 组件样式需要响应组件数据变化
  - UI 组件库
    - 设计体系
    - 主题定制
  - 微前端
  - SSR
    - 状态
      - 多例
    - 客户端同步








- hr
  - 你觉得你最大的缺点是什么?




- HTTP/0.9
  - request 只有一行且只有一个 GET 命令
- HTTP/1.0
  - 增加状态码
  - 在 request 和 response 中添加 header 的概念
  - 在 header 中添加 content-type 以此可以传输 html 之外类型的文件
  - bad
    - http 队头阻塞
    - 短连接
- HTTP/1.1

  - 长链接 keep-alive
  - chunked 机制，分块响应
  - 缓存控制
  - 内容协商，包括语言、编码和类型，客户端和服务器现在可以就交换哪些内容达成一致
  - 请求头域中新增了 Host 字段：处理一个 IP 地址上面多个虚拟主机



- 为什么 0.1+0.2 不等于 0.3？
  - 解决
- 如何判断一个值是不是数字




- - 依赖安装
  - 最新兼容
- Monorepo
  - 依赖管理
  - 任务管理
    - 任务编排
      - 串行
      - 并行
      - 拓扑结构
    - 版本发布
      - 同步
      - 独立
  - 代码管理
- PNPM
  - 幻影依赖
  - 安装速度快、节省磁盘
  - 依赖提升算法 不稳定性



- 将 table / list 抽象，用类似 scheme 驱动的方式
- ui 都有差异,在设计层面，可能由于业务需求，很难做到统一，不得已自带设计体系
- 后端数据模型没有统一，因此对接数据前后涉及到的前端状态管理、数据流转也未能统一，复用性大打折扣。


- css
  - bfc 布局规则
- js
  - 说一下原型链，原型链实现继承。
  - vue 中 nextTick 的实现，结合浏览器事件循环机制说一下？
  - 说说 commonjs 和 esmodule？
  - 手写简版 promise，基础架子，不用写 all、race 等 api
  - 手写 bind
- 框架原理
  - vue 模板编译原理
- http
  - http 和 tcp 协议？
  - 缓存相关（对比缓存？强缓存？对应请求头）
  - cookie 有哪些属性？
  - options
  - 简单请求？
  - 跨域？
- 浏览器
  - 为甚么要有同源策略？dns 劫持？
  - 渲染原理
- 算法
  - 回文字符串个数
  - 猴子吃香蕉
  - 爬楼梯
  - 最长公共子串
- 项目
  - 项目怎么做的移动端适配？
    - flexible 原理
    - 移动端的 1 像素问题怎么解决
  - 团队协作，以前的开发流程？
- 其他
  - 职业规划？
  - 有什么问题吗？
  - 为什么要离职？
  - 怎么学习的？








- 拆分-按需加载
- 缩小
  - 混淆
  - 代码升级
  - Removing unused code.
    - DevTools code coverage.
    - analysis of their webpack bundles
- 压缩
- 缓存
  - http
  - V8’s code cache
- PRPL（推送、渲染、预缓存、延迟加载）是一种通过积极的代码拆分和缓存来优化互动的模式：



- 正则
  - 分割行而不包含行终止符 str.split(/\r?\n/)
  - 分割行同时包含行终止符 /(?<=\r?\n)/
  - 多行文本消除首尾**空白符**：`string.replace(/^\s+|\s+$/g,"")`
  - js 正则相关 api
- 框架 xss 防范
  - xss
    - js
    - 拼接 HTML + encode
  - script
    - 逃逸



- HTTP 缓存
  - 浏览器发出的所有 HTTP 请求首先会转至浏览器缓存，用于检查是否存在可满足请求的有效缓存响应。如果存在匹配，则从缓存中读取响应，从而消除网络延迟和传输产生的数据成本。
  - HTTP 缓存的行为由请求标头和响应标头的一起控制
  - 策略
    - 版本化 URL 的长期缓存
    - 非版本化 URL 的服务器重新验证
  - 通过设置 ETag 或 Last-Modified ，您可以让重新验证请求更加高效。它们最终会触发在请求标头中提到 If-Modified-Since 或 If-None-Match 请求标头。







- 构建DOM树；
样式计算；
布局定位；
图层分层；
图层绘制；
合成显示；
- 在CSS属性改变时，重渲染会分为“回流”、“重绘”和“直接合成”三种情况，分别对应从“布局定位”/“图层绘制”/“合成显示”开始，再走一遍上面的流程。


- Typescript 项目架构
  - 构建
    - AST
      - [ts-morph](https://github.com/dsherret/ts-morph)
    - 类型加载
      - [typesync](https://github.com/jeffijoe/typesync)
    - 类型工具
      - [type-fest](https://github.com/sindresorhus/type-fest)
    - 类型检查
      - [ezno](https://github.com/kaleidawave/ezno)
    - 运行时类型检查
      - [tsd](https://github.com/SamVerschueren/tsd)
      - [zod](https://github.com/colinhacks/zod)
    - 类型生成
      - [quicktype](https://github.com/quicktype/quicktype)
    - JSDoc
      - [JS Projects Utilizing TypeScript](https://typescriptlang.org/docs/handbook/intro-to-js-ts.html)
  - 类型查找
    - 模块
    - tsconfig
  - TS 只做类型功能，由其他编译器编译代码、消除类型
    - ts
      - tsconfig
        - Language and Environment
          - target
          - lib
        - Modules
          - module node
          - moduleResolution
          - allowSyntheticDefaultImports
          - "declaration": true,
      - package.json
        - "type": "module"
          - 路径名-扩展名 写全
        - exports
          - 将目录映射到文件
            - "./util": "./dist/src/util/errors.js"
  - 类型声明文件 d.ts
    - 类型声明
    - 变量声明：用来告诉编译器，某个类型的变量的存在，可以在当前文件中使用
    - 声明增强：为外部模块扩展新的类型或类型声明合并
  - 类型系统
  - 题目
    - type 和 interface 区别
    - any、unknown 和 never 区别
