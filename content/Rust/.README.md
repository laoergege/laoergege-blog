---
discussionID: 4VRzUDnXN1BHHx8QIV1zE
tags:
 - rust
---

# Rust

- Rust
  - 设计理念
    - 安全（类型安全、内存安全、并发安全）
    - 性能（零抽象）
    - 多范式编程
    - 划分 Safe rust 和 Unsafe Rust（方便与其他语言沟通）
  - [Rust 编程基础](./Rust%20基础.md)
  - [所有权、借用及生命周期](./所有权、借用及生命周期.md)
  - 数据结构
    - 数组（长度固定、类型相同）
      - `let arr: [i32; 5] = [1,2,3,4,5];`
      - `let arr2 = [3; 5]; // let arr2 = [3,3,3,3,3]`
    - 元组：`(), (T,), (T1, T2), …`
      - `let tup = (32, 'A', 0.12);`
      - 解构：`let (x, y, z) = tup;`
      - 索引：`tup.1`
    - 切片
      - 切片 (slice) 的作用是提供对集合 (collection) 的视图 (view)
      - 类型 `&[type]`
      - `&xx[闭..开]`
    - 字符串 String
      - 字符串本质：byte 集合 + 方法（将字节解析成文本）
      - 创建
        - `String::new()`
        - `to_string()`
        - `String::from()`
      - 拼接
        - s1 + &s2
          - 类似效果：`fn add(self, &str) -> String`
        - `fomate!("{}-{}", s1, s2)`
          - 不会获取参数所有权
          - 返回新的字符串
      - 访问
        - 无法索引
          - UTF-8 可变长编码
      - 字符串切片 &str
        - 切片如果跨越字符边界，程序会 panic
      - 遍历
        - 字节
        - 标量值
        - 字形簇
    - 矢量 `Vec`
      - 创建
        - `let v: Vec<i32> = Vec::new();`
        - `let v = vec![1,2,3]`
      - 访问
        - 索引：`&v[2]`，在运行时进行越界检查，越界会导致程序 panic
        - get：`v.get(2)`
      - Vector + Enum：使用枚举来储存多种类型
    - 哈希 `HashMap`
      - `HashMap::new()`
      - `hashMap.insert(key, value)` 值所有权移动
      - `entry()`、`or_insert()`
  - [Rust 模块系统](./Rust%20模块系统.md)
  - [Rust 泛型、Trait](./Rust%20泛型、Trait.md)
  - 文档注释
  - 代码调试及错误处理
    - 打印日志
      - `println!`
        - `\{}` 调用 `std::fmt::Display` 实现
        - `\{:?}`、`\{:#?}` 调用 `std::fmt::Debug` 实现
          - `#[derive(Debug)]` 派生 Debug trait
      - `dbg!`：是一个非常有用的调试宏，它会输出文件名，当前代码行号，变量名称以及变量的值
    - [Rust 错误处理](./Rust%20错误处理.md)
  - [Rust 代码测试](#rust-代码测试)
  - 学习资料
    - [Rust编程语言入门教程（Rust语言/Rust权威指南配套）](https://www.bilibili.com/video/BV1hp4y1k7SV)
    - [tour_of_rust](https://github.com/richardanaya/tour_of_rust)

## Rust 代码测试

- Rust 代码测试
  - 断言
    - `assert!` 检查布尔结果
      - true：测试通过
      - false：调用 `panic!`，测试失败
    - `assert_eq!` 和 `assert_ne!` 测试相等性
      - `assert_eq!` 和 `assert_ne!` 宏在底层分别使用了 == 和 !=。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必须实现了 PartialEq 和 Debug trait。
        - `#[derive(PartialEq, Debug)]`
    - `assert!`、`assert_eq!` 和 `assert_ne!` 自定义失败信息：必需参数之后指定的参数都会传递给 `format!` 宏
  - 可将 `Result<T, E>` 用于测试结果
    - 断言一个操作返回 Err 成员：`assert!(value.is_err())`
  - cargo test
    - 分隔符 `--` 传参给执行程序
    - 默认并行测试
      - 单线程测试：`cargo test -- --test-threads=1`
    - 默认情况下，只打印到错误流信息
      - `--show-output` 告诉 Rust 显示所有输出流
    - 运行部分测试
      - 运行单个测试：`cargo test <xxx>`
      - 过滤运行多个测试：`cargo test <匹配部分测试的名称>`
  - 单元测试
    - 单元测试代码与目标代码位于同份文件
    - 每个文件中创建包含测试函数的 tests 模块，并使用 `#[cfg(test)]` 标注模块
    - 测试函数
      - 标注 `#[test]`
      - `#[should_panic]` 预期的失败，检查 panic
        - 可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本
      - `#[ignore]` 忽略测试
  - 集成测试
    - 根目录创建一个 tests 目录
    - 创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译
    - 不需标注 `#[cfg(test)]` 测试模块
    - 可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试
    - 二进制项目的 crate 的集成测试
      - 使用一个简单的 src/main.rs 调用 src/lib.rs 中的逻辑。因为通过这种结构，集成测试 就可以 通过 extern crate 测试库 crate 中的主要功能了，而如果这些重要的功能没有问题的话，src/main.rs 中的少量代码也就会正常工作且不需要测试。
  - 文档测试
