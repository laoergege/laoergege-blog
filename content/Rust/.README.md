---
discussionID: 4VRzUDnXN1BHHx8QIV1zE
tags:
 - rust
---

# Rust

::tl
- Rust
  - 设计理念
    - 内存安全、并发安全、性能
    - 多范式编程
    - 划分 Safe rust 和 Unsafe Rust（方便与其他语言沟通）
  - [Rust 编程基础](#rust-编程基础)
  - [所有权、借用及生命周期](./所有权、借用及生命周期.md)
  - 数据结构
    - 数组（长度固定、类型相同）
      - `let arr: [i32; 5] = [1,2,3,4,5];`
      - `let arr2 = [3; 5]; // let arr2 = [3,3,3,3,3]`
    - 元组：`(), (T,), (T1, T2), …`
      - `let tup = (32, 'A', 0.12);`
      - 解构：`let (x, y, z) = tup;`
      - 索引：`tup.1`
    - 切片
      - 切片 (slice) 的作用是提供对集合 (collection) 的视图 (view)
      - 类型 `&[type]`
      - `&xx[闭..开]`
    - 字符串 String
      - 字符串本质：byte 集合 + 方法（将字节解析成文本）
      - 创建
        - `String::new()`
        - `to_string()`
        - `String::from()`
      - 拼接
        - s1 + &s2
          - 类似效果：`fn add(self, &str) -> String`
        - `fomate!("{}-{}", s1, s2)`
          - 不会获取参数所有权
          - 返回新的字符串
      - 访问
        - 无法索引
          - UTF-8 可变长编码
      - 字符串切片 &str
        - 切片如果跨越字符边界，程序会 panic
      - 遍历
        - 字节
        - 标量值
        - 字形簇
    - 矢量 `Vec`
      - 创建
        - `let v: Vec<i32> = Vec::new();`
        - `let v = vec![1,2,3]`
      - 访问
        - 索引：`&v[2]`，在运行时进行越界检查，越界会导致程序 panic
        - get：`v.get(2)`
      - Vector + Enum：使用枚举来储存多种类型
    - 哈希 `HashMap`
      - `HashMap::new()`
      - `hashMap.insert(key, value)` 值所有权移动
      - `entry()`、`or_insert()`
  - [Rust 模块系统](./Rust%20模块系统.md)
  - [Rust 泛型、Trait](./Rust%20泛型、Trait.md)
  - 代码调试及错误处理
    - 打印日志
      - `println!`
        - `\{}` 调用 `std::fmt::Display` 实现
        - `\{:?}`、`\{:#?}` 调用 `std::fmt::Debug` 实现
          - `#[derive(Debug)]` 派生 Debug trait
      - `dbg!`：是一个非常有用的调试宏，它会输出文件名，当前代码行号，变量名称以及变量的值
    - [Rust 错误处理](./Rust%20错误处理.md)
  - [Rust 代码测试](#rust-代码测试)
  - 学习资料
    - [Rust编程语言入门教程（Rust语言/Rust权威指南配套）](https://www.bilibili.com/video/BV1hp4y1k7SV)
    - [tour_of_rust](https://github.com/richardanaya/tour_of_rust)
::

## Rust 编程基础

:: tl
- Rust 编程基础
  - 变量、值和类型声明
    - 变量
      - Rust 的变量命名规范：蛇形命名法 (snake_case)
      - 声明不可变变量：`let`
        - 隐藏变量：即可重复声明变量
      - 可变变量声明：`let mut`
      - 常量声明：`const`
        - 不可与 `mut` 配合，且使用**必须注明值的类型**
        - 常量被编译后放入可执行文件的数据段，可全局访问
      - 静态变量：`static let`
    - 值和类型
      - 类型是对值的区分，它包含了值在内存中的长度、对齐以及值可以进行的操作等信息；值是无法脱离具体的类型讨论的
      - rust 编译器会自动隐式**类型推导**
        - 但特殊情况也需要表明数据类型，如 const 变量声明
      - 类型分类
        - 标量类型
          - 整数
            - 无符号：`u32`
            - 有符号：`i32`
          - 浮点
            - IEEE-754 标准
          - 布尔
          - 字符
            - 单个字符：`char`
        - 复合类型：多个类型值组合在一起共同表达单个类型值的复杂数据结构
          - 结构体 `struct`
          - 枚举 `enum`
            - 标签联合
        - 类型转换
  - 语句、表达式与运算符
    - 语句是执行动作的指令，以分号";"结尾
    - 表达式是计算产生值
    - **面向表达式**：一切皆是表达式，即一切皆类型
      - 在 Rust 中，无论是（大多数）语句还是表达式会产生值，值即类型，rust 就是通过一切类型检查保证内存安全、并发安全
      - 比如
        - 分号也是一种表达式，返回单元类型 `; -> ()`
        - 语句块会对里面最后表达式的值作为其值返回，否则默认 `; -> ()`
    - 注释
      - 文档注释
    - 控制流
      - 顺序
      - 跳转
        - 循环
          - `loop {...}`：一直循环
          - `while [expr] {...}`：条件循环
            - 总是返回 `()` 类型
          - `for ... in [迭代器] {...}`：集合迭代
          - 中断
            - `break [expr]`
            - `continue`
            - `return [expr]`
        - 分支 
          - `if [condition] {...} else {...}`
          - 模式匹配（基于类型的分支）
            - `match expr {}`
              - 解构
              - _
            - `if let`
              - `if let ... else`
            - `while let`
        - 错误跳转
          - `expr?`：自动错误传播
            - expr 必须返回 Result 类型
        - 异步跳转
          - `expr.await`
  - 函数 `fn xxx_xxx([arg:type, ...]) -> [type]{...}`
    - 函数是一等公民
    - 函数声明提升
    - 返回值
      - 默认最后一个表达式
      - `return`：指定返回值
    - 不支持函数重载
    - 闭包
      - 使用两个竖线符号`||`定义，而不是用`fn ()`来定义
::


## Rust 代码测试

- Rust 代码测试
  - 断言
    - `assert!` 检查布尔结果
      - true：测试通过
      - false：调用 `panic!`，测试失败
    - `assert_eq!` 和 `assert_ne!` 测试相等性
      - `assert_eq!` 和 `assert_ne!` 宏在底层分别使用了 == 和 !=。当断言失败时，这些宏会使用调试格式打印出其参数，这意味着被比较的值必须实现了 PartialEq 和 Debug trait。
        - `#[derive(PartialEq, Debug)]`
    - `assert!`、`assert_eq!` 和 `assert_ne!` 自定义失败信息：必需参数之后指定的参数都会传递给 `format!` 宏
  - 可将 `Result<T, E>` 用于测试结果
    - 断言一个操作返回 Err 成员：`assert!(value.is_err())`
  - cargo test
    - 分隔符 `--` 传参给执行程序
    - 默认并行测试
      - 单线程测试：`cargo test -- --test-threads=1`
    - 默认情况下，只打印到错误流信息
      - `--show-output` 告诉 Rust 显示所有输出流
    - 运行部分测试
      - 运行单个测试：`cargo test <xxx>`
      - 过滤运行多个测试：`cargo test <匹配部分测试的名称>`
  - 单元测试
    - 单元测试代码与目标代码位于同份文件
    - 每个文件中创建包含测试函数的 tests 模块，并使用 `#[cfg(test)]` 标注模块
    - 测试函数
      - 标注 `#[test]`
      - `#[should_panic]` 预期的失败，检查 panic
        - 可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本
      - `#[ignore]` 忽略测试
  - 集成测试
    - 根目录创建一个 tests 目录
    - 创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译
    - 不需标注 `#[cfg(test)]` 测试模块
    - 可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试
    - 二进制项目的 crate 的集成测试
      - 使用一个简单的 src/main.rs 调用 src/lib.rs 中的逻辑。因为通过这种结构，集成测试 就可以 通过 extern crate 测试库 crate 中的主要功能了，而如果这些重要的功能没有问题的话，src/main.rs 中的少量代码也就会正常工作且不需要测试。
  - 文档测试
