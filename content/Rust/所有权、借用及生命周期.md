---
discussionID: lS0kRZ7bcLT35zNyd8cUm
release: true
tags:
 - rust
---

# 内存安全：所有权、借用及生命周期

::tl
- 值的分配
  - 栈内存
    - 在编译时已知的固定大小
      - 栈上的操作比堆高效，因为栈上内存的分配和回收只需移动栈顶指针就行了。这就决定了分配和回收时都必须精确计算这个指针的增减量，因此栈上一般放固定尺寸的值
      - 栈的容量也是非常有限的，因此也不适合放尺寸太大的值
    - 固定生命周期：调用栈生命规则
  - 堆内存
    - 数据具有动态大小
    - 不固定生命周期
- Rust 对值的管理
  - 所有权和作用域
    - Rust 中，每一个值有且仅有一个所有者
    - 当所有者所在作用域（scope）结束的时候，其管理的值会被一起释放掉
  - 所有权转移：一旦发生赋值行为（变量赋值、参数传递、函数返回等行为），旧的所有者会把值的所有权转移给新的所有者
  - 借用
    - Rust 通过**单一所有权**规则来限制任意引用的行为。但是在 Rust 中为了不转移所有权和拷贝消耗（clone 相较栈消耗要大得多）下能够访问使用数据，引入了**borrow** 的概念，使用引用可以避免对变量或对象进行复制，从而提高程序的效率并减少内存使用
    - “借用”和“引用”是同一个概念，只不过多了些规则，便提出了新概念“借用”，所谓的借用，其本质就是**引用 + 借用规则**




      - Rust 的赋值行为有三种
        - Move 语义（默认行为）：即所有权转移
        - Copy 语义：自动按位拷贝。如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行拷贝，否则使用 Move 语义进行移动
        - Borrow 语义

- 值的使用：值只能所有者使用，当想通过其他方式使用呢？
  - 转移
  - 克隆
  - 借用：在 Rust 中，“借用”和“引用”是同一个概念，只不过多了些规则，便提出了新概念“借用”
    - 创建一个引用的行为称为**借用**
      - `&T：不可变借用`
      - `&mut T: 可变借用`
    - 借用规则
      - 可多个不可变借用，但只能有一个可变借用
      - 在同一作用域内，可变借用（写）和不可变借用（读）是互斥的，不能同时存在。即读完再写或写完再读，不能边写边读
      - 借用只在所有权者的**生命周期内**才有效，防止悬空引用
  - 切片 slice：允许你引用集合中一段连续的元素序列，而不用引用整个集合
    - 切片语法 `&T[..]`
    - 字符串切片 `&str` ：指向字符串的一部分不可变借用
- 内存、资源安全问题
  - 空指针
  - 堆栈溢出
  - **多重可变引用** => 悬空指针、内存泄漏、数据竞争
    - 悬空指针：是指指向无效或已经释放的内存的指针
      - 例如，当一个对象被删除或释放，而指向它的指针没有修改，那么这个指针就成为了垂空指针。可能导致不可预测的行为，因为释放的内存可能被重新分配给其他数据，如果程序试图通过悬空指针访问或修改内存，可能会造成数据的损坏或覆盖
    - 内存泄漏：自动垃圾回收算法会根据引用数
  - 资源泄漏
::

## 所有者及生命周期

堆内存的生命周期和使用它的栈内存上的所有者生命周期绑在一起，当程序离开所有者的作用域，它拥有的值会被丢弃。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心只需要关心调用栈的生命周期。


当程序离开 "hello" 所有者变量 s 所在生命周期（作用域），其拥有的值被丢弃。

```rust
fn main() {
    let s_ref;                                   ——————————————————————                      
    {                                                                 ｜
        let s = String::from("hello");   ----------                   ｜ 
                                                  |                   ｜
                                                  s 生命周期范围        s_ref 生命周期范围
        s_ref = &s;                      _________|                   ｜ 
    }                                                                 ｜ 
    println!("{}", s_ref);                       ——————————————————————
}
```

这种堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性，叫作 RAII（Resource Acquisition Is Initialization）。

Drop trait
      - 类似面向对象编程中的析构函数，当一个值要被释放，它的 Drop trait 会被调用

fn foo(s: String) {
    println!("{s}");
}

fn main() {
    let s1 = String::from("I am a superman.");
    foo(s1);
    println!("{s1}");    // 这里加了一行
}


## Clone Trait vs Copy Trait

- **Clone trait** 是 **Copy trait** 的 supertait（基类）
- 无论是 Clone 还是 Copy，目的都是为了拷贝值
  - Copy 是隐式复制行为，由编译器自动执行的；它是一个**标记特征**，告诉编译器表明该类型可以**安全、简单**得直接**按位拷贝**
    - 按位拷贝：等同于 C 语言里的 memcpy：C 语言中的 memcpy 会从源所指的内存地址的起始位置开始拷贝 n 个字节，直到目标所指的内存地址的结束位置。**但如果要拷贝的数据中包含指针，该函数并不会连同指针指向的数据一起拷贝**
    - 如何实现 Copy 特征
      ```rust
      struct MyStruct;

      impl Copy for MyStruct { }

      impl Clone for MyStruct {
          fn clone(&self) -> MyStruct {
              *self // 直接解引用到原值
          }
      }
      ```
    - 在 Rust 中，什么数据结构实现了 **Copy trait** 呢？
      - [Rust 标准库中实现 Copy trait 的所有数据结构](https://doc.rust-lang.org/std/marker/trait.Copy.html)
      - 大概心智模型
        - 固定大小的数据类型，如标量类型、共享只读引用、函数指针等
        - 无法安全复制的类型不能实现 Copy trait
          - 可变引用类型
          - 任何类型的实现 **Drop trait**，防止双重释放
        - 需要所有成员都是 Copy trait 的，结构体才能实现 Copy trait
  - Clone 则是开发者通过 clone 方法显示调用的
    - Copy 无法重载，而 Clone trait 则可以重载
    - Copy trait 和 Clone trait 本质上都是按位复制，但 Clone trait 可能会涉及到更多的内存分配和操作，而 Copy trait 则只是简单地复制值，Clone trait 更多期望实现真正克隆语义。故在 Rust 中，Copy 的特征充当于“浅”克隆，而 Clone 则相当于“深”拷贝
    - [Rust 标准库中实现 Clone trait 的所有数据结构](https://doc.rust-lang.org/std/clone/trait.Clone.html)



- 但 Rust 没有传引用的概念，Rust 所有的参数传递都是传值，不管是 Copy 还是 Move。所以在 Rust 中，你必须显式地把某个数据的引用，传给另一个函数。





- 追踪式垃圾回收（Tracing GC）
  - 原理：
    - 标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉
  - bad
    - GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大
    - 但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的**延迟（latency）不确定**
      - fix：混合写屏障
        - https://go.dev/blog/ismmkeynote



