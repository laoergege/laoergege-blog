---
release: true
tags:
 - rust
---

# 内存安全：所有权、借用及生命周期

- 所有权
  - 单一所有权机制：每个值只能被一个变量所拥有，这个变量被称为所有者
  - 所有权转移：一旦发生变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者
    - 符合 Copy 语义（**Copy trait**）的的数据类型会自动按位拷贝（浅拷贝）；否则默认 Move 语义，则会发生值的**所有权转移**
      - 按位拷贝，等同于 C 语言里的 memcpy：C 语言中的 memcpy 会从源所指的内存地址的起始位置开始拷贝 n 个字节，直到目标所指的内存地址的结束位置。但如果要拷贝的数据中包含指针，该函数并*不会*连同指针指向的数据一起拷贝
    - 在 Rust 中，什么数据结构实现了 **Copy trait** 呢？
      - [Rust 标准库中实现 Copy trait 的所有数据结构](https://doc.rust-lang.org/std/marker/trait.Copy.html)
      - 大概心智模型规律：一般来说存放在栈上的数据类型（标量类型）实现Copy trait
  - 当程序离开所有权者的作用域（生命周期），其拥有的值将被丢弃
- Copy trait 特性
  - 要实现 Copy trait 的类型不能包含指向堆上数据的指针
  - **Clone trait** 是 Copy trait 的 supertait（基类），Clone 是隐式行为：由编译器默认调用的, 而 Clone trait 则是开发者通过 clone 方法调用的
  - 任何类型的实现 **Drop trait** 都不能实现 Copy trait
- 值的使用：值只能所有者使用，当想通过其他方式使用呢？
  - 转移
  - 克隆（深拷贝）
    - 实现 `Clone trait`
    - [Rust 标准库中实现 Clone trait 的所有数据结构](https://doc.rust-lang.org/std/clone/trait.Clone.html)
  - 借用
    - 在 Rust 中，“借用”和“引用”是同一个概念，只不过多了些规则，便提出了新概念“借用”
    - 创建一个引用的行为称为**借用**
      - `&T：不可变借用`
      - `&mut T: 可变借用`
    - 借用规则：
      - 在同一作用域内只能有一个可变引用、任意数量的不可变引用
      - 在同一作用域内不能在不可变引用之前使用可变引用
      - 引用只在其借用的所有权者的**生命周期内**才有效，防止悬空引用
        - 悬空指针 (Dangling Pointer) : 一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了
  - 切片 slice：允许你引用集合中一段连续的元素序列，而不用引用整个集合
    - 切片语法 `&T[..]`
    - 字符串切片 `&str` ：指向字符串的一部分不可变借用
- 指针和引用
  - 指针
    - 指针是一个持有内存地址值的变量
    - 可以通过**解引用（dereference）**来访问它指向的堆内存地址，理论上可以解引用到任意数据类型，但如果没有用正确的类型解引用一个指针，那么会引发各种各样的内存问题
  - 引用
    - 引用是一种直接指向值的指针
    - 引用是特殊的指针，引用的实现上比正常指针携带更多信息的指针，我们称之为胖指针（fat pointer），很多数据结构的引用，内部都是由胖指针实现的
    - 引用的解引用访问是受限的，它只能解引用到它引用数据的类型
    - 在 Rust 中
      - 使用 `*` 操作符进行解引用和赋值
      - 使用 `&` 操作符进行借用和解构（C++，`&` 是取址操作）
- Rust 内存安全设计

## 所有权转移

```rust
fn move_var_ownership() {
    let num = 123;
    let num2 = num;
    println!("{}", num); // success

    let data = vec![1, 2, 3, 4];
    //移动：所有权一旦转移，旧变量将不再有效
    let data1 = data;
    println!("data1: {:?}", data); // error
}
```

## 生命周期

当程序离开 "hello" 所有者变量 s 所在生命周期（作用域），其拥有的值被丢弃。

```rust
fn main() {
    let s_ref;                                   ——————————————————————                      
    {                                                                 ｜
        let s = String::from("hello");   ----------                   ｜ 
                                                  |                   ｜
                                                  s 生命周期范围        s_ref 生命周期范围
        s_ref = &s;                      _________|                   ｜ 
    }                                                                 ｜ 
    println!("{}", s_ref);                       ——————————————————————
}
```

## Rust 内存安全设计

- 内存问题
  - 空指针
  - 堆栈溢出
  - 内存泄漏、重复释放
    - 栈：栈上内存由编译器、系统自动管理，无需额外释放
    - **堆**
      - fix
        - 单一所有权及转移 => 保证一块内存仅有一个所有者？
          - 在rust语言机制上,不允许 Copy trait 和 Drop trait 同时实现,因为允许 Copy trait 的都在栈上. 栈上的内存管理是不需要开发者操心的,只有堆上的内存需要
          - 在 Rust 中为了不转移所有权和拷贝消耗（clone 相较栈消耗要大得多）下能够访问使用数据，引入了**borrow** 的概念，使用引用可以避免对变量或对象进行复制，从而提高程序的效率并减少内存使用
  - 悬空指针
    - 悬空指针是指指向无效或已经释放的内存的指针。例如，当一个对象被删除或释放，而指向它的指针没有修改，那么这个指针就成为了悬空指针
    - 悬空指针可能导致不可预测的行为，因为释放的内存可能被重新分配给其他数据，如果程序试图通过悬空指针访问或修改内存，可能会造成数据的损坏或覆盖。
    - fix
      - 生命周期注释
      - Rust 借用检查器管理
  - 数据竞争
    - 多重引用
    - fix
      - 不可变

