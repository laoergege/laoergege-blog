---
discussionID: lS0kRZ7bcLT35zNyd8cUm
release: true
tags:
 - rust
---

# 内存安全：所有权、借用及生命周期

- 值的分配存储方式及生命周期
  - 栈上存放的数据是静态的，固定大小，固定生命周期
  - 堆上存放的数据是动态的，不固定大小，不固定生命周期
- 值在内存中的访问规则
- 内存、资源安全问题
  - 空指针
  - 堆栈溢出
  - **多重可变引用** => 悬空指针、内存泄漏、数据竞争
    - 悬空指针：是指指向无效或已经释放的内存的指针
      - 例如，当一个对象被删除或释放，而指向它的指针没有修改，那么这个指针就成为了垂空指针。可能导致不可预测的行为，因为释放的内存可能被重新分配给其他数据，如果程序试图通过悬空指针访问或修改内存，可能会造成数据的损坏或覆盖
    - 内存泄漏：自动垃圾回收算法会根据引用数
  - 资源泄漏
- Rust 变量的所有权、借用检查和生命周期
  - 生命周期标注 -> 结构体数据的所有权
  - 所有权、借用检查和生命周期 + 类型系统（Send/Sync trait） -> 并发安全
- Rust 通过**所有权规则**来限制任意引用的行为
  - 单一所有权：每个值只能被一个变量所拥有，这个变量被称为所有者
  - 所有权转移：一旦发生赋值行为（变量赋值、参数传递、函数返回等行为），旧的所有者会把值的所有权转移给新的所有者
    - Rust 的赋值行为有三种
      - Move 语义（默认行为）：即所有权转移
      - Copy 语义：自动按位拷贝。如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行拷贝，否则使用 Move 语义进行移动
      - Borrow 语义
- 借用：在 Rust 中为了不转移所有权和拷贝消耗（clone 相较栈消耗要大得多）下能够访问使用数据，引入了**borrow** 的概念，使用引用可以避免对变量或对象进行复制，从而提高程序的效率并减少内存使用
  - 生命周期注释
  - Rust 借用检查器管理
- 值的使用：值只能所有者使用，当想通过其他方式使用呢？
  - 转移
  - 克隆
  - 借用：在 Rust 中，“借用”和“引用”是同一个概念，只不过多了些规则，便提出了新概念“借用”
    - 创建一个引用的行为称为**借用**
      - `&T：不可变借用`
      - `&mut T: 可变借用`
    - 借用规则
      - 在同一作用域内只能有一个可变借用
      - 在同一作用域内，可变借用（写）和不可变借用（读）是互斥的，不能同时存在。即读完再写或写完再读，不能边写边读
      - 借用只在所有权者的**生命周期内**才有效，防止悬空引用
  - 切片 slice：允许你引用集合中一段连续的元素序列，而不用引用整个集合
    - 切片语法 `&T[..]`
    - 字符串切片 `&str` ：指向字符串的一部分不可变借用
- 内存管理：值的生命周期
  - 当程序离开所有权者的作用域（生命周期），其拥有的值将被丢弃

## 栈内存管理

## 生命周期

当程序离开 "hello" 所有者变量 s 所在生命周期（作用域），其拥有的值被丢弃。

```rust
fn main() {
    let s_ref;                                   ——————————————————————                      
    {                                                                 ｜
        let s = String::from("hello");   ----------                   ｜ 
                                                  |                   ｜
                                                  s 生命周期范围        s_ref 生命周期范围
        s_ref = &s;                      _________|                   ｜ 
    }                                                                 ｜ 
    println!("{}", s_ref);                       ——————————————————————
}
```

## Clone Trait vs Copy Trait

- **Clone trait** 是 **Copy trait** 的 supertait（基类）
- 无论是 Clone 还是 Copy，目的都是为了拷贝值
  - Copy 是隐式复制行为，由编译器自动执行的；它是一个**标记特征**，告诉编译器表明该类型可以**安全、简单**得直接**按位拷贝**
    - 按位拷贝：等同于 C 语言里的 memcpy：C 语言中的 memcpy 会从源所指的内存地址的起始位置开始拷贝 n 个字节，直到目标所指的内存地址的结束位置。**但如果要拷贝的数据中包含指针，该函数并不会连同指针指向的数据一起拷贝**
    - 如何实现 Copy 特征
      ```rust
      struct MyStruct;

      impl Copy for MyStruct { }

      impl Clone for MyStruct {
          fn clone(&self) -> MyStruct {
              *self // 直接解引用到原值
          }
      }
      ```
    - 在 Rust 中，什么数据结构实现了 **Copy trait** 呢？
      - [Rust 标准库中实现 Copy trait 的所有数据结构](https://doc.rust-lang.org/std/marker/trait.Copy.html)
      - 大概心智模型
        - 固定大小的数据类型，如标量类型、共享只读引用、函数指针等
        - 无法安全复制的类型不能实现 Copy trait
          - 可变引用类型
          - 任何类型的实现 **Drop trait**，防止双重释放
        - 需要所有成员都是 Copy trait 的，结构体才能实现 Copy trait
  - Clone 则是开发者通过 clone 方法显示调用的
    - Copy 无法重载，而 Clone trait 则可以重载
    - Copy trait 和 Clone trait 本质上都是按位复制，但 Clone trait 可能会涉及到更多的内存分配和操作，而 Copy trait 则只是简单地复制值，Clone trait 更多期望实现真正克隆语义。故在 Rust 中，Copy 的特征充当于“浅”克隆，而 Clone 则相当于“深”拷贝
    - [Rust 标准库中实现 Clone trait 的所有数据结构](https://doc.rust-lang.org/std/clone/trait.Clone.html)



- 但 Rust 没有传引用的概念，Rust 所有的参数传递都是传值，不管是 Copy 还是 Move。所以在 Rust 中，你必须显式地把某个数据的引用，传给另一个函数。
- Rust 的引用实现了 Copy trait，所以按照 Copy 语义，这个引用会被复制一份交给要调用的函数。
- 堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们核心只需要关心调用栈的生命周期。
- 自动引用和解引用
- 重新借用
  - &*r1;
- 打印栈变量地址
- copy语义和move语义底层实现都是按位浅拷贝，只不过copy语义是产生新的值，move语义是所有权转移，这样理解对吧？


- 多引用
  - 在编译时，通过 Rust 借用检查器就能完成静态检查
  - Rust 提供了运行时的动态检查
    - 使用引用计数的智能指针：Rc（Reference counter） 和 Arc（Atomic reference counter）



- 栈是自顶向下增长的
- 栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）
- 一个新的帧会分配足够的空间存储寄存器的上下文
  - 怎么确定究竟需要多大的帧呢？
    - 编译并优化代码的时候，一个函数就是一个最小的编译单元。在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定。所以编译器就需要明确每个局部变量的大小，以便于预留空间。这下我们就明白了：在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上
- 这主要是考虑到调用栈的大小，避免栈溢出（stack overflow）。一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧，来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。
  - 除了动态大小的内存需要被分配到堆上外，动态生命周期的内存也需要分配到堆上。
  - 而堆上分配出来的每一块内存需要显式地释放，这就使堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据






- 追踪式垃圾回收（Tracing GC）
  - 原理：
    - 标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉
  - bad
    - GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大
    - 但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的**延迟（latency）不确定**
      - fix：混合写屏障
        - https://go.dev/blog/ismmkeynote


- 内存安全
  - 资料
    - [Type Systems for Memory Safety](https://borretti.me/article/type-systems-memory-safety)
  - 内存安全问题
  - 基于区域的内存管理


