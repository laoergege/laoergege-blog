---
discussionID: mk7VNH75CATICoFAAr-Gq
---


  - JS
    - 堆栈跟踪
      - Error.stack 
        - `Error.captureStackTrace(obj, func)`
      - console.trace
  - 实践
    - 扩展错误对象：规范化错误类型
    - 集中式处理
    - 错误处理
      - 传递
        - callback 
        - throw + try-catch
        - 异步错误
          - promise.reject
          - EventEmitter.emit("error")
    - 优雅地重启你的应用程序以处理程序员的错误
    - 对于操作错误，您应该使用 Promise 拒绝或带有 async/await 的 try-catch 块

   
    - 全局
      - 捕获所有未捕获的异常 process.on('uncaughtException'
      - 捕获所有未处理的承诺拒绝 process.on('unhandledRejection', callback)
    - 错误日志（打印、上传）及警报
      - [consola](https://github.com/unjs/consola)









- 工作模式
  - 调用者角度：错误发生 => 错误类型捕获 => 立即处理、延迟处理（传播）
    - 能，上
  - 编写正确的代码
    - 在代码中每次都处理错误
  - 快速开发
    - 只处理少数的必要的错误
    - 粗略集中处理
    - 监控：实时抓取运行时发生的各种问题
- 原则
  - 错误处理是程序员的事，是系统/架构/模块设计师的事，不是编程语言的事
  - 区分错误和异常：我们更应该关注的，是如何清晰的区分和标注哪些是“错误”或“异常”，而不是把错误和异常混为一谈
    - 错误是明确的、职责分明的，应当立即处理
    - 异常是无法预测的、难以修复的，需要上报
- 语言范式-错误处理：
  - 设计要点
    - 如何避免开发者遗漏错误
      - 类型化，通过类型系统检查 ✅
      - 全局捕获、报道所有异常
    - 如何表达错误，如何组合多个可能发生错误的代码，如何提供语法糖简化一些不得不写的，反复重复的代码
  - 分类
    - 错误码 + 返回值
      - 容易忽略错误 ❌
      - 错误嵌套，错误层次追踪 ❌
      - 返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
        - 函数返回就没有错误，必然是有效值，不要用错误码污染它的返回 ✅
    - 异常处理机制：异常类型 + try-catch-throw
      - 将错误的产生和错误的处理分隔开 ✅
      - 错误自动传播
      - 开发者滥用，无脑往上抛 ❌
    - 错误类型 + 返回值
      - 错误信息既然可以通过已有的类型携带，或者通过多返回值的方式提供，那么通过类型来表征错误，使用一个内部包含正常返回类型和错误返回类型的复合类型，通过类型系统来强制错误的处理和传递
      - 可以用函数式编程的方法简化错误的处理，比如 map、fold 等函数，让代码相对不那么冗余
  - 最佳实践
    - 错误类型化 + 类型检测
    - **错误返回 + 类型检测 + 自动化异常**
    - 未捕获的异常应该让应用程序崩溃、记录并重新启动

