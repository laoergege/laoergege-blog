---
discussionID: mk7VNH75CATICoFAAr-Gq
---


  - JS
    - 堆栈跟踪
      - Error.stack 
        - `Error.captureStackTrace(obj, func)`
      - console.trace
  - 实践
    - 扩展错误对象：规范化错误类型
    - 集中式处理
    - 错误处理
      - 传递
        - callback 
        - throw + try-catch
        - 异步错误
          - promise.reject
          - EventEmitter.emit("error")
    - 优雅地重启你的应用程序以处理程序员的错误
    - 对于操作错误，您应该使用 Promise 拒绝或带有 async/await 的 try-catch 块

   
    - 全局
      - 捕获所有未捕获的异常 process.on('uncaughtException'
      - 捕获所有未处理的承诺拒绝 process.on('unhandledRejection', callback)
    - 错误日志（打印、上传）及警报
      - [consola](https://github.com/unjs/consola)







- 我们真正需要关注的问题有两个，一是区分错误和异常；二是“如何把异常弄的不可忽略”

- 函数式语言的理论模型是lambda演算？
  - <表达式>::= <标识符>
  - <表达式>::= (λ<标识符>.<表达式>)
  - <表达式>::= (<表达式> <表达式>)
  - 特征
    - 数据不可变
    - 其他
      - Curry
      - Lazy evaluation (惰性求值)
        - 函数的参数如果是个计算表达式的话，这个将被看成一个thunk, 真正需要的时候才会计算
        - 无限数据流

错误处理
  - 错误传递
    - 返回错误码
    - 返回错误结构体
    - 异常
      - try/catch/finally
      - “快乐路径”和错误处理路径之间的分离
      - 自动调用堆栈冒泡
      - Java著名的尝试使用“检查异常”，即你必须声明为签名一部分的异常 
    - 回调
    - 类型化，结构体、枚举


- 错误
    - 错误发生
      - 错误捕获
        - 处理
        - 反馈
        - 传播
          - 错误信息既然可以通过已有的类型携带，或者通过多返回值的方式提供，那么通过类型来表征错误，使用一个内部包含正常返回类型和错误返回类型的复合类型，通过类型系统来强制错误的处理和传递，
        - 忽略
    - 错误嵌套
- 错误处理
  - 错误处理是程序员的事，是系统/架构/模块设计师的事，不是编程语言的事，只有正确认识错误处理原则，才能更好利用好编程语言中的错误机制设计
  - 正确区分错误和异常
    - 错误
      - 失败，这是可预测的错误，必须立即处理
      - 异常，程序员忽略的或者没法在意、不可恢复的，这是一种没被处理的错误，意味着程序进入了一个未知的，不确定的状态，这是一个非常严重的错误问题
        - 面对异常，最好的做法是上报收集、系统隔离、奔溃重启
    - 错误是可预测的问题，应当立即
      - 比如，面对入参的错误，这是一种契约、明确的，应当中断执行并反馈
      - 面对操作结果的失败，应当立即、尽量处理
  - 开发模式
    - 编写正确的代码，在编码过程中尽量处理完大部分的错误
    - 快速开发
      - 只处理少数的必要的错误
      - 粗略集中处理
      - 监控：实时抓取运行时发生的各种问题
  - 编程语言中的错误处理模型
    - 编程语言应该尽力提醒程序员不要忽略错误
      - 错误码，容易忽略错误 ❌
      - 错误类型化，通过类型系统检查 ✅
        - Java CE
    - 将正确逻辑和错误处理分隔开
      - 比如 `try-catch`
    - 错误传播及追踪
      - 返回值
        - 返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
          - 可类似 Golang 多值返回，区分开错误返回和正常返回
        - 错误必须得到处理或者显式的传播
      - 异常抛出
        - 异常可以通过栈回溯（stack unwind）被一层层自动传递，直到遇到捕获异常的地方，如果回溯到 main 函数还无人捕获，程序就会崩溃
          - 异常看成一种关注点分离（Separation of Concerns）：错误的产生和错误的处理完全被分隔开，调用者不必关心错误，而被调者也不强求调用者关心错误
          - 使用异常来返回错误可以极大地简化错误处理的流程，它解决了返回值的传播问题
        - 异常安全、异常性能问题 😩
        - 开发者滥用，无脑往上抛 ❌
          - 无论什么错误都上抛，混淆、违背了“正确区分错误和异常”的原则
      - 编程语言提供自动传播的语法糖
    - 全局捕获



- 系统
  - 调用者 panic
    - 被调用 error


 
      - 错误嵌套，错误层次追踪 ❌


 
  - 最佳实践
    - 错误类型化 + 类型检测
    - 错误返回 + 自动化异常
    - 未捕获的异常应该让应用程序崩溃、记录并重新启动



内存溢出是指程序在申请内存时超出了可用内存大小，导致程序崩溃或异常终止。
内存泄漏是指程序在分配内存后无法释放已经不再使用的内存，导致内存资源逐渐耗尽