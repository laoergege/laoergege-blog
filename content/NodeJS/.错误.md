---
discussionID: mk7VNH75CATICoFAAr-Gq
---

错误处理
  - 实践
    - 扩展错误对象：规范化错误类型，友好
      - 内置错误对象 Error
        - 堆栈跟踪
          - Error.stack 
            - `Error.captureStackTrace(obj, func)`
          - console.trace
      - 中间件
    - 传递错误
      - return / callback 
      - throw
      - 异步错误
        - promise.reject
        - EventEmitter.emit("error")
    - 错误处理
      - 捕获
        - callback error
        - async/await 和 try-catch
        - promise 中使用 .catch() 错误
        - EventEmitter
      - 全局
        - 捕获所有未捕获的异常 process.on('uncaughtException'
        - 捕获所有未处理的承诺拒绝 process.on('unhandledRejection', callback)
    - 错误日志（打印、上传）及警报
      - [consola](https://github.com/unjs/consola)

- 
- 。最好的方法是让应用程序崩溃，记录错误，然后使用 nodemon 或 pm2 自动重启进程。
- 如果未正确处理 JavaScript 错误，则会发出 uncaughtException


NodeJS 中错误
  - 用户指定错误
  - 断言错误
  - JS 错误
    - EvalError
    - RangeError
    - ReferenceError
    - SyntaxError
    - TypeError
    - URIError
    - Async errors
  - [Node 系统错误](https://nodejs.org/api/errors.html#errors_class_systemerror)



- 如何处理好错误
  - 错误类型
    - 错误
    - 异常：如果一个错误出了程序员不在意，或者没法在意，那么就是一个异常。异常是程序员不处理的错误。异常意味着程序进入了一个未知的，不确定的状态。
      - throw：让上层处理问题，决定自己到底是不管直接挂掉还是把程序从有问题的状态转变回来。
        - 挂掉：异常意味着程序运行的状态处于一个非预期的状态，在没有事先设计过错误处理路径的情况下，挂掉是最好的选择。这通常被称为fail-fast。
          - 灰度开发和发布流程，即可以让不稳定的代码在一个风险可控的范围内跑，尽情的暴露各种问题，尽快的crash，然后开发者尽快去修
          - 隔离，重启
  - 错误处理
    - 调用者角度：错误发生 => 错误类型捕获 => 立即处理、延迟处理（传播）
    - 传递
      - 返回
      - 抛出
    - 处理
  - 模式
    - 错误分离
  - 工作模式
    - 编写正确的代码
      - 在代码中每次都处理错误
    - 快速开发
      - 只处理少数的必要的错误
      - 粗略集中处理
      - 监控：实时抓取运行时发生的各种问题
  - 编程语言-错误设计
    - 所有错误处理必须 "checked"。对于所有错误程序员必须显示的处理，不然编译过不去
    - 编译器应该尽力提醒程序员不要忽略错误。程序员要不处理错误，或者明确告诉编译器这个错误我觉得可以不处理
  - 语法范式
    - 关键点在于如何表达错误，如何避免开发者遗漏错误，如何组合多个可能发生错误的代码，如何提供语法糖简化一些不得不写的，反复重复的代码。

## Nodejs 错误最佳实践

1. 自定义扩展错误类型


- 未捕获的异常 `uncaughtException`
  - uncaughtException是在关闭进程之前对分配的资源（例如文件描述符、句柄等）执行同步清理
  - 让应用程序崩溃，记录错误，然后使用 nodemon 或 pm2 自动重启进程


- 性能
- 稳定性
- 可维护性
- 可扩展性





- 原则
  - 错误处理是程序员的事，是系统/架构/模块设计师的事，不是编程语言的事
  - 区分错误和异常
    - 我们更应该关注的，是如何清晰的区分和标注哪些是“错误”或“异常”，而不是把错误和异常混为一谈
    - 错误是**明确的**、职责分明的，应当**立即处理**
      - 容易忽略处理错误，必须强制显示处理
    - 异常是“不可抗力”的，是要尽快报告、提交到更高层讨论处理的
      - 异常：是执行过程无法预测的，得终止执行
      - 异常意味着程序进入了一个未知的，不确定的状态
  - 二是“如何把异常弄的不可忽略”
    - 类型化，通过类型系统检查 ✅
    - 捕获所有异常
- 常见范式
  - 错误码 + 返回值
    - 错误嵌套，错误层次追踪 ❌
    - 返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
      - 函数返回就没有错误，必然是有效值，不要用错误码污染它的返回 ✅
  - 异常类型 + try-catch-throw
    - try-catch-throw 机制
      - 将错误的产生和错误的处理分隔开
      - 错误自动传播
    - 开发者会滥用异常。只要有错误，不论是否严重、是否可恢复，都一股脑抛个异常
  - 错误类型 + 返回值
    - 错误信息既然可以通过已有的类型携带，或者通过多返回值的方式提供，那么通过类型来表征错误，使用一个内部包含正常返回类型和错误返回类型的复合类型，通过类型系统来强制错误的处理和传递
    - 可以用函数式编程的方法简化错误的处理，比如 map、fold 等函数，让代码相对不那么冗余
- 最佳实践
  - 



错误处理
  - 分类
    - 一般错误
    - 异常：不可恢复或者不想恢复的错误，想让程序终止运行并得到崩溃信息
  - 建议
    - 开发前定义好项目的错误类型
    - 未捕获的异常应该让应用程序崩溃、记录并重新启动



错误返回 + 类型检测 + 自动化异常