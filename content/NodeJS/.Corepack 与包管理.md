---
discussionID: xwJdUgnvRfm2UYF8Ju4tG
---
# Corepack 与包管理

- [Corepack：包管理器的管理器](https://nodejs.org/api/corepack.html)
  - 作用
    - 限制项目使用特定包管理工具
    - 不在需要专门安装包管理工具
  - [用法](#corepack-用法)
- 包管理(Pnpm)
  - [包描述文件：package.json](#packagejson-常见字段)
  - 创建现代化模块包
    - 编写单元测试
    - 自动化版本管理和发布
  - 依赖管理
    - 安装
    - 更新
      - 补丁
    - 删除
    - 联调
  - 脚本运行
  - Workspaces
- Node 开发环境锁定
  - Node 版本
    - [nvm](https://github.com/nvm-sh/nvm)
    - [volta](https://github.com/volta-cli/volta)
  - 包管理
    - [corepack](https://github.com/nodejs/corepack)
    - package: `engines` + `.npmrc: engine-strict`
    - .npmrc: `use-node-version`
    - pnpm env
  - 依赖版本：lockfile

## Corepack 用法

```
# 卸载全局 pnpm yarn
npm uninstall -g yarn pnpm

# 激活
corepack enable

# 禁用 npm
corepack disable npm 

# package.json 定义包管理器及限制版本 
"packageManager": "pnpm@7.16.0"

# 下载包管理，并激活为全局
corepack prepare pnpm@latest --activate

# 修改指定全局包管理
corepack prepare pnpm@7.16.0 --activate

# 离线手动安装包管理
corepack hydrate <path/to/corepack.tgz> 【--activate】
```

## 创建现代化模块包

- 自动化版本管理
  - 语义版本控制
    - [semantic-release](https://github.com/semantic-release/semantic-release)
- 发包

## 发包

pnpm 在默认情况下，如果可用的 packages 与已声明的可用范围相匹配，pnpm 将从 workspace 链接这些 packages，并在 package.json 以 `workspace:` 协议声明；而当发包的时候将动态标准化依赖为 `workspace:` 协议：

```json
{
  "dependencies": {
    "foo": "workspace:*",
    "bar": "workspace:~",
    "qar": "workspace:^",
    "zoo": "workspace:^1.5.0"
  }
}
```

将会被转化为：

```json
{
  "dependencies": {
    "foo": "1.5.0",
    "bar": "~1.5.0",
    "qar": "^1.5.0",
    "zoo": "^1.5.0"
  }
}
```

### Publish 工作流

> 以下基于 [github package npm 注册源](https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-npm-registry)为例

1. 确认 package 相关信息（[package.json 常见字段](#packagejson-常见字段)）
2. Pack
3. Versions
4. Changelog
5. Register & Oauth

   - 注册源配置
     - .npmrc：`@laoergege:registry=https://npm.pkg.github.com/`
     - package.json#publishConfig：
       ```json
       "publishConfig": {
         "registry":"https://npm.pkg.github.com",
         "access": "public"
       }
       ```
   - 身份认证

     - 个人访问令牌
       - .npmrc：`//npm.pkg.github.com/:_authToken=TOKEN`
     - 命令行

       ```shell
       $ npm login --scope=@OWNER --registry=https://npm.pkg.github.com

       > Username: USERNAME
       > Password: TOKEN
       > Email: PUBLIC-EMAIL-ADDRESS
       ```

6. `pnpm publish`

## package.json 常见字段

> package.json 文档链接
>
> - [npm](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)
> - [pnpm](https://pnpm.io/zh/package_json)

- package.json
  - 项目描述
    - name
      - Global names
      - `@scope/name`
    - version
      - 语义版本控制
    - description
    - keywords
    - homepage
    - license
    - people fields: author, contributors
    - repository
  - 模块描述
    - type
    - main
    - module
    - types
    - 依赖
      - dependencies
      - devDependencies
      - peerDependencies
    - overrides：用于开发覆盖包做测试
    - workspaces
  - 脚本命令
    - bin
    - scripts
  - 发包配置
    - publishConfig
    - private
    - files
  - 环境声明
    - engines

### 语义版本控制

- `major[.minor][.patch]`
  - major version：当进行不兼容的 API 更改时，主要版增加
  - minor version：当以向后兼容的方式添加功能时，次要版本增加
  - patch version：当进行向后兼容的错误修复时，补丁版本递增
  - 修饰符
    - * 匹配任何版本
    - >=version表示安装的版本必须是version或更高
    - <=version表示安装的版本必须是version或更低
    - version1-version2 等同于>=version1 <=version2
    - ^version：主版本必须相同

### 

```
{
  "name": "my-package",
  "bin": "./src/main.mjs"
}


{
  "name": "my-package",
  "bin": {
    "my-package": "./src/main.mjs"
  }
}
```


- npm 
  - 它的依赖项应该是灵活的，以便在依赖项树中升级依赖项和共享包成为可能。
这就是为什么 package-lock.json 永远不会上传到 npm 注册表的原因
- 它通常包含生成的工件 - 例如，包含从 TypeScript 文件编译的 JavaScript 文件，这样只使用 JavaScript 的人就不必安装 TypeScript 编译器。


- specifiers（模块说明符）
  - Absolute specifiers are full URLs
  - Relative specifiers are relative URLs
    - 绝对说明符和相对说明符总是有文件扩展名——通常是 .js 或 .mjs
  - Module specifiers：既不以斜杠也不以点开头的路径，则以包名称开头
    - 仅包名 
    - 带有无扩展子路径
    - 带扩展的子路径
- The Node.js resolution algorithm works as follows（Node 模块路径解析算法）:
  - 如果 Absolute specifiers，则解析已经完成。Node 支持的协议：
    - file: 本地文件
    - data: 数据协议
    - node: 内置模块
  - 如果 Relative specifiers，则根据导入模块的 URL 进行解析
  - 如果 Module specifiers
    - startWith `#`
      - package imports
    - 解析算法遍历当前目录及其祖先，直到找到一个目录 node_modules，该目录的子目录存在与包名匹配
      - 入口文件解析
        - package main
        - 子路径被解释为相对于包目录。可以通过包导出覆盖默认值
        - 文件扩展名
          - `.js` 文件的加载取决于 package.json 里面 `type` 字段的设置
            - commonjs（默认）
            - module
          - `.mjs` 文件总是以 ES6 模块加载
          - `.cjs` 文件总是以 CommonJS 模块加载
- Package exports
  - `exports` 字段的优先级高于 `main` 字段
  - 向后兼容 `main`
    ```json
    {
      "main": "./dist/src/main.js",
      // "exports": "./dist/src/main.js", 
      "exports": {
        ".": "./dist/src/main.js"
      }
    }
    ```
  - 自定义子路径导出，隐藏包的内部结构（一旦 `exports` 属性存在，就只能使用其中列出的）
    ```json
    {
      "exports": {
        "./util/errors": "./dist/src/util/my_errors.js",
        "./lib/*": "./dist/src/*.js", // 对应映射多个文件
        
        "./util/errors.js": "./dist/src/util/errors.js",
        "./*": "./dist/src/*",

        //
        "./internal/*": null,
      }
    }
    ```
  - 条件导出
    ```json
    ```
- Package imports

