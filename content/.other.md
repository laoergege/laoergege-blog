
## 网络


- tcp
  - 握手
    - 发送方选择随机生成的序列号“x”并向接收方发送 SYN 数据包。
    - 接收器递增“x”，选择随机生成的序列号“y”并发回 SYN/ACK 数据包。
    - 发送方递增序列号并回复 ACK 数据包和应用程序数据的第一个字节。
  - 流量控制
    - 流量控制是一种退避机制，旨在防止发送方压垮接收方
  - 拥塞控制




- 网络性能
  - 吞吐量
    - 带宽
  - 抖动
    - 最大延迟与最小延迟的时间差
    - 时延
      - 排队时延
      - 处理时延
      - 发送时延
      - 传播时延
  - 丢包率
    - 包损坏
    - 超过 MUT
    - 超过 TTL
    - 网络发生拥塞，数据流量太大，网络设备处理不过来自然而然就有些数据包会丢了
- 网络传输
  - 分片传输
    - 序列
    - 通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割
  - 寻址：路由、路径选择

- TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。
  - 序号
  - 丢包
    - 请求/响应模型
    - 确认与重发的机制
      - 超时重传：每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试
        - TCP 动态采样 RTT 的时间进行加权估算超时时间
        - 超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
      - 快速重传：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段
        - 例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发
  - 流量控制（大小）
    - 滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满
  - 拥塞控制（速度）
- TCP 和 UDP 有哪些区别？
  - TCP 是面向连接的，UDP 是面向无连接的。
    - 所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
  - TCP 提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
    - UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。
  - TCP 是面向字节流的
    - UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。
  - TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，管它洪水滔天
  - TCP 其实是一个有状态服务，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 UDP 则是无状态服务。通俗地说是没脑子的，天真无邪的，发出去就发出去了。
- MAC 层定义了本地局域网的传输行为
- IP 层定义了整个网络端到端的传输行为
- 网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包
- IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是 UDP
- 适合场景
  - 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
  - 不需要一对一沟通，建立连接，而是可以广播的应用
  - 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候
    - TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。
    - HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。
    - 流媒体的协议
      - 直播
        - 实时性比较比较重要，宁可丢包，也不要卡顿的
        - 对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。
    - 实时游戏
- TCP/UDP 建立连接的本质就是在客户端和服务端各自维护一定的数据结构（一种状态机），来记录和维护这个“连接”的状态 。并不是真的会在这两个端之间有一条类似“网络专线”这么一个东西（在学网络协议之前脑海里是这么想象的）。
- 在 IP 层，网络情况该不稳定还是不稳定，数据传输走的是什么路径上层是控制不了的，TCP 能做的只能是做更多判断，更多重试，更多拥塞控制之类的东西。
- 滑动窗口

  - 流量控制
  - 拥塞控制










- TSL
  - Cipher Suite
  - Random
  - 数字证书
    - 签名是如何制作
      - 数字证书中包含的信息将使用 SHA-256 算法进行哈希处理。生成哈希值后，证书颁发机构使用 RSA 非对称密钥加密技术使用其私钥对哈希值进行加密
    - 信任链




- 网络问题
  - 丢包
  - 乱序
  - 延迟
- TCP
  - 可靠性
    - 发送 -> 确认；超时 -> 重发
      - 定时器
        - 在 TCP 协议中，为了避免重传次数过多，定时器的超时时间会按 2 的指数增长
        - 如果第七次之后仍然超时，则断开 TCP 连接




- 追踪式垃圾回收（Tracing GC）
  - 原理：
    - 标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉
  - bad
    - GC 在内存分配和释放上无需额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大
    - 但是，GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的**延迟（latency）不确定**
      - fix：混合写屏障
        - https://go.dev/blog/ismmkeynote






- JS 对象
  - `{key: value, ...obj, [key]: value, get xxx(), set xxx()}`
  - 原型链
    - Object.hasOwn
  - 简直对的属性集合
    - key-value
 
      - Object.keys
      - Reflect.ownKeys
      - Object.values
      - Object.entries
      - Object.fromEntries
        - 不会忽略符号键控属性
      - 私有属性
    - Object.assign
    - Object.getOwnPropertyDescriptor




- 迭代器
  - Iterable 和 Iterator 
    - interface Iterable<T> {
  [Symbol.iterator]() : Iterator<T>;
}

interface Iterator<T> {
  next() : IteratorResult<T>;
}

interface IteratorResult<T> {
  value: T;
  done: boolean;
}

  - for of、。。。、【】
- 生成器函数，它会返回一个可迭代
- yield*
- 。。



- Web 安全
  
    - Web
      - 跨站脚本（XSS）
        - HTML 给浏览器解析渲染
        - Vue、React 则将模板/jsx解析为树，在 renderer 里调用 DOM API
          - prerender / SSR 的 hydrate 过程会生成 html 
          - dangerouslySetInnerHTML、v-html
          - onload=字符串、href=字符串，设置值时，会被解析为代码执行
        - 存储型XSS
        - 反射型XSS
        - DOM-XSS
          - 过滤和数据转义
  - 安全最佳实践
    - 保护 API：使用 HTTPS、访问控制列表（ACLs）、认证方法和输入验证来保护 REST API
    - 实施内容安全策略（CSP）：确保应用程序有 CSP，防止 XSS 攻击
    - 输入净化：清理和验证用户输入，避免输入错误和恶意代码执行
    - 防止跨站脚本（XSS）攻击：通过验证和编码输入以及使用 HTTP-Only Cookies 来防止 XSS 攻击
    - 定期安全审计：定期检查应用程序的潜在漏洞，包括依赖项、输入验证、安全头和代码编辑器的安全工具


- 输入来源：过滤
  - 数据库
  - URL 参数
  - 前端 DOM
- 输出执行：转义
  - HTML 渲染



- Monorepo
  - pnpm workspace
  - elint
  - git subtree


- nextTick


- js
  - 编译
    - 执行上下文
    - 字节代码
  - 执行
    - 调用栈
      - 执行上下文 
        - 变量环境
        - 词法环境
        - this
        - 作用于域连


  


Referrer-Policy



- 常说的性能是吞吐量和延迟的总体感知





- 将用户界面分解为组件层次结构



- 枚举上定义方法
- - 在有空值的语言中，变量总是这两种状态之一：空值和非空值。
- Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 Option<T>
- enum Option<T> {
    None,
    Some(T),
}






  - Trait 约束
    - 函数参数 Trait 约束
      - `fn xxx(arg: impl Trait, ...){...}`
      - Trait 泛型约束
        - 函数：`fn xxx<T: Trait>(arg: T, ...){...}`
        - 方法：`impl<T: Trait> Xxx<T, ...> {...}`
      - 使用 + 组合多个 Trait
        - `fn xxx(arg: impl Trait1 + Trait2, ...){...}`
        - `fn xxx<T: Trait1 + Trait2>(arg: T, ...){...}`
      - 使用 where 简化 Trait 泛型约束
        ```rs
        fn some_function<T, U>(t: &T, u: &U) -> i32
        where
            T: Display + Clone,
            U: Clone + Debug,
        {
            unimplemented!()
        }
        ```
    - 函数返回 Trait 约束
      - `fn xxx() -> impl Trait`



- 词法分析 tokenizer lexer
- 语法分析
  - ast
- 转换
  - 代码生成


- 使用trait对象，具体类型在运行时解析。对于泛型，具体类型在编译时解析。


- 多态中另外两种方式：特设多态和子类型多态
- self 在用作方法的第一个参数时，实际上是 self: Self 的简写，所以 &self 是 self: &Self, 而 &mut self 是 self: &mut Self
- 静态方法


- https
- http cache
- http
- DHCP（Dynamic Configuration Protocol:动态主机设置协议）：是一个局域网协议，是应用UDP协议的应用层协议。作用：为临时接入局域网的用户自动分配IP地址
- DNS