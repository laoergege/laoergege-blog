## 操作系统

- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步 IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- stdin, stdout, and stderr
  - stdin、stdout 和 stderr 是三个标准的 I/O 流，它们分别代表标准输入、标准输出和标准错误输出。在 Unix/Linux 系统中，每个进程都默认打开了这三个流，它们通常分别与进程的键盘输入、终端输出和错误信息输出相关联。
  - 查看：`lsof -p 1234`
- 进程通信
  - API 规范
    - HTTP
      - REST API
    - RPC
  - 方式
    - 进程之内
    - 跨进程
      - 管道
      - 消息队列
      - Socket
  - 序列化、反序列化

## vscode

- vscode remote
  - [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh#_debugging-on-the-ssh-host)
  - [Remote - Containers](https://code.visualstudio.com/docs/remote/containers)
    - [附加到正在运行的容器](https://code.visualstudio.com/docs/remote/attach-container)
    - [创建开发容器](https://code.visualstudio.com/docs/remote/create-dev-container)
    - [高级容器配置场景](https://code.visualstudio.com/remote/advancedcontainers/overview)
  - GitHub Codespaces
  - The VS Code Server
  - Remote Repositories

## JavaScript

- 二进制
  - ArrayBuffer
    - ArrayBuffer 对象表示通用的、固定长度的二进制数据缓冲区
    - 必须使用其封装类 ArrayBufferView 进行实例化后才能进行访问
    - ArrayBuffer 只是描述有这样一块空间可以用来存放二进制数据，但在计算机的内存中并没有真正地为其分配空间。只有当具体类型化后，它才真正地存在于内存中
  - ArrayBufferView
    - ArrayBufferView 并不是一个具体的类型，而是代表不同类型的 Array 的描述。这些类型包括：Int8Array、Uint8Array、DataView 等
  - Blob
    - Blob（Binary Large Object）是 JavaScript 的大型二进制对象类型
- 元编程
  - Reflect 主要是和 Proxy 配对使用，提供对象语义的默认行为
  - get/set 带有额外的 receiver 参数，现阶段，receiver 其实只对访问器进行上下文修改。因为对于除了访问器（立即求值导致的）以外的属性，没有其他情况会出现这种上下文丢失的情况了，因为即使是一般函数调用，过程也是分步的，先获取函数对象（[[Get]]），再执行函数（[[Call]]）。而不会在[[Get]]的时候直接执行就意味着不会出现上下文丢失。receiver 参数完全是为了解决访问器上下文问题而添加的。


## TypeScript

- 类型系统
  - “在 TypeScript 中，类型是一组可能的值”
- 类型推导
- 类型编程
- 类型系统
  - TypeScript 基于结构类型系统
    - TypeScript 的结构类型系统是基于 JavaScript 的动态 duck 类型系统在运行时的工作方式而设计的
    - ```ts
      type X = {
          a: string;
      };
      type Y = {
          a: string;
      };
      const x: X = { a: 'a' };
      const y: Y = x; // 有效
      ```
    - 比较规则
      ```ts
      type X = {
          a: string;
      };
      const y = { a: 'A', b: 'B' }; // 有效, 至少它拥有相同的成员 X
      const r: X = y;
      ```
      - 函数参数按类型进行比较，而不是按名称进行比较
        - 函数返回类型必须相同：或者子类型
- tsconfig
  - lib
  - strict
  - esModuleInterop
    - 允许从未使用“default”属性导出的 CommonJS 模块导入默认值
    - 启用此选项后，我们可以使用“import MyLibrary from 'my-library'”而不是“import * as MyLibrary from 'my-library'”
  - 迁移到 TypeScript 的建议
    - allowJs
    - noImplicitAny
- tagged union
- 测试构造函数的原型属性是否出现在对象原型链中的任何位置
- TypeScript 编译器有两个主要职责：
  - 检查类型错误
  - 编译为 JavaScript
- 提取构造器参数签名
  - `ConstructorParameters<typeof Server>`
- 获取函数参数签名
  - `Parameters<typeof fn>;`
- 获取对象某一属性签名
  - `type Age = Person["age"];`

## 框架

- Event => Logic => State => UI
  - 人机交互的业务逻辑本身，是【针对人的行为做出反馈】
    - 行为事件 => 业务处理 => 数据变化 => 视图渲染
      - **事件驱动业务逻辑**
      - **数据驱动视图**
  - Logic
    - 业务
      - Model 业务模型
      - Service 交互模型
    - 逻辑复用
      - 组件
        - 状态逻辑
        - UI
          - 模板
          - 原子样式
  - State => Logic
    - 状态管理
      - 如何与框架实现原理尽可能契合？
      - Model 组织结构管理问题
      - 细分领域管理
        - 表单状态
        - 流程状态
        - 请求缓存
    - 依赖注入
    - 容器组件模式
  - UI => Event
    - 双向绑定
- React vs Vue
  - React 为什么函数式开发范式
  - why hook（范式与原理哪个更为接近）
    - react 原生的响应式方案是非常依赖数据不可变性的，hook、函数式编程理念与 react 更为接近
    - vue：更好的逻辑分离与组合复用、类型推导
  - vue、react 区别
    - 渲染机制差不多，响应式机制一个可变
 



- 组件对象 component = props + state + render(viewModel) + effects
  - 组件交互性、状态持久性
- 组件范式
  - React 函数式组件
    - 多实例执行模型 => 并发渲染
    - 时序
    - React 内部托管状态
- 函数
  - 逻辑复用：函数组合
  - 代码组织：逻辑关注点聚合
- 前端代码分层
  - 视图层
    - 除了 Angular 之外，剩下的视图库都没有强调视图与业务逻辑的分离性，也就是说一个组件耦合了「视图」与「业务」，对 React 来说又是一大矛盾点，因为刚刚说了，React 的「视图模型」是基于函数式的，而「业务模型」往往是基于面向对象的。
    - 没有框架层面去约束或者给出最佳实践的后果就是，很容易诱导使用者把业务逻辑耦合到视图层，走向「状态驱动」的道路。很多时候的心智负担都来自于此，因为它的模式限制了业务逻辑的表达方式，无法追本溯源而是基于数据流去实现业务
    - 你会发现这些库（排除 Angular，它是框架），真的就只是在表达如何以更友好的方式描述 UI，一切的状态、事件都是为这个 UI 而服务的，而业务逻辑是可以脱离视图独立存在的，也因此只有 Angular 提供了开发业务逻辑的最佳实践（Service）
    - 我并不否认这几个库都可以采用 OOP，我一开始就说了，这是因为它们就仅仅是一个 DSL，它们没有提供一个开发业务的最佳实践，但是也提供了可操作的接口，比如依赖注入，比如生命周期或 useEffect，让你自行接入自己的逻辑，但也仅此而已，完备的模块化机制都没有（有别于 ESM 基于内容寻址的模块化，事实上 Angular 的模块化机制也还可以再进一步），所以采用何种范式进行业务开发全凭开发者自身的经验或者是社区的导向。
  - 应用层
  - 业务层
  - 数据层
- React vs Vue
  - 数据驱动
    - 不可变数据 VS 可变数据
- rx，zone，signal 一个解决异步流，一个控制函数调用栈，一个做数据响应式





- diff
  - 同层对比
  - type 变了就不再对比子节点
  - 移动：复用元素、尽量减少创建新元素
    - 判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的
    - 每个节点都是有唯一的标识 key，利用 key 复用
    - vue2 双端对比、vue3 最小递增子序列


- 框架原理
  - 响应原理
    - 原理
      - Vue
        - vue 和 mobx 这类基于 proxy 的响应方案，核心依赖的就是“容器对象引用不变，内部属性状态发生改变”，而面向对象的 class 实例的本质，就是一个引用不变的对象，里面有一些可变的状态，还有一些用来改变这些状态的动作。完美配合！
      - React
        - react 原生的响应式方案是非常依赖数据不可变性的
        - 监测变量引用（reference）的变化，然后整个子树去协调更新
        - 要求“内部不要变，容器整体引用要变”，也就是你每一个动作都必须生成一个新的实例，这样它才能检测到状态的变化。刚好和对象的特性是反的。这就天然切合声明式编程、FP 的特质。
    - 上层范式
      - 视图范式
      - 模型范式
      - 我们讨论 react class 组件是 FP 还是 OOP，其实不是讨论 class 组件 API 本身的风格，而是讨论“它作为 UI 库，更容易和 FP/OOP 哪种风格的 model 模型相对接
- js 的函数一等公民加上词法作用域，带来的闭包特性
  







- 闭包是将函数代码和其环境一起存储的一种数据结构
  - 闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分。一般来说，如果一门编程语言，其函数是一等公民，那么它必然会支持闭包（closure），因为函数作为返回值往往需要返回一个闭包
  - 闭包是一种特殊的函数，它会捕获函数体内使用到的上下文中的自由变量，作为闭包成员的一部分




- 错误分类
  - 可恢复错误
    - Logic errors 逻辑错误
  - 不可恢复错误
    - Runtime errors 运行时错误
    - Syntax errors 语法错误
      - ESLint
- 原则
  - 错误处理是程序员的事，是系统/架构/模块设计师的事，不是编程语言的事，只有正确认识错误处理原则，才能更好利用好编程语言中的错误机制设计
  - 错误是可预测的、可恢复的，应当立即处理
    - 比如，面对入参的错误，这是一种契约、明确的，应当中断执行并反馈
    - 面对操作结果的失败，应当立即、尽量处理
  - 异常，程序员忽略的或者没法在意、不可恢复的，这是一种没被处理的错误，意味着程序进入了一个未知的，不确定的状态，这是一个非常严重的错误问题
    - 面对异常，最好的做法是上报收集、系统隔离、奔溃重启
- 开发模式
  - 编写正确的代码，在编码过程中尽量处理完大部分的错误
  - 快速开发
    - 只处理少数的必要的错误
    - 粗略集中处理
    - 监控：实时抓取运行时发生的各种问题
- 编程语言中的错误处理模型
  - 编程语言应该尽力提醒程序员不要忽略错误
    - 错误码，容易忽略错误 ❌
    - 错误类型化，通过类型系统检查 ✅
  - 将正确逻辑和错误处理分隔开
    - 比如 `try-catch`
  - 错误传播及追踪
    - 返回值
      - 返回值具有二义性：返回值有它原本的语义，强行把错误类型嵌入到返回值原本的语义中 ❌
        - 可类似 Golang 多值返回，区分开错误返回和正常返回
      - 错误必须得到处理或者显式的传播
    - 异常抛出
      - 异常可以通过栈回溯（stack unwind）被一层层自动传递，直到遇到捕获异常的地方，如果回溯到 main 函数还无人捕获，程序就会崩溃
        - 异常看成一种关注点分离（Separation of Concerns）：错误的产生和错误的处理完全被分隔开，调用者不必关心错误，而被调者也不强求调用者关心错误
        - 使用异常来返回错误可以极大地简化错误处理的流程，它解决了返回值的传播问题
      - 异常安全、异常性能问题 😩
      - 开发者滥用，无脑往上抛 ❌
        - 无论什么错误都上抛，混淆、违背了“正确区分错误和异常”的原则
    - 编程语言提供自动传播的语法糖
  - 全局捕获
- 最佳实践
    - 错误类型化 + 类型检测
    - 未捕获的异常应该让应用程序崩溃、记录并重新启动


- 语言层-开发者角度
  - 异步
  - 并发
    - 数据竞争
    - 很多高级语言会把线程概念屏蔽掉，只允许开发者使用语言提供的运行时来保证并发安全  
      - Golang 要使用 channel 和 Goroutine 
      - Erlang 只能用 Erlang process，
  - 内存和资源安全
    - 类型系统
    - 所有权、借用检查和生命周期检查，来保证内存和资源一旦被分配，在其生命周期结束时，会被释放掉
    - 资源安全缺陷也是大部分语言都会有的问题，诸如文件 /socket 这样的资源，如果分配出来但没有很好释放，就会带来资源的泄漏，支持 GC 的语言对此也无能为力，很多时候只能靠程序员手工释放
      - 然而资源的释放并不简单，尤其是在做异常处理或者非正常流程的时候，很容易忘记要释放已经分配的资源
  - 语法错误


  - 错误处理缺陷
    - 缺少优雅的错误处理模式
    - 抛出的错误并没有得到处理，导致程序在后续的运行中崩溃
  - 代码风格和常见错误引发的缺陷：linter
  - 逻辑缺陷：单元测试覆盖率
  - 功能缺陷：需要通过足够好的集成测试，把用户主要使用的功能测试一遍
  - 用户体验缺陷：需要端到端的测试，甚至手工测试，才能发现





- 关键请求链
  - 预加载 preload
    - 关键 CSS




内存安全：Rust 使用所有权系统和借用检查来确保内存安全。每个值在 Rust 中都有一个称为其 “所有者” 的变量。值只能有一个所有者，当所有者离开作用域时，值会被自动清理。这可以避免诸如空指针解引用、双重释放、悬垂指针等问题。另外，Rust 的借用检查器确保了引用的有效性。在任何给定时间，要么只能有一个可变引用（用于读写数据），要么只能有多个不可变引用（用于读取数据），但不能同时有这两种引用。这个规则阻止了数据竞争和其他并发相关的内存错误。

线程安全：Rust 的所有权和借用规则同时也保证了线程安全。由于在任何时刻，一个值要么只有一个可变引用，要么只有多个不可变引用，这确保了在没有加锁的情况下，也不会出现数据竞争的问题。另外，Rust 的类型系统和标准库中还提供了一些并发抽象，如 Arc（原子引用计数类型）和 Mutex（互斥锁），它们提供了线程间共享状态的安全方式。

Rust 中的内存管理原理
在 Rust 中，内存管理是通过所有权（Ownership）、借用（Borrowing）和生命周期（Lifetimes）这三个概念来实现的。这种机制使得 Rust 在没有垃圾回收的情况下也能保证内存安全。

所有权：在 Rust 中，每一个值都有一个被称为其所有者（owner）的变量。值在任何时候都只能有一个所有者。当所有者（变量）离开作用域，这个值将被丢弃（drop）。






- 类型层级
  - any
    - 污染问题：any 可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错
  - unknown
    - unknown类型的变量，不能直接赋值给其他类型的变量（除了any类型和unknown类型）
    - 不能直接调用unknown类型变量的方法和属性
  - Object
  - 包装类型
  - 基本类型、值类型
  - undefined、null
  - never
    - 表示一种不存在、不会发生的值
    - never类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性
- 高级类型
  - 联合类型
  - 交叉类型 
    - 交叉类型的主要用途是表示对象的合成
- 类型缩小
- 类型编程
  - type
  - typeof
- 类型兼容
  - 如果类型A的值可以赋值给类型B，那么类型A就称为类型B的子类型（subtype）
- type vs interface
  - interface 仅仅是对象类型，type 任何类型
  - 接口可以声明合并





- React
  - React 渲染
    - 触发
      - setState、dispatch、forceUpdate
      - useSyncExternalStore
      - 再次调用 ReactDOM 顶级方法（相当于调用根组件）
    - 异步渲染
      - 批处理
        - 批处理次数
          - ```js
              const [counter, setCounter] = useState(0);

              const onClick = async () => {
                setCounter(0);
                setCounter(1);

                const data = await fetchSomeData();

                setCounter(2);
                setCounter(3);
              };
            ```
          - React 17 以原始事件处理期间为单位 - 执行 3次
          - React 18 以事件循环周期为单位 - 执行 2次
        - flushSync
      - 闭包陷阱和状态快照
  - vDom: render => diff => patch
    - reconcile
      - render => vdom
        - 在这个过程中，React 循环遍历整个组件树，查找标记为更新的组件
        - 对于每个标记的组件，从它开始，React 将递归渲染其中的所有子组件
          - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件
        - 渲染中 setState
          - 立即状态更新并重新渲染组件，[限制 50 次](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactFiberHooks.new.js#L430-L469)
      - diff
    - commit patch
      - 在提交阶段的生命周期中同步运行 UI 渲染
  - 并发渲染
    - 这使 React 能够在渲染阶段暂停工作以允许浏览器处理事件。React 将在以后适当地恢复、丢弃或重新计算该工作。一旦渲染过程完成，React 仍然会一步同步运行提交阶段
    - [Fiber](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193)
      - React 存储了一个内部数据结构，用于跟踪应用程序中存在的所有当前组件实例
      - React 将组件的所有 hooks 存储为附加到该组件的 fiber object 的链表
      - 在渲染过程中，React 将迭代这个纤维对象树，并在计算新的渲染结果时构造一个更新的树。
  - React 组件设计原则
    - 纯函数、不可变
      - 可变状态会导致 `UI = f(state)` 计算结果失效
    - 单向数据流规则
  - 性能优化





## 软件设计


[灰度上线系统](https://mp.weixin.qq.com/s/Mv3gG51UWA4b-6GquEEzfw)



第二次软件危机主要体现在软件的“扩展”变得非常复杂 => 面向对象思想设计

- 模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已
  - 从业务逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理部署的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是单元复用
- 框架关注的是“规范”，架构关注的是“结构”。


  - 模块是职责所分明、逻辑拆分，组件是单yu a
  - 框架 = 开发规范 + 基础功能

## 编程语言

- 语言学习路线
  - 基础
    - 变量、值和类型
    - 语句、表达式、运算
      - 控制语句
    - 函数
    - 模块系统
      - 模块路径
  - 数据结构
  - 面向对象编程
  - 代码调试及错误处理
  - 泛型编程
  - API
    - 文本
    - 文件
    - 网络编程
  - 高级特性
    - 并发编程
    - 异步编程
    - FFI
    - 函数式编程
    - 宏编程
- 返回值的编译实现
  - 堆上分配值，然后返回指针
  - 调用方分配空间，子函数内部使用父函数分配好的空间写入
- 运行时
  - 程序生命周期中的阶段
  - 运行时库
  - 运行时系统
- 代码复用（继承的另一个层面）
  - 代码拷贝
  - 指针拷贝
    - Mixin
  - 指针代理/委托/借用
    - 多态
    - 原型链
    - 作用域链
    - 组合
- 编程技巧
  - Class 类
    - 类也是一种模块
    - 在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如 java.util.Collections。
    - 代码复用
      - 抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用、覆盖（多态）
      - 我们可以把通用功能放到抽象类；而一些特定的行为或属性，我们可以通过继承放到实现类中
- 编程范式
  - 函数式编程
    - Lambda 演算和图灵机是等价的？
    - 函数式编程来自 λ 演算法
      - λ 演算，规则非常简单，只有三条
        - `<表达式>::= <标识符>`
        - `<表达式>::= (λ<标识符>.<表达式>)`
        - `<表达式>::= (<表达式> <表达式>)`
    - 用面向对象编程的方式对系统的结构进行搭建，然后，用函数式编程的理念对函数接口进行设计/或者说计算设计
      - 分离可变状态
      - 如何做到“不可变”？
        - 使用不可变的语法
        - 拷贝数据而不是修改
        - 如果要使用变量，只使用局部变量
        - **事件溯源（Event Sourcing）**：把对象的状态每次变化抽象成独立的事件进行保存，对象的状态变化可由一系列事件的调用重现。
      - 副作用隔离
        - Monad
      - 可组合性 => 接口 => 抽象 => 分离关注点
        - 函数的合成还必须满足结合律
- 类型
  - 类型层次
    - 向上转型？
  - 结构化类型
    - 接口标记
- 接口和抽象类
  - 抽象类可扩展功能
  - 接口是对行为的抽象
  - 接口的多继承
  - 接口标记

## JavaScript


- 值保证不会显式改变一个量，而纯函数保证的是，不会隐式改变一个量
- 不可变就是在减少程序被外界影响的同时，纯函数减少对外界的影响



        - 脏东西，这种被称为对现实世界的影响（Effect）
        - 因为脏东西被装在盒子里，我们又回到了纯函数的世界。换句话说，在计算的过程中，一旦出现了脏东西，那我们就用一个新盒子把它装进去，然后对自己说，“这个盒子里有个脏东西”，然后进行下一步。注意到，我们没有打开盒子，所以自然就没有对世界产生任何影响。
        - 把这个装了脏东西的盒子当做函数的输出
          - 打开的过程是有影响的，但是在计算f(x)的过程中，是纯函数，是没有影响的。这就是我们经常说的，要把影响（或者说副作用）push to edge，即推到纯函数的外面，程序的边缘地带。

- 函数操作复习
  - 部分应用可以减少每次函数调用时需要传入的参数，而柯里化更是把函数调用时需要传入的参数数量，降到了 1。它们实际上都起到了控制参数数量的作用
  - 通过柯里化每次传一个参数
- Pointe-Free Style
  - var isOdd = (x) => equalsToOne(remainderOfTwo(x));
  - point free 的理解：把参数去掉，是指参数的含义已经体现在函数声明（名字）里面了，比如 equalsToOne，那就是说传入的值是否等于 1，如果是 equalsToA，那么这个 A 就得传为参数，加上要比较的 x 就是两个参数了。这就是所谓“暴露给使用者的就是功能本身”。
- reducer

  - 它最主要的作用其实是解决在使用多个 map、filter、reduce 操作大型数组时，可能会发生的性能问题。而通过使用 transducer 和 reducer，我们就可以优化一系列 map、filter、reduce 操作，使得输入数组只被处理一次并直接产生输出结果，而不需要创建任何中间数组
  - composeReducer 原理

- Pointfree 就是如何使用函数式编程的答案
- Pointfree：不使用所要处理的值，只合成运算过程
- Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算
- 简单说，Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。



- 对象
  - 公开属性
  - 私有属性
  - 静态属性
    - 静态属性只能作用于 class 本身。
    - 普通属性里调用
  - 静态私有属性
- 实现私有属性
  - 主要有闭包、WeakMap 和 Symbol 这三种方式。
    - 构造器 + 闭包
      ```js
      function WidgetG() {
        var appName = "天气应用";
        this.getName = function () {
          return appName;
        };
      }
      WidgetG.prototype = (function () {
        var model = "支持安卓";
        return {
          getModel: function () {
            return model;
          },
        };
      })();
      var widget7 = new WidgetG();
      console.log(widget7.getName()); // 返回 “天气应用”console.log(widget7.getModel()); // 返回 “支持安卓”
      ```
- WeakMap，它的特点是只接受对象作为键名，键名是弱引用，键值可以是任意的
- 多态
  - 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法
  - 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
  - 多态机制使内部结构不同的对象可以共享相同的外部接口。即子类可以重写父类的某个函数，从而为这个函数提供不同于父类的行为。一个父类的多个子类可以为同一个函数提供不同的实现，从而在父类这个公共的接口下，表现出多种行为。
  - 多态的使用场景：当类之间存在层次结构，并且类之间是通过继承关联时。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
- 组合、继承意义
  - 业务开发
  - 基础设施？
- object 接口


- js 类实现、Object.create
- 实现私有属性的方法其实就两种：闭包和 symbol
- 在 JavaScript 中，this 是在运行时而不是编写时绑定的。所以要正确地使用它，需要考虑到函数调用时的执行上下文。
- 在 this 的绑定中，有一点是需要我们注意的，那就是当我们使用箭头函数的时候，this 是在词法域里面的，而不是根据函数执行时的上下文。
- 箭头函数区别
  - 不能作为构造函数
- 为什么 0.1+0.2 不等于 0.3？
  - 解决
- 如何判断一个值是不是数字

## 网络

- 网络性能
  - 吞吐量
    - 带宽
  - 抖动
    - 最大延迟与最小延迟的时间差
    - 时延
      - 排队时延
      - 处理时延
      - 发送时延
      - 传播时延
  - 丢包率
    - 包损坏
    - 超过 MUT
    - 超过 TTL
    - 网络发生拥塞，数据流量太大，网络设备处理不过来自然而然就有些数据包会丢了
- 数据交换：先从一条链路进入交换设备，然后缓存下来，再转发（切换）到另一条路径 ![图 1](../images/49aed7f5d78350299c7b04323efbb17a625247f4a064c17951f89482582f54da.png)
  - 交换技术的本质，就是让数据切换路径
- 网络传输
  - 类型
    - 端到端（Host-to-Host）
    - 广播的能力，是一对多、多对多
  - 分片传输
  - 寻址：路由、路径选择
    - 网络状态
- 网络问题
  - 乱序
  - 丢包
  - 阻塞、延迟
- 网络性能指标
  - 吞吐量
  - 丢包率
  - 延迟
- TCP（Transport Control Protocol）是一个传输层协议，提供 Host-To-Host 数据的可靠传输，支持全双工，是一个连接导向的协议。

  - 序号
  - 丢包
    - 请求/响应模型
    - 确认与重发的机制
      - 超时重传：每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试
        - TCP 动态采样 RTT 的时间进行加权估算超时时间
        - 超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
      - 快速重传：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段
        - 例如，接收方发现 6 收到了，8 也收到了，但是 7 还没来，那肯定是丢了，于是发送 6 的 ACK，要求下一个是 7。接下来，收到后续的包，仍然发送 6 的 ACK，要求下一个是 7。当客户端收到 3 个重复 ACK，就会发现 7 的确丢了，不等超时，马上重发
    - 收到应答包确定连接建立
  - 流量控制（大小）
    - 滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满
  - 拥塞控制（速度）

- TCP 和 UDP 有哪些区别？
  - TCP 是面向连接的，UDP 是面向无连接的。
    - 所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。
  - TCP 提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
    - UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。
  - TCP 是面向字节流的
    - UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。
  - TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，管它洪水滔天
  - TCP 其实是一个有状态服务，通俗地讲就是有脑子的，里面精确地记着发送了没有，接收到没有，发送到哪个了，应该接收哪个了，错一点儿都不行。而 UDP 则是无状态服务。通俗地说是没脑子的，天真无邪的，发出去就发出去了。
- MAC 层定义了本地局域网的传输行为
- IP 层定义了整个网络端到端的传输行为
- 网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。我们笼统地称为包
- IP 头里面有个 8 位协议，这里会存放，数据里面到底是 TCP 还是 UDP，当然这里是 UDP
- 适合场景
  - 需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用
  - 不需要一对一沟通，建立连接，而是可以广播的应用
  - 需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候
    - TCP 在网络不好出现丢包的时候，拥塞控制策略会主动的退缩，降低发送速度，这就相当于本来环境就差，还自断臂膀，用户本来就卡，这下更卡了。
    - HTTP 协议，往往采取多个数据通道共享一个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不来，后一个和前一个即便没关系，也要等着，时延也会加大。
    - 流媒体的协议
      - 直播
        - 实时性比较比较重要，宁可丢包，也不要卡顿的
        - 对于丢包，其实对于视频播放来讲，有的包可以丢，有的包不能丢，因为视频的连续帧里面，有的帧重要，有的不重要，如果必须要丢包，隔几个帧丢一个，其实看视频的人不会感知，但是如果连续丢帧，就会感知了，因而在网络不好的情况下，应用希望选择性的丢帧。
    - 实时游戏
- TCP/UDP 建立连接的本质就是在客户端和服务端各自维护一定的数据结构（一种状态机），来记录和维护这个“连接”的状态 。并不是真的会在这两个端之间有一条类似“网络专线”这么一个东西（在学网络协议之前脑海里是这么想象的）。
- 在 IP 层，网络情况该不稳定还是不稳定，数据传输走的是什么路径上层是控制不了的，TCP 能做的只能是做更多判断，更多重试，更多拥塞控制之类的东西。
- 滑动窗口

  - 流量控制
  - 拥塞控制

- 内网服务外网用
  - 动态公网 IP + DDNS
  - 内网穿透
  - IPv6
- 称呼
  - TCP,段
  - IP，数据包
  - 链路层，Frame（帧）
- 其他
  - 吞吐率：吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps
- 传输层
  - 通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割
  - TCP
- 网络层、链路层
  - 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地
  - 网络层
    - IP 寻址
    - 选路
      - BGP
  - 性能至上的 IP 层
    - 无连接、非可靠、无确认
  - 数据链路层
    - 封装帧
    - MAC 寻址
    - 定义物理层标准
  - 路由器
    - 网络层
    - 连接不同网络
  - 交换机
    - 链路层
    - 连接同一网络下的不同主机
    - 交换
      - 交换技术的本质，就是让数据切换路径。因为，网络中的数据是以分组或封包（Packet）的形式传输，因此这个技术也称作封包交换技术（Packet Switch）
      - 具有交换能力的设备
        - 路由器
        - 链路层交换机
- 称呼

  - 传输层：TCP 段
  - 网络层：IP 封包 Packet
  - 链路层：Frame

- 保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量
  - 滑动窗口
    - 传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供
- 网络安全
  - https 安全协议
  - 防火墙
- Whireshark 追溯的是最底层网卡传输的 Frame（帧），可以追溯到数据链路层。因此对二进制形式的解读，也就是我们的消息视图也要分层。因为对于同样的数据，不同层的解读是不同的。
- 网之初，性本善，不丢包，不乱序

## CSS

- 大型项目的 CSS 编写和维护
  - 难点
    - 协作难 易冲突 维护苦 灵活性差
  - 需求
    - 可维护性
    - 可扩展性
    - 可重用
  - CSS 规则难以管理
    - 全局命名空间
    - 权重(特异性)
    - 级联规则
  - CSS 的最佳实践
    - 样式表和关注点分离
    - CSS 方法论
      - BEM
      - CSS Modules
      - Atomic CSS

## Web

- 抓包
  - whistle
  - Charles
- 调试

  - vConsole
  - eruda
  - Chrome、Safari 远程调试

- 可视化大屏幕
  - 定宽高
  - 等比缩放


- 页面加载
  - 网络层
    - 连接复用
    - 并发连接
    - CDN
    - 缓存
    - 减少页面初载时，所需加载资源的「数量」和「体积」
      - 体积
        - 代码拆分、延迟加载非关键代码
          - 使用 DevTools 代码覆盖确定可以删除或延迟加载的代码的机会
        - 缩小
          - 混淆
          - 删除未使用的代码
          - 使用 babel-preset-env 和 browserlist 来避免转译现代浏览器中已有的功能
          - tree-shaking
        - 压缩
  - 初始渲染
    - 减少阻塞渲染的请求
      - 将脚本标签放在 body 标签的底部；
      - 使用 async 异步加载脚本；
      - 内联小型 JS 或 CSS 代码段（如果它们需要同步加载）
    - 避免阻塞渲染的顺序请求链
      - 内联合并
      - 预加载或预连接
- 页面交互

[延迟加载非关键 CSS](https://web.dev/defer-non-critical-css/)

- devtool
  - 测量 Performance
  - 优化 Coverage
- 提取关键 css
  - [critical](https://github.com/addyosmani/critical)
- 异步加载非关键 CSS
  - `<link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="styles.css"></noscript>`
- 预加载关键资产以提高加载速度

- preconnect
- prefetch
- preload

- WebGPU
  - [Babylon.js](https://github.com/BabylonJS)
- 页面
  - 加载
    - 减少资源文件的请求数量
    - 减小每个资源文件的大小
      - 懒加载
        - 按路线拆分代码
      - 分析大小、组成
        - 使用 webpack-dashboard 和 webpack-bundle-analyzer 等工具来了解您的应用程序有多大。每隔几个月重新审视一下您应用的整体性能
        - bundlesize 验证 webpack 资产不超过指定的大小。将它与 CI 集成，以便在应用程序变得太大时得到通知
    - 提高每个资源的加载速度
      - 缓存代码
  - 交互
- 评审工具
  - Lighthouse
- 性能优化
  - 资源大小
  - 资源调度
- pwa
  - 首屏优化
    - 静态资源优化
      - precache
    - 动态数据优化
      - 字典数据 swr
    - 直出的 html
- 实现端到端类型安全
  - tRPC、Zod、PrismatTanStack Router

## 音视频

- 流媒体

  - 本质：将音视频数据进行切片，可传输一部分即可播放一部分
  - HLS（HTTP Live Streaming）：HTTP 直播流

    - m3u8：m3u8 文件是目录，它记录了每个视频切片文件（ts）对应的视频时间范围
    - 直播流架构 ![图 4](./images/5d3d66258cc08d1d063603997f4913b66d15104a63414fd2dee44eac2953c8d8.png)

  - 直播
    - 录制端不断上传视频内容，视频内容编码后流媒体服务器负责分发
    - m3u8 文件可以看作一个动态的文件，能够不断产生新的数据。因此直播技术中，可以考虑将获取 m3u8 文件设计成一个接口，不断由播放器请求新的 m3u8 文件
    - 架构 ![图 3](../images/9d38c82021f15ed2b092e7925232ade8b4bb023af32e876d0b300af18854f317.png)
      - 录制端：负责录制直播视频，用流的形式上传。
      - 计算集群：专门负责编码上传的流数据，然后进行压缩、转码、切片等工作。
      - 对象存储：存储原始视频和转码后的视频（相当于 CDN 的源，回源用）。
      - CDN：将转码后的内容分发到离用户较近的节点，方便用户获取。
      - 直播 App：给用户看直播时使用

- 视频的编码和解码

## web

- Web 生态架构
  - 协议方面
    - HTTPS 强化通信链路安全
    - HTTP/2 优化传输效率
  - 应用方面
    - Nginx/OpenResty 提升网站服务能力
    - WAF 抵御网站入侵攻击
    - CDN 内容访问加速
    - 浏览器

## 其他

- hash：每次 hash 值的变化，浏览器不发出请求，也就不会刷新页面，还会触发 hashchange
- history：pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求

  - 但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求
    - 为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。

- git
  - husky
  - lint-staged
  - commitlint
- 版本发布：发版与 CHANGELOG 自动化

  - standard-version
  - 根据指定规则自动升级项目不同级别（major、minor、patch）的版本并打 tag
  - 对比历史 commit 提交自动生成不同版本间的可阅读、分类的 CHANGELOG 日志

- em 相对于自身元素的 font-size

- web 攻击

  - 点击劫持
  - 跨站脚本 (XSS)
  - 跨站请求伪造 (CSRF)



https://github.com/dcastil/tailwind-merge

提示浏览器如何加载资源



- Referer

  - Referrer-Policy
    - 默认：`Referrer-Policy: strict-origin-when-cross-origin`
      - 同源时，发送完整的 Referer 字段；
      - 跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，否则发送源信息
  - 设置 Policy 的方法
    - 元素属性
      - rel
      - referrerpolicy
    - 标签设置整个网页的 Referer Policy 策略
    - Headers 请求头：`Referrer-Policy: no-referrer`
  - 作用及使用场景
    - 防盗链：按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问
    - 埋点分析：Referer 提供用户的来源网址和整体访问链路
    - 错误排查（接口日志）

- HTTP/0.9
  - request 只有一行且只有一个 GET 命令
- HTTP/1.0
  - 增加状态码
  - 在 request 和 response 中添加 header 的概念
  - 在 header 中添加 content-type 以此可以传输 html 之外类型的文件
  - bad
    - http 队头阻塞
    - 短连接
- HTTP/1.1

  - 长链接 keep-alive
  - chunked 机制，分块响应
  - 缓存控制
  - 内容协商，包括语言、编码和类型，客户端和服务器现在可以就交换哪些内容达成一致
  - 请求头域中新增了 Host 字段：处理一个 IP 地址上面多个虚拟主机

- 数组

  - slice
  - Object.keys([...new Array(6)])


- 充分利用可用空间
  - `width: 100%`
  - `width: fit-content`
- 收缩与包裹 
  - `width: fit-content`
- 收缩到最小
  - `width: min-content`


- 函数
  - this
    - 修改 this
      - call
      - apply
        - `func.apply(context, args)`
      - bind
        - 绑定 this，生成新的函数对象
    - 回调函数中防止 this 丢失
      - 包装
      - bind
  - 装饰器
    - 装饰器 是一个围绕改变函数行为的包装器。主要工作仍由该函数来完成。
  - 部分（应用）函数（Partial functions）



- 链表（单链表）
  - 单链表翻转
  - 字符串是否是回文字符串的问题
  - 两个有序的链表合并
  - 删除链表倒数第 n 个结点
  - 求链表的中间结点
- 树
  - 树的前中后序遍历
  - 验证二叉搜索树
  - 104. 二叉树的最大深度 - 力扣（LeetCode）
  - 二叉树
    - 104. 二叉树的最大深度
    - 144. 二叉树的前序遍历
    - 543. 二叉树的直径
    - 剑指 Offer 55 - I. 二叉树的深度
- 排序
  - 快排
- 分治
  - 算法
    - 二分查找（以及变形）
    - 归并思想
      - 归并排序：912. 排序数组 - 力扣（LeetCode）
  - 海量数据处理
  - 题目
    - pow
- 回溯
  - 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作为一个子问题
  - 题目
    - 全排列问题：给定一个集合，求出其所有可能的排列组合
  - 78. 子集 - 力扣（LeetCode）
  - 51. N 皇后 - 力扣（LeetCode）
  - 全排列
- 动态规划
  - 问题分解
  - 题目
    - 爬楼梯以及变形问题
    - 斐波那契数列
    - 最小路径和
    - 0-1 背包问题
      - 给定 n 个物品，每个物品都有各自的价值 vi 和重量 wi，现在给你一个背包，背包所能承受的最大重量是 W，那么往这个背包里装物品，问怎么装能使被带走的物品的价值总和最大
    - 零钱兑换
      - 零钱兑换 II 
    - 编辑距离
    - 股票问题
- 贪心：局部最优解
  - 每一个阶段，我们都选择当前看起来最优的决策
  - 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法
- 树
  - 组合状态：构建解空间/解答树、决策树
    - 遍历
      - 回溯
    - 递推/动态规划
  - 分解状态：分解问题树
    - 递归/分治
    - 递归/动态规划


- LeetCode 第 91 题，
- LeetCode 第 51 题 黄河

- 搜索问题：找到满足特定条件的解决方案
  - 排列
    - [全排列](https://leetcode.cn/problems/permutations/description/)
    - [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)
  - 子集和
    - [78. 子集](https://leetcode.cn/problems/subsets/)
  - 组合优化






常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

循环链表
链表操作



栈在表达式求值中的应用
栈在函数调用中的应用
栈在括号匹配中的应用
如何实现浏览器的前进、后退功能
leetcode 上关于栈的题目大家可以先做 20,155,232,844,224,682,496.

循环队列
确定好队空和队满的判定条件。
队空 head = tail
队满(tail+1)%n=head
队列应用 09 | 队列：队列在线程池等有限资源池中的应用
请求排队 任务排队调度
不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

- 将 table / list 抽象，用类似 scheme 驱动的方式
- ui 都有差异,在设计层面，可能由于业务需求，很难做到统一，不得已自带设计体系
- 后端数据模型没有统一，因此对接数据前后涉及到的前端状态管理、数据流转也未能统一，复用性大打折扣。

因为屏幕像素密度问题，根据 devicePixelRate 不同要将 canvas 设置对大小



- 阿里三面：灵魂拷问——有 react fiber，为什么不需要 vue fiber 呢？
  - React 从诞生之日的设计哲学就是，当状态发生变化时，重新创建所有视图。
  - 即使你只是修改了组件树最深处的一个小小的状态，React 仍然需要自顶重新创建整个 vdom 树并且 Diff
  - 引入 fiber 机制后使得 React 的渲染过程可以中断，让出主线程响应用户事件，或者允许插入更高优先级的更新
  - Vue 有一套细粒度的响应式机制，框架的更新粒度是组件级别，除此之外还有 Block Tree 等分离静态/动态模板的优化手段，更新的效率是足够高的，也就没有必要引入 fiber 这样的机制
- why react fiber



- 关键请求：如何确定请求的优先级以提高速度

- 闭包是指函数能够记住和访问其词法范围，即使该函数在其词法范围之外执行也是如此。

- 箭头函数

  - 没有 arguments
  - 无法通过 apply、call、bind 改变 this 指向

- 位运算
  - 与
  - 或
  - 异或
  - 取反
  - 左移
  - 右移
- 字典树


- 代码

  - 构建 CommonJS (CJS) 和 ECMAScript (ESM) 模块格式 - p
    `   "exports": {
  ".": {
    "import": {
      "types": "./lib/esm/types/index.d.ts",
      "default": "./lib/esm/index.mjs"
    },
    "require": {
      "types": "./lib/cjs/types/index.d.ts",
      "default": "./lib/cjs/index.js"
    }
  }
},`

                                                      ```
                                                      “types": "./lib/cjs/types/index.d.ts",

                                                "main": "./lib/cjs/index.js",

                                                ```

                                                ```

- 单元测试
  Mocha.js、Chai.js 和 ts-node。Mocha.js 是一个测试运行器，Chai.js 是一个断言库，用于帮助确定您是否从代码中获得了预期的结果，而 ts-node 帮助我们在 TypeScript 项目中使用这些工具。
- 集成测试
  - 本地
    - npm link
    - npm pack
  - 代理
    - Verdaccio
- 发布包
  - 在您的文件中添加一个 files 字段 package.json，以指示当 npm 打包您的代码以供发布时应包含哪些文件。
  - npm version <major|minor|patch>
  - prepack 在打包 npm 包以准备发布到注册表之前，npm 使用该脚本
  - 安全检查
  - `npm publish --access=public`
  - 自动化版本管理和发布
- 集成 CI/CD



- JS

  - Tagged template literals
  - Symbols
  - 2020
    - Optional chaining
    - Nullish coalescing operator (??)
    - import()
    - String.matchAll
    - Promise.allSettled()
  - 2021
    - String.replaceAll()
    - Promise.any
    - Nullish coalescing assignment (??=)
    - Logical and assignment (&&=)
    - Logical or assignment (||=)
    - WeakRef: Hold a “weak” reference to an object, without preventing the object from being garbage-collected.
  - 2022



- `new Function`
  - `new Function ([arg1, arg2, …argN], functionBody)`
  - 上下文是全局的
  - 场景：动态生成代码、计算

```js
const pipe =
  (...fns) =>
  (value) =>
    fns.reduce((v, fn) => fn(v), value);

const asyncPipe =
  (...fns) =>
  (value) =>
    fns.reduce((chain, fn) => chain.then(fn), Promise.resolve(value));

const compose =
  (...fns) =>
  (value) =>
    fns.rightReduce((v, fn) => fn(v), value);
```

- Vue

  - 如何避免 data 中一个复杂对象（自身或属性对象）被默认被创建为响应式（Non-reactive Object）的过程
    - Object.defineProperty
    - Object.frezen



- ui、api、rpc、mq、servcie、db
- node 服务开发
  - 部署、devops 工具；
  - 远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们常见的 PM2；
  - 我们需要判断远程服务运行是否正常，这就涉及远程服务的监控和告警机制；
    - 遇到运行问题时，我们需要通过远程日志来定位分析问题，这就涉及日志打印和跟踪染色。
  - 后端服务应用则必须关注服务的稳定与安全。因为都是基于用户发送的内容，用户有时候发送一些非法或者违法的内容。
  - 其次需要关注并发性能，因此必须充分考量服务器所能承载的最大用户并发数，在并发即将达到阈值时，又需要考量平行扩容方案。还有就是为了用户体验，需要充分做好服务的性能优化，做到极致的接口响应时间。
- 你需要在每个业务场景中，思考在哪里进行一些关键逻辑或者数据打印日志信息，这里就需要 Node.js 日志服务模块，而这类日志服务又不能影响性能，因此需要考虑一些高性能日志打印工具。其次在服务端运行，你可能会遇到诸如内存泄漏、句柄泄漏或者进程异常退出等问题，因此这里就需要这类工具和方法来分析定位现网问题。

- 前端代码分层架构
  - 视图层
  - 业务层
    - Model：描述业务的实体对象，是业务所围绕的核心概念，你的公司所做的业务，本质上就是在创建和处理这些对象
    - Service：描述工作流程的服务对象，它们主要是对实体对象的处理过程、逻辑、事件，是使得业务产生实际效果的非实体对象
      - 领域模型帮我们描绘了有关这个业务的核心对象的各种逻辑，但是，我们的这个业务实体会面对很多场景，每一个场景下，可能存在有些特定的转化逻辑，这就需要我们在领域模型的基础上，提供对应场景的服务。简单讲，你可以把领域服务想象成领域模型实例的处理工厂，在这些处理中，我们是为了描述特定场景下的业务需求，所以，领域服务仍然是业务描述，和 UI 无关。
    - 总而言之，领域模型是相对比较普遍的业务描述，而领域服务是相对比较特殊的业务描述。
    - 一般来讲，服务需要遵循无状态的原则，状态一般会放在领域模型中。
    - 数据驱动视图，事件驱动业务逻辑
    - 业务开发下，更应该关注的是业务模型，行为指令，这才是最好维护的
    - 视图层只做 data 消费，业务写在 Model 层
    - 不要视图驱动业务模型
  - 数据层
  - 交互模型
    - 交互有两种，一种是界面交互，一种是业务交互
    - 交互模型会引用领域模型和领域服务，同时，它还会被用到视图层中，交给视图层使用
    - 可以把交互模型和我们平时讲的“状态管理器”划一个约等号，交互模型的实例向视图层提供状态属性和方法，属性用于视图层进行渲染，而方法用于事件回调

  



- js 正则相关 api
- 数组、字符串 api



- 发布
- 消费
- 生产


- 函数式编程
  - 为函数运算，并且避免使用程序状态以及易变对象
  - λ演算为该语言最重要的基础
    - λ演算的函数可以接受函数作为输入参数和输出返回值
  - Pointer


- URL

  - QueryString
    - 结构：`field1=value1&field2=value2&field3=value3...`
    - 多个 value 关联到同一个 field（无明确处理规范）
      - `key=a&key=b`（建议优先此形式）
  - URL 编码：将非 ASCII 字符转换为百分号编码形式（`%HH`：先转成 UTF-8 编码，再对每个字节进行%HH 的编码）
    - `encodeURI`
    - `encodeURIComponent`：URL 中有特殊含义的字符（如 空格、%、&、=、?、# 等）无法直接在 Query String 中使用
      - % 百分号编码为 %25
      - 空格编码为 %20（建议优先）或 +；
        - decodeURIComponent，是无法解析 + 为 空格的
    - qs
      - 自定义性强
      - 多层嵌套对象（Nested object）的支持
      - 使用场景：拥有强大的序列化能力，可以处理复杂的类 JSON 数据。
    - URL/URLSearchParams
      - 适合常规的 Web 端数据传输，处理平面数据结构
      - URLSearchParams 采用了 application/x-www-form-urlencoded 编码模式，而这个编码采用了一个非常早期（RFC 1738）的通用百分号编码方法——就是将 空格转换为+
  - x-www-form-urlencoded：是一种常见的编码格式，用于将表单数据编码为 URL 查询字符串
  - 空格编码为 +；






- lint 机制和 IDE 提示

  - git hooks

- 如何将主线程还给浏览器，以便浏览器更新页面？
  - 时间切片 + 宏任务
    - 因为宏任务是在下次事件循环中执行，不会阻塞本次页面更新，而微任务是在本次页面更新前执行
    - React Scheduler 使用 MessageChannel 就是为了产生宏任务，
      - 嵌套深的 setTimeout(fn, 0) 最低 4mm 间隔延迟
- 如何通过 postMessage 实现一个真正 0 延迟的定时器

  ```js
  (function () {
    var timeouts = [];
    var messageName = "zero-timeout-message";

    // 保持 setTimeout 的形态，只接受单个函数的参数，延迟始终为 0。
    function setZeroTimeout(fn) {
      timeouts.push(fn);
      window.postMessage(messageName, "*");
    }

    function handleMessage(event) {
      if (event.source == window && event.data == messageName) {
        event.stopPropagation();
        if (timeouts.length > 0) {
          var fn = timeouts.shift();
          fn();
        }
      }
    }

    window.addEventListener("message", handleMessage, true);

    // 把 API 添加到 window 对象上
    window.setZeroTimeout = setZeroTimeout;
  })();
  ```

- css
  - bfc 布局规则
- js
  - 说一下原型链，原型链实现继承。
  - vue 中 nextTick 的实现，结合浏览器事件循环机制说一下？
  - 说说 commonjs 和 esmodule？
  - 手写简版 promise，基础架子，不用写 all、race 等 api
  - 手写 bind
- 框架原理
  - vue 模板编译原理
- http
  - http 和 tcp 协议？
  - 缓存相关（对比缓存？强缓存？对应请求头）
  - cookie 有哪些属性？
  - options
  - 简单请求？
  - 跨域？
- 浏览器
  - 为甚么要有同源策略？dns 劫持？
  - 渲染原理
- 算法
  - 回文字符串个数
  - 猴子吃香蕉
  - 爬楼梯
  - 最长公共子串
- 项目
  - 项目怎么做的移动端适配？
    - flexible 原理
    - 移动端的 1 像素问题怎么解决
  - 团队协作，以前的开发流程？
- 其他

  - 职业规划？
  - 有什么问题吗？
  - 为什么要离职？
  - 怎么学习的？


- VDOM 的更新机制
  - render：组件渲染生成一棵新的虚拟 dom 树；
  - diff：新旧虚拟 dom 树对比，找出变动的部分；（也就是常说的 diff 算法）
    - 旧 diff 算法 = 同层对比 + 深度优先 + 前序遍历
  - patch：为真正改变的部分创建真实 dom，把他们挂载到文档，实现页面重渲染；
- why react fiber
  - 在数据更新时，react 生成了一棵更大的虚拟 dom 树，给第二步的 diff 带来了很大压力，树的递归过程没法暂时停止，阻塞用户响应
  - diff 过程切片，react fiber 使得 diff 阶段有了被保存工作进度的能力
    - 为什么有了 react fiber 就能断点恢复呢；
      - fiber 是链表结构，只要保留下中断的节点索引，就可以恢复之前的工作进度；
- 有 react fiber，为什么不需要 vue fiber 呢？
  - vue 基于数据劫持 + 编译优化，能够更加精确更新
- hooks
  - 实现
    - hooks 实现内部实现实际将组件状态放在组件实例对应的 Fiber 节点里面。
  - why hooks
    - hooks 对并发友好：并发过程 React 内核可以维护多份数据模型，并发渲染“多个版本”的组件树
      - 而如果你用了 class 组件，就很容易出问题，因为“多个版本”的组件树，其中 class 组件的实例对象是共享的，
- Vue 与 React 框架的对比
  - 范式
  - 生态
  - 原理
- 渲染机制
- 设计思想
- 响应式原理
  - react
    - 不可变、setState
    - 会自顶向下重新渲染组件，自顶向下的含义是，该组件以及它的子组件全部需要渲染
    - 手动优化
  - vue
    - 可变、响应式
    - vue 使用 Object.defineProperty（vue@3 迁移到了 Proxy）对数据的设置（setter）和获取（getter）做了劫持，也就是说，vue 能准确知道视图模版中哪一块用到了这个数据，并且在这个数据修改时，告诉这个视图，你需要重新渲染了
  - 所以当一个数据改变，react 的组件渲染是很消耗性能的——父组件的状态更新了，所有的子组件得跟着一起渲染，它不能像 vue 一样，精确到当前组件的粒度。
- Vue
  - 性能
    - 响应式
      - proxy
    - diff
      - 静态标记
  - ref 和 reactive 的区别



- 响应式更新：响应式更新」描述的是「状态与 UI 之间的关系
  - 状态变化如何映射到 UI 变化
- 单向数据流：单向数据流」描述的是「组件之间的关系
  - 当状态变化后，变化产生的影响只会从上往下传递
- 双向数据绑定：「双向数据绑定」描述的是「组件内逻辑与视图的关系」

- http 连接

  - 请求响应和长连接
    - keep-alive
      - Keep-Alive 是 HTTP 1.1 版增加的功能
  - 当一个网站需要加载的资源较多时，浏览器会尝试并发发送请求（利用多线程技术）。浏览器会限制同时发送并发请求的数量，通常是 6 个，这样做一方面是对用户本地体验的一种保护，防止浏览器抢占太多网络资源；另一方面也是对站点服务的保护，防止瞬时流量过大
  - HTTP 2.0 的多路复用




- Q640】如何实现数组函数 reduce #658
- const reduce = (list, fn, ...init) => {
  let next = init.length ? init[0] : list[0]
  for (let i = init.length ? 0 : 1; i < list.length; i++) {
  next = fn(next, list[i], i)
  }
  return next
  }
- 什么是防抖和节流，他们的应用场景有哪些
- 实现一个数组扁平化的函数 flatten
- const flatten = list => list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), [])
- 如何实现一个深拷贝 (cloneDeep)









- 拆分-按需加载
- 缩小
  - 混淆
  - 代码升级
  - Removing unused code.
    - DevTools code coverage.
    - analysis of their webpack bundles
- 压缩
- 缓存
  - http
  - V8’s code cache
- PRPL（推送、渲染、预缓存、延迟加载）是一种通过积极的代码拆分和缓存来优化互动的模式：




- 16
- 18
- 19
- 25
- 26
- 32
- 35
- 49
- 52
- 54






- URL
- 正则
  - 分割行而不包含行终止符 str.split(/\r?\n/)
  - 分割行同时包含行终止符 /(?<=\r?\n)/
  - 多行文本消除首尾**空白符**：`string.replace(/^\s+|\s+$/g,"")`
  - js 正则相关 api
- 框架 xss 防范
  - xss
    - js
    - 拼接 HTML + encode
  - script
    - 逃逸
- 主题切换
  - 原理
    - 主题生成：CSS 原生变量/CSS 预构建 + CSS 样式覆盖
    - 切换、触发
      - 跟随系统
        - `prefers-color-scheme`
        - `window.matchMedia("(prefers-color-scheme: dark)").matches`
      - class、dataset 手动切换策略
        - `class.dark`
        - `[data-theme]=dark`
  - 现有工程改造
    - postcss/stylelint
    - 查找 & 替换】所有颜色变量
    - 通过 Stylelint 编辑器插件提示,保存时自动替换
  - 状态封装
    - [useColorMode](https://vueuse.org/core/useColorMode/)


- Web 安全

  - 网络
    - TLS
      - 自签名
    - Http
      - Helmet
  - 密码
  - 身份验证
    - JWT 这类令牌的场景，是多个系统间通过非信任通道（数据发到浏览器再由浏览器发到另一个系统）传递数据（这也是典型的第三方登录的场景）而不是当会话用，也不是在一个完全自己控制的系统中传数据用，也不是在消息队列发消息用。

- glob 语法

  - `*`：任何路径段
    - 星号不匹配名称以点开头的“不可见文件”，如果我们想匹配这些，我们必须在星号前加上一个点：`.*`
  - `**`：匹配零个或多个路径段
  - `!`：排除
  - `\{xx,xx\}`：可选匹配


- 以各种编码对文本进行编码和解码
  - 类 TextEncoder< /code> 或类 TextDecoder
- 文本
  - 字符串拆分成行
    - RE_SPLIT_EOL = /\r?\n/;
    - /(?<=\r?\n)/
  - 通过流行读取文本文件
  - 写入
    - 覆盖
    - 增加
- 目录

  - 操作系统特定的全局临时目录中创建我们的临时目录
  - 重要的是要注意临时目录不会在 Node.js 脚本终止时自动删除。我们要么必须自己删除它，要么依靠操作系统定期清理它的全局临时目录

- web stream
  - 文本流：字符串
  - 二进制流：Uint8Arrays（一种 TypedArray）
- WebStream
  - ReadableStream
  - WritableStream
  - TransformStream：传输流或称管道，由读、写流组成，从输入流（读）传输数据到输出流（写）
- ReadableStream

  - Reading via Readers
  - Reading via asynchronous iteration
    ```js
    const iterator = readableStream[Symbol.asyncIterator]();
    let exhaustive = false;
    try {
      while (true) {
        let chunk;
        ({ done: exhaustive, value: chunk } = await iterator.next());
        if (exhaustive) break;
        console.log(chunk);
      }
    } finally {
      // If the loop was terminated before we could iterate exhaustively
      // (via an exception or `return`), we must call `iterator.return()`.
      // Check if that was the case.
      if (!exhaustive) {
        iterator.return();
      }
    }
    ```
  - Piping ReadableStreams to WritableStreams


- Monorepo
  - 架构
    - 依赖管理
    - 任务编排
      - 串行
      - 并行
      - 拓扑结构
    - 版本发布
  - 库
    - [lage](https://github.com/microsoft/lage)
- 构建系统

  - 缓存-增量



- 资源
  - 关键资源：初始
    - Critical CSS
      - [critters](https://github.com/GoogleChromeLabs/critters)
- 网络
- 代码

- link

  - preload
  - prefetch
  - 资源优先级

- webpack

  - hash
    - hash 每个构建生成的唯一哈希
    - chunkhash 基于每个块的内容
    - contenthash 最终生成的文件内容

- pro
  - 关闭 sourcemap
  - 分析大文件，找出内鬼
    - webpack-bunle-a
    - 拆包
    - 外置
    - cdn 加速
    - 压缩


- HTTP 缓存
  - 浏览器发出的所有 HTTP 请求首先会转至浏览器缓存，用于检查是否存在可满足请求的有效缓存响应。如果存在匹配，则从缓存中读取响应，从而消除网络延迟和传输产生的数据成本。
  - HTTP 缓存的行为由请求标头和响应标头的一起控制
  - 策略
    - 版本化 URL 的长期缓存
    - 非版本化 URL 的服务器重新验证
  - 通过设置 ETag 或 Last-Modified ，您可以让重新验证请求更加高效。它们最终会触发在请求标头中提到 If-Modified-Since 或 If-None-Match 请求标头。

Cache-Control: no-cache 适用于每次使用前应与服务器重新验证的资源。
Cache-Control: no-store 适用于永远不要缓存的资源。
Cache-Control: max-age=31536000 适用于版本化的资源。

- 预加载 preload：`<link rel="preload">`
  - 浏览器会根据情况执行诸如 preconnect 和 prefetch 等资源提示。而另一方面，preload 对浏览器来说是强制性的。现代浏览器已经非常擅长对资源进行优先级排序，这就是为什么谨慎使用 preload 并且只预加载最关键的资源那么重要
  - as
    - 提供 as 属性可帮助浏览器根据其类型来设置预获取资源的优先级，设置正确的标头，以及确定资源是否已存在于缓存中。此属性可接受的值包括： script 、style 、font 和 image 等等
    - 省略 as 属性或使用了无效值，就相当于 XHR 请求，这时浏览器不知道它获取的内容，因此无法确定正确的优先级。它还可能导致某些资源（例如脚本）被获取两次



- 代码调试
  - Syntax errors 语法错误
  - Logic errors 逻辑错误
  - Runtime errors 运行时错误








- 对象
  - 内部槽
    - 用于操作对象（获取属性、设置属性等）的方法槽
    - 存储值的数据槽。
  - 属性的集合
    - 属性 key - value
      - key
        - A string 一个字符串
        - A symbol 一个符号 
    - 分类
      - 数据属性
      - 访问器属性
        - getter
        - setter

- super
  - SuperCall
  - SuperProperty

- WebStream API
  - writable streams
  - readable streams
  - transform streams


- Socket
  - 编程模型
- TCP
  - 可靠性
    - 流量控制
    - 拥塞控制


- 软件设计目的
  - 软件设计就是对抗不断增加的需求变化，变化会导致软件不稳定
    - 分离变化：尽可能把变的部分和不变的部分分开，让不变的部分稳定下来
      - how：分离关注点
- 软件设计
  - 模型设计/定义
    - 软件设计即要抽象设计，一切皆抽象，抽象出稳定的系统模型层非常重要，应用的核心模型是相对稳定的，实现细节则是容易变动的部分
  - 模型之间如何交互？
    - 接口设计：帮助从具体的实现细节中抽离出来
      - 接口是把变和不变隔离开
      - 接口应该是尽可能稳定的
        - 接口的使用者对于接口是一种依赖关系，被依赖的一方越稳定越好，而只有规模越小，才越有可能稳定下来
      - 做接口设计时，需要关注不同的使用者
        - 每个使用者面对的接口，其实都是一种角色接口，识别出接口不同的角色是至关重要的
    - 原则：接口隔离
      - 同一个对象扮演不同角色的场景，每个接口代表着与不同使用者交互的角色
      - 分离关注点，使用接口识别出不同的角色是至关重要的
      -  ISP 理解成接口设计的 SRP。
- ISP 还可以从更广泛的角度去理解，也就是说，不要依赖于任何不需要的东西，这个原则可以指导我们在高层次上进行设计。



- 如果你发现了任何做运行时类型识别的代码，很有可能已经破坏了 LSP、OCP。
- 要满足 LSP，首先这个对象体系要有一个统一的接口，而不能各行其是，其次，子类要满足 IS-A 的关系
- IS-A 的判定是基于行为的
  


  - 控制反转：即反转控制流，是框架经常使用到的一种模式，由框架来调用应用，而不是应用来调动框架
  - DI 容器/IoC 容器
    - 负责组装代码，把业务模型和具体类联合在一起
    - 即便是没有 DI 容器的语言，组装代码与模型代码也应该是分开的
    - 依赖注入
      - 依赖注入的最主要目的，就是为了实现依赖倒置。一个是手段，一个是目的
      - 依赖注入真正实现了面向接口编程的愿景，可以很方便地替换同一接口的不同实现，而不会影响到依赖这个接口的客户端。而且使用了依赖注入后，每个组件只需要关注自己的逻辑，而不需要关心组件之间的组合逻辑，大大降低了系统复杂度
- 应对变化
  - how：构建模型
    - 分离关注点：从不同角度看待问题
    - 找到共性
  - 模型抽象设计
  - 如何应对变化对模块设计的影响






- 设计
  - 功能结构
  - 使用流程

- 文本格式
  - 以 NULL 结尾的字符串、回车符和换行符或其他控制字符，这些字符旨在读取和操作
- 二进制格式
  - 二进制文件格式是一种将数据编码为二进制格式的方法


- any
  - noImplicitAny
  - 污染问题
- unknown
- never：空类型
- Typescript 生态
  - tsc & AST
    - [ts-morph](https://github.com/dsherret/ts-morph)
  - tsd 验证器：[tsd](https://github.com/SamVerschueren/tsd)
  - 类型生成
    - [quicktype](https://github.com/quicktype/quicktype)
  - 运行时 ts 类型验证
    - [zod](https://github.com/colinhacks/zod)




MVC 是一种软件架构模式，通常用于开发用户界面，主要是在解决数据逻辑和视图逻辑的分离问题；**MVC 在不同编程领域有不同的通信模型变化**，而在 web 前端领域里通常是 MVP 和 MVVM 的 MVC 变种模型，并且前端的 MVC 对应整个 web 应用的 MVC 模型中的 V。

主要由三部分组成

- Model：应用的状态管理和业务逻辑
- View：视图渲染和视图逻辑管理
- Controller：控制器，接受、处理用户指令，调度数据模型和视图通信



  - 状态通信
    - 状态管理
      - 组件级
      - 页面路由级/业务级
      - 应用会话级
    - 组件树 + 层级栈：区域状态

- WebServer
- WAF
  - ModSecurity
- DNS
- CDN
  - 就近访问
  - 高速专有线路连接
  - 全局负载均衡和缓存系统
    - 智能 DNS
    - 缓存
- WebSocket
  - HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式
  - WebSocket 采用了二进制帧结构
  - URI 格式、“ws”和“wss”，分别表示明文和加密的 WebSocket 协议。
  - WebSocket 的默认端口也选择了 80 和 443，因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接
  - WebSocket 的握手
    - 利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制
    - WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：
      - “Connection: Upgrade”，表示要求协议“升级”；
      - “Upgrade: websocket”，表示要“升级”成 WebSocket 协议



- SSR
- Static Hosting
  - SSG
    - ssr + pre-renders
      - Crawl-based Pre-rendering
        - /、~/pages、nitro.prerender.routes
        - HTML 中的 `<a href="...">`
  - CSR


- Web 服务遇到的威胁
  - 第一种叫“DDoS”攻击（distributed denial-of-service attack），有时候也叫“洪水攻击”
  - 代码注入
    - “SQL 注入”（SQL injection）应该算是最著名的一种“代码注入”攻击了，它利用了服务器字符串拼接形成 SQL 语句的漏洞，构造出非正常的 SQL 语句，获取数据库内部的敏感信息。
    - HTTP 头注入
    - JS 代码注入
      - 跨站脚本”（XSS）
        - 利用 JavaScript 脚本获取未设防的 Cookie。
      - CSP内容安全策略，CSRF防御




- EOF（如C程序所示）不是一个字符
- EOF (end-of-file) 是内核提供的一种条件，可由应用程序检测到。当读取操作到达文件末尾时，应用程序可以检测到该条件


- ssr
  - 爬虫
  - 序列化







- rest
  - REST更像是一种范式，而不是API标准
  - REST API”用于基于HTTP的JSON API
  - 使用 REST，一切都以资源为中心，可以检索和操作资源



- Unicode
  - Unicode 为每个字符提供了一个唯一的编号，如 h 对应的码位(`U+<hex>` 格式) 为 U+0068
  - 字符编码将 Unicode 代码点转换为唯一的代码单元序列。
    - UTF-8、UTF-16 和 UTF-32

- Rest 参数与 Spread 语法
  - spread 语法这样操作任何可迭代对象
  - Array.from 适用于类数组对象也适用于可迭代对象。
Spread 语法只适用于可迭代对象


- 箭头函数
  - 箭头函数没有自身的 this，从外部词法环境中查找 this
    - 不能用作构造器
  - 箭头函数没有 "arguments"

- 部分（应用）函数（Partial functions）
  - let bound = func.bind(context, [arg1], [arg2], ...);

- NodeJS 错误
  - 操作错误
  - 编程错误
  - 捕获
    - 处理
    - 传播
  - Nodejs 捕获
    - Try-Catch 尝试捕获
    - 异步
      - Callbacks 回调
      - Promises 承诺
    - 全局
  - 创建自定义错误处理程序



- 构建DOM树；
样式计算；
布局定位；
图层分层；
图层绘制；
合成显示；
- 在CSS属性改变时，重渲染会分为“回流”、“重绘”和“直接合成”三种情况，分别对应从“布局定位”/“图层绘制”/“合成显示”开始，再走一遍上面的流程。


- 脚手架
- 样式隔离方案：CSS Modules
- ESLINT 代码检查
- commit 信息规范\commitlint
  - git hooks: husky
- 代码复用：组件模版与 code snippets
- 版本发布：发版与 CHANGELOG 自动化
  - 引入 standard-version 对自动打 tag 以及 CHANGELOG 生成进行规范




- PNPM
  - 幻影依赖
  - 安装速度快、节省磁盘
- Changesets[12]、Beachball[13]、Auto[
- Turborepo
  - 任务编排
  - 构建缓存


type 和 interface 区别；
any、unknown 和 never 区别
extends 用法
泛型；
高阶：如何理解类型系统是图灵完备的。

- JS 常见 API
  - 正则
    - String.prototype.replace(pattern, replacement)
      - replacement
        - replacer(match, p1, p2, /* …, */ pN, offset, string, groups)

- TSL
  - Cipher Suite
  - Random
  - 数字证书
    - 签名是如何制作
      - 数字证书中包含的信息将使用 SHA-256 算法进行哈希处理。生成哈希值后，证书颁发机构使用 RSA 非对称密钥加密技术使用其私钥对哈希值进行加密
    - 信任链


- 异步 = 语法 + 并发模型
- 并发模型
  - 单线程事件循环
- 浏览器中的 EventLoop
  - 需要主要的是在浏览器中，所谓的 macro-task 代表：setTimerout、setInterval、script脚本、UI渲染等。
  - 而所谓的 micor-task 代表则是：Promise、MutationObserver 等


- Cookie
  - 本质目的：在浏览器能够持久化少量数据
  - 特征
    - 能自动附加在 http 请求中
  - 主要用途：记录少量会话状态
  - 第三方 Cookie
    - 统一登录
    - 为 Web 提供了跨站点跟踪的能力
  - SameSite Cookie
    - Lax
      - 对于允许用户从外部链接到达本站并使用已有会话的网站站
      - Lax 属性只会在使用危险 HTTP 方法发送跨域 Cookie 的时候进行阻止，例如 POST 方式。
      - 同时，使用 JavaScript 脚本发起的请求也无法携带 Cookie。
  - 隐式沙盒
    - https://mp.weixin.qq.com/s/Oq_0wXXB9JPbcHEB6qw4ZQ
- HTTP 协议是无状态的协议
  - 众所周知，HTTP 协议是无状态的协议，如果你在同一个客户端向服务器发送多次请求，服务器不会知道这些请求来自同一客户端。
  - 这正是 HTTP 协议得以广泛应用的原因，试想一下，如果它是有状态协议，你必须要时刻与服务器建立链接，那么如果连接意外断开，整个会话就会丢失，重新连接之后一般需要从头开始；而如果是无状态协议，使得会话与连接本身独立起来，这样即使连接断开了，会话状态也不会受到严重伤害，保持会话也不需要保持连接本身


- 页面流式渲染
  - 技术层面更合理的做法是，每个组件描述它自身所需的数据依赖，页面渲染时遇到没有数据依赖的静态组件，立即发送给用户，遇到有数据依赖的组件则发起请求（Render-As-You-Fetch），不同组件可以独立发起不同请求，每个组件数据请求完毕后即刻开始自身渲染，最终得到页面流式渲染，用户渐进式地看到一块块成形的界面渲染的效果
  - Streaming SSR 


- 函数式语言的理论模型是lambda演算？
  - <表达式>::= <标识符>
  - <表达式>::= (λ<标识符>.<表达式>)
  - <表达式>::= (<表达式> <表达式>)
  - 特征
    - 数据不可变
    - 其他
      - Curry
      - Lazy evaluation (惰性求值)
        - 函数的参数如果是个计算表达式的话，这个将被看成一个thunk, 真正需要的时候才会计算
        - 无限数据流


- 错误的处理策略
  - 向上抛出
  - 捕获并处理
  - 反馈给用户
  - 重试
  - 记录错误日志
- Node.js 异常处理机制
  - 同步代码：try-catch
  - 异步代码
    - Callback
      - 通常会将第一个参数作为错误对象传递出来，然后根据是否存在错误来进行处理
    - Promise
      - catch
    - EventEmitter
      - on(error)
  - 集中
- 线上异常定位
  - 发现问题
    - 性能指标
      - 系统指标
      - 应用指标
        - QPS、请求响应时间、错误率
  - 快速响应
    - 服务回滚
    - 紧急修复
    - 限流、降速
  - 定位解决，一旦问题得到控制，我们需要深入分析服务、代码和数据以找到根本原因




- Tree-Shaking 依赖 ESM 的静态结构。
- Tree-Shaking 中的第二个关键点——副作用。如果一个
函数调用会产生副作用，那么就不能将其移除


- FIFO：先进先出算法
- LRU：最近最少使用算法，
- LFU：最不常使用算法


闭包是将函数，或者说代码和其环境一起存储的一种数据结构。闭包引用的上下文中的自由变量，会被捕获到闭包的结构中，成为闭包类型的一部分

- native 端
  - 在 native 端，Unity 是我们比较熟悉的老牌游戏引擎
  - cocos 2D-3D 主要用于小游戏
- web 端
  -  three.js
  -  pixi.js
  -  Oasis Engine
- 场景模型
  - web3D 的主流格式是 glTF（GL Transmission Format


- TypedArray
  - Int8
  - Float32
- ArrayBuffer


- 原码
- 反码
- 补码
  - 计算机在存储数字值时会采用“补码”的形式
  - 反码 + 1
  - 无符号数的反码和补码，与其原码保持一致？
- ACL（Access Control List） 访问控制列表
- 在计算机中，有符号数之间的减法操作（比如 “10 - 3”）是如何进行运算的吗？




- 0x
- 0o
- 0b
- b'A' 此字符的ASCII码值
- String 内部存储的是 Unicode 字符串的 UTF8 编码，而 char 直接存的是 Unicode Scalar Value
- 字符串字面量中的转义
  - Rust 还支持通过 \x 输入等值的 ASCII 字符，以及通过 \u{} 输入等值的 Unicode 字符
  - 禁止转义的字符串字面量
    - 使用 r"" 或 r#""# 把字符串字面量套起来就行了
- 是否能在编译期计算出某个数据类型在运行过程中占用内存空间的大小
- 如果一个资源没有被任何一个栈帧中的变量引用或间接引用，如图中的 C，那么它实际是一个被泄漏的资源，也就是发生了内存泄漏。被泄漏的资源会一直伴随程序的运行，直到程序自身的进程被停止时，才会一起被 OS 回收掉。
- 这种堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性，叫作 RAII（Resource Acquisition Is Initialization）。它实际不是 Rust 的原创，而是 C++ 创造的。



- TCP
  - 可靠性
    - 发送 -> 确认；超时 -> 重发
- 网络问题
  - 丢包
  - 乱序
  - 延迟
- 协议设计
  - 序号：用于标识传输包的序号，这样就可以知道这个包是第几个分片了。
  - 起始标记：记录分帧的第一个 UDP 包。
  - 结束标记：记录分帧的最后一个 UDP 包




- s
  - https
  - Helmet
  - 身份验证
    - 会话
    - 令牌


- pnpm
  - 幻影依赖
  - 安装效率
  - 节省磁盘



- Typescript
  - ts 类型增强
  - ts 模块类型解析
- rust 所有权及生命周期
- socket.io
  - https://github.com/socketio/socket.io-client

## end

## Quetions

- http 客户端设计
  - https://mp.weixin.qq.com/s/By-iXlONjSZLKFG2Xd7rpg 重复
  - https://mp.weixin.qq.com/s/NfyxtWUzjHh6ucXvBF9B4Q 缓存
  - https://mp.weixin.qq.com/s/E4SdYEkEzurfrnJrBu3bjA 并发下载
  - https://mp.weixin.qq.com/s/8RJSBwCDTvwX3Oql31ckkg 重试
  - https://mp.weixin.qq.com/s/lGqnGg-Zdnt-b7grdh9NnQ 压缩
- 发布 - 消费 - 生产
- AI
  - 机器学习
    - 深度学习
- 路由器
  - WAN 千兆入口
  - LAN 出口
  - 双频
    - 双频合一
  - wifi 传输标准
    - ac 5
    - ax 6
  - 速率（天线）
  - 信号
    - 发射频率
    - 天线增益
  - 性能
    - cpu
      - 博通1-联发科2-海思
    - 内存
    - 固件
      - 华硕
- Web 框架
  - 路由
  - 中间件
- Cloudflare
  - Cloudflare Zero Trust
- 操作系统
  - 可执行文件
    - 二进制执行文件
    - shell 脚本文件
  - 文件格式
    - 文本格式
      - 以 NULL 结尾的字符串、回车符和换行符或其他控制字符，这些字符旨在读取和操作
    - 二进制格式
      - 二进制文件格式是一种将数据编码为二进制格式的方法
- CSS
  - 内容溢出
    - `overflow 的值为 scroll 或 hidden`
    - 长字符设置 word-break
    - img 上设置 max-width: 100%
- Admin 系统模块
  - 列表
  - 表单
  - 权限设计
  - 登陆验证
  - 工作流
- Monorepo
  - 依赖管理
  - 任务编排
    - 缓存
    - 监听
  - 版本发布
    - 支持 monorepo
      - 同步
      - diff
- Vue
  - 实例
    - vnode
    - component
    - ctx
- 单词
  - 知道怎么说/读
    - 口语、听力
    - 阅读
    - 写作
- Typescript
  - 怎么动态推导回调函数的返回值类型
  - 断言
    - ！
    - as
- 思维图
  - https://developer.mozilla.org/en-US/docs/Web/CSS/mask
  - https://css-tricks.com/clipping-masking-css/
  - https://codepen.io/inventicon/pen/xpvWOq
  - https://codepen.io/nicktayloruk/pen/BaoKxaW
- 权限设计
  - 架构思想
    - 最小权限原则
      - 权限设计尽量细
      - 每个用户权限尽量少
    - 权限职责划分
    - 分级分层保护：外层调用内层，需要多层检验保护
    - 尽可能少的 root
      - 如果一个用户需要root能力，那么应当进行权限包围——马上提升权限（比如 sudo），处理后马上释放权限
- 前端组件
  - canvas table
    - [glide-data-grid](https://grid.glideapps.com/)
  - canvas text
    - [Canvas-Txt](https://github.com/geongeorge/Canvas-Txt/)
    - [canvas-hypertxt](https://github.com/quicktype/canvas-hypertxt)
- 数据库
  - Mongodb
    - 面向文档的数据库：是一种非关系型数据库（NoSQL），它存储和管理的数据以文档的形式存在
    - 概念
      - 集合
        - 文档
          - 文档：是一个 BJSON 对象
          - BJSON：二进制格式的 JSON 样式的文档
    - MQL
  - PostgreSQL
    - 表
      - 行
- 请求
  - swr
  - 防抖
  - 取消
- 优化三大宝
  - 拆分/分层
  - 缓存
  - 加机子（计算角度）
    - 算法
    - 并发
    - native code
- NodeJS
  - 部署
    - [The complexity of writing an efficient NodeJS Docker image](https://www.specfy.io/blog/1-efficient-dockerfile-nodejs-in-7-steps)
- SSH
  - TSL 握手
  - tty
- React
  - StrictMode？
- Rust
  - 静态变量与常量区别？
    - const 系统会在编译时对常量变量进行求值；无论在何处使用，其值都会被内嵌
    - staic 使用时不会内联，并且具有实际关联的内存位置
  - 注释、Rustdoc
    - 文档注释
  - continue 和 break 都可以选择接受一个标签参数，用来 终止嵌套循环
  - 内存安全
    - 资料
      - [Type Systems for Memory Safety](https://borretti.me/article/type-systems-memory-safety)
    - 内存安全问题
    - 基于区域的内存管理
- JS
  - rxjs
  - vite-node
- Blog
  - `nitroApp.hooks.hook("content:file:beforeParse", (file: ContentFile)` 类型问题
  - Toc、JSX 组件更新问题
  - vueuse pr、类似 rxjs 响应式 api 设计
    - 思考
      - computed 单个计算
        - (cb) => ref
      - pipe 压缩计算
        - (ref, cb) => ref
    - api
      - event-emitter
      - untilValue
  - provide/inject ts 体操
  - https://metascraper.js.org/#/
  - 命令式组件 Side
    - 创建命令式组件
      - create
      - destroy
      - Comp
    - 动态组件内容配置
      - slot
      - component
      - teleport
- 个人 
  - freedom2
    - share-screen
  - parcel-vue
    - https://github.com/vitejs/vite/tree/main/packages/create-vite

## My

- 低代码-表单
  - `表单设计器 => 表单 UI 描述模型 => 表单渲染器 => [UI 模型(VNode) => Vue Render =>] UI`
    - 表单 UI 描述模型
      - 表单组件描述
      - 交互逻辑描述
        - 数据校验
          - 必填
          - 大小
          - 格式
          - 联动数据校验
        - 错误提示
  - `表单 UI 描述模型 => 表单数据描述模型`
    - 表单数据描述模型
  - `表单数据描述模型 => 数据模型校验器 check 数据`
  - `表单数据描述模型 => 表格 UI 模型描述 => 表格渲染器 => [UI 模型(VNode) => Vue Render =>] UI`
  - 其他
    - [JSON Schema](https://json-schema.org/)
    - JSON Schema 验证器：[ajv](https://github.com/ajv-validator/ajv)

## 语录

- 人生意义就是帮助其他人、乃至人类这个物种的生存和发展。因此，实现人生意义的最好方法，就是做对社会有益的事情，让社会和人类延续。最低限度上，只要正常的劳动和工作，你的人生就有意义了。
- 人类学习效率最高的方式，不是“读书 + 思考”，而是“观察 + 模仿”
- wwh
  - what：学什么东西，首先要摸清楚其提供的概念模型
  - why：为什么/有什么用
  - how：怎么做/如何学习
    - 做经典题
- 一共有四点，一点认知、一点执行和两点方法论：认知就是收集信息的能力，执行即自驱力，来源于你的野心；方法论有两个，一个是拆解问题的能力，以及第二个，变通思维的能力

## Goal

- 看机会
- 找工作
- 技术学习
  - Rust、JS、算法、面试
- 接外包
- 其他
  - 股票学习
  - 英语

## IT 技术学习

- 开发
  - 字符串、文本操作
  - 二进制操作、编解码
  - 网络 IO 编程
  - 协议、编译原理
  - 操作系统应用编程
  - 数据结构与算法
- 计算机技术及应用
  - 领域
    - Web
      - HTTP
        - [ ]《透视 HTTP 协议》
      - 浏览器
        - [ ] 《浏览器原理及实践》
      - 前端框架及工程化
        - Vue
          - [ ] 深入 Vue 框架源码及生态
          - [ ] 技术输出：vue 深入系文
        - 低代码框架
          - [amis](https://github.com/baidu/amis)
        - [前端工程化](./content/前端工程化/README.md)
      - 后端
        - [NodeJS](./NodeJS)
      - 音视频
        - [ ] 《从 0 打造音视频直播系统》
      - 可视化、3D、XR
      - 跨端
      - 游戏
  - 软件设计及架构、软件工程及软件工具
    - 软件设计及架构
      - [ ]《软件设计之美》
    - 软件工程及软件工具
      - DevOps
      - 容器技术
        - [ ] 《Kubernetes 入门实战课》
      - Git
      - [SSH](./软件设计及架构、软件工程、软件工具/SSH.md)
        - [ ] [ssh-tutorial](https://github.com/wangdoc/ssh-tutorial)
  - 程序设计语言与实现原理、编译原理
    - [JavaScript](./JavaScript/README.md)
      - [ ] 《JavaScript 核心原理精讲》
      - [ ] 《ES6 入门教程》
      - Typescript
    - Rust
      - [ ] [《Rust 程序设计语言》](https://kaisery.github.io/trpl-zh-cn/title-page.html)
      - [ ] 如何用 napi-rs 搭建一个 Node.js 可以调用的 Rust 库
    - 语言实现原理、编译原理
      - [ ] https://craftinginterpreters.com/contents.html
      - [ ] 《手把手带你写一门编程语言》
      - SICP
        - [MIT 计算机程序的构造和解释](https://github.com/DeathKing/Learning-SICP)
        - [Berkeley 的 61A 课程](https://www.bilibili.com/video/av40460492/?vd_source=5e3f59e2a50994ae58323e0f75a50d48)
      - [《程序语言理论与实现》](https://bobzhang.github.io/courses/)
      - 《编译原理》龙书
      - https://www.edx.org/course/compilers
  - 计算机基础
    - 数据库
      - [ ] SQL 必知必会
    - 计算机网络
      - [ ] 《计算机网络通关 29 讲》
      - [ ] 《趣谈网络协议》
      - [ ]《网络是怎样连接的》
      - [ ] 《抓包》
      - [The TCP/IP Guide](http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm)
        - RFC：https://datatracker.ietf.org/doc/rfc1644/
      - 《计算机网络-自顶向下方法》
    - 操作系统
      - [ ] 《重学操作系统》
      - 《趣谈 Linux 操作系统》
      - 《现代操作系统：原理与实现》
      - https://wiki.osdev.org/Main_Page
    - [数据结构与算法](./数据结构与算法/README.md)
      - [ ] leetcode 200 道
      - [ ] 《数据结构与算法之美》
      - [ ] 《算法面试通关 40 讲》
      - [ ] [Hello 算法](https://www.hello-algo.com/)
    - 计算机组成原理/计算机系统
      - [ ]《程序是怎样跑起来的》
      - 《计算机是怎样跑起来的》
      - https://www.bilibili.com/video/BV1iW411d7hd
  - 数学与应用
- 悟
  - 人类学习效率最高的方式，不是“读书 + 思考”，而是“观察 + 模仿”
  - WWH
    - what：是什么
      - 学什么东西，首先要摸清楚其提供的概念模型
    - why：为什么/有什么用
    - how：怎么做/如何学习
      - 做经典题
  - 一共有四点，一点认知、一点执行和两点方法论：认知就是收集信息的能力，执行即自驱力，来源于你的野心；方法论有两个，一个是拆解问题的能力，以及第二个，变通思维的能力