---
discussionID: Oj_XjbyTJSguC6tnf3dnh
---
## 计算机

 - 计算
   - 并发
     - 物理
       - 单核分时
       - 多核并行
     - 模式
       - 多线程
       - 协程
     - 缺点
       - 资源竞争
         - 所谓状态是对象某时间的快照，我们引入状态却把时间参数隐藏起来，于是我们不得不引入锁来保持一致性。强一致性（控制），最终一致性（回避），事件溯源（引入），这一步步正是重新正视我们过去抽象偷懒引来的问题。计算或逻辑本来就没有状态概念，减少多余概念的消耗，可以发挥计算最大效能
       - 逻辑同步
 - 内存
 - IO

## 操作系统

- 进程
  - 进程状态：阻塞、非阻塞
  - 阻塞
    - 主动阻塞
    - IO 调用
      - IO 调用模型
- 跨语言通信方式
  - 进程之内
    - SM，SharedMemory
    - FFI，Foreign Function Interface
  - 跨越进程
    - RPC，Remote Procedure Call
      - 序列化、反序列化
      - grpc
    - CLI
- 文件
  - 可执行文件
    - shell
    - 图形
  - 数据文件
  - file magic
    - 有些file magic是可以从头至尾一行行扫描的，在哪找到了，把那里当开头就行。

## 编译原理

- code => 编译 => 运行

## 设计

- 分层
  - 静态代码逻辑分离
- 模块化

## vscode

- vscode remote
  - [Remote - SSH](https://code.visualstudio.com/docs/remote/ssh#_debugging-on-the-ssh-host)
  - [Remote - Containers](https://code.visualstudio.com/docs/remote/containers)
    - [附加到正在运行的容器](https://code.visualstudio.com/docs/remote/attach-container)
    - [创建开发容器](https://code.visualstudio.com/docs/remote/create-dev-container)
    - [高级容器配置场景](https://code.visualstudio.com/remote/advancedcontainers/overview)
  - GitHub Codespaces
  - The VS Code Server 
  - Remote Repositories

## 框架

- 主流框架原理（React、Vue）
  - 底层原理
    - 渲染：视图是状态的一种映射 `UI = f(state)`
      - VDom 渲染机制
        - render => vdom
        - diff vdom
        - patch
    - 响应
      - 数据驱动：state => UI
        - vue 依赖追踪
      - 事件驱动
  - 上层范式：组件
    - 组件：将状态与「和他相关的 UI 映射关系」约束在一起
      - 组件是为了解决框架实现原理中「UI到状态的映射」的途径
    - 语法
      - 对象形式
      - 函数式
- 逻辑分离、复用
  - 组件 => 松散耦合单元
  - Model 与 UI 分离 => model、viewmodel
    - 状态逻辑
    - UI
      - 模板
      - 原子样式
- 业务架构
  - 业务
    - 业务模型
    - 模型交互流程
  - model => view
- 状态管理
  - 如何与框架实现原理尽可能契合？
  - Model 组织结构管理问题
  - 细分领域管理
    - 表单状态
    - 流程状态
    - 请求缓存
- React vs Vue
  - why hook（范式与原理哪个更为接近）
    - react 原生的响应式方案是非常依赖数据不可变性的，hook、函数式编程理念与 react 更为接近
    - vue：更好的逻辑分离与组合复用、类型推导
  - vue、react 区别
    - 渲染机制差不多，响应式机制一个可变
- diff
  - 同层对比
  - type 变了就不再对比子节点
  - 移动：复用元素、尽量减少创建新元素
    - 判断 type 么？ 那不行，同 type 的节点可能很多，区分不出来的
    - 每个节点都是有唯一的标识 key，利用 key 复用
    - vue2 双端对比、vue3 最小递增子序列
- 状态管理
  - 思考
    - 人机交互的业务逻辑本身，是【针对人的行为做出反馈】
    - 异步 IO => 数据变化 => 视图渲染
      - command pattern+event driven、state$＝reduce(userIntent$, initialState)
      - 数据驱动视图，事件驱动业务逻辑
      - 状态提升或者抽离到外部单例 store
      - 在组件里写逻辑，通信问题，观察数据
      - 前端圈有些思路，违背了很多根本性的架构理念，最典型的就是依赖方向，数据流方向，读写分离的问题。只是由于绝大多数项目复杂度低，破坏性产品功能迭代少，所以对架构要求不高而已
      - 视图层依赖数据层


  - 利用原生的文件系统（ES Module）来实现对响应式全局状态的管理。
  - 分层
    - 不同场景 UI 变化、对接的数据模型不同
    - headless 组件即无 ui 组件，表示仅提供 UI 元素和交互的数据状态逻辑、状态、流转处理和API，但不提供标记、样式或预构建实现（或另外实现)
    - 有效分离了 ui 定义和业务定义、层次分明
    - 容器/展示
    - 依赖方向应该是由不稳定指向稳定，而UI是最不稳定的，如果任何逻辑一定要先让组件渲染出来，那一定是错的，没有什么值得讨论的。
    - 对象
      - 函数一等公民，也和面向对象不矛盾。在没有class的年代，js的函数一等公民加上词法作用域，带来的闭包特性，也是一种经典的面向对象的手段，所谓“闭包是穷人的对象”嘛。访问限定、封装、隔离，都可以用闭包搞定。而多态这种特性。。。JS这种鸭子类型的动态语言难道不是天然支持多态吗？多态搞起来比TS方便多了。
      - 单线程模型风格  
        - 最基础的是声明式编程，或者说函数式编程。这个风格最大的特点就“数据不可变”，变量和属性都只能赋值一次，不能重新赋值。如果一个class内部属性不可变、方法都是纯函数，那么它虽然看起来像是对象，但其实属于FP。
        - 在声明式编程的基础上，加上可变状态，也就是允许变量和属性重新赋值，就变成了“基于对象的编程”，Object-based Programing。所谓“对象”，就是可变的数据的组合。
        - 在此基础上，再加上对象之间的继承关系，就从OBP变成了OOP，“面向对象的编程”。
    - proxy响应式+OOP模型，还是选择react响应式+FP模型
    - ui、model、db
- SSR
  - dev
- css
  - Tailwind 通过使用 PurgeCSS 来扫描你的大包产物并删除你不需要的规则。这得以使其在生产环境中 CSS 文件缩减为几 KB
    - 属性化模式  
    - 自动值推导
    - 按需生成
  - Icon
    - image
    - font
      - css 类 伪元素
    - svg
      - svg
      - css 类 bg
        - dataUri
  - Theme
    - 方案
      - CSS 原生变量
      - CSS 预构建 + CSS 样式覆盖
    - 现有工程改造
      - postcss/stylelint
      - 查找 & 替换】所有颜色变量
      - 通过 Stylelint 编辑器插件提示,保存时自动替换
    - 行为
      - class、dataset 切换策略
      - 系统监听： `window.matchMedia("(prefers-color-scheme: dark)").matches`
- SSR
  - 原理
    - renderToString => html
    - 注水、客户端激活
  - 优点
    - 更快的首屏加载
    - 更好的 SEO
  - 缺点
    - 开发中的限制
      - 平台特有 API
      - 响应性
      - 组件生命周期钩子
    - 更高的服务端负载
- 同构渲染
  - 同构、通用应用：应用的大部分代码同时运行在服务端和客户端
  - 结构
    - app
    - server.js
    - client.js
- Github
  - 开发
    - Token
    - Github APP
    - OAuth APP：OAuth App 使用 GitHub 作为身份提供程序以验证为授予应用程序访问权限的用户
  - API
    - Github API
    - WebHook


vue和react都抛弃了基于class组织组件的模式，是为了解决逻辑复用带来的命名冲突问题以及依赖注入问题。


- Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
- React 在组件方面的心智模型是「副作用受上下文托管的纯函数」
- Props 无论是跟着 View 销毁还是函数参数总是暂时性的输入，States 无论跟着组件实例还是置外总必须是持久化的，至于怎么判断更新
- 变更集
  - 依赖追踪
  - 引用不等性






- react 为什么函数式开发范式
  - 函数式的数据不可变契合 react 原理
  - 并发
  - this.state 问题
  - React 并发模式下很容易出现数据竞态（data race）的问题。
    - this.state 是一个对象，每次更新局部，更新时也可新加 state 进去，这就让 state 整体比较混沌。
    - 使用高阶组件等模式时，会造成 this.props 中的数据来源不透明，同样混沌。
    - 因为 this 魔法指针的存在，很容易挂一大堆东西上去，互相随意调用，就会让逻辑缠绕。
  - 复用状态逻辑
    - 提供逻辑共享，以替代高阶组件。
  - 逻辑关注点
  - algebraic effects

- 框架体系不同
  - Vue
    - 组件语义：基于响应式的对象
    - Vue 在组件方面的心智模型仍然是「拥有数据与行为且自响应式的对象」
    - 接近大家习惯的 JS
  - React
    - 函数
    - 副作用受控的「执行上下文（evaluation context）」
    - React 在组件方面的心智模型是「副作用受上下文托管的纯函数」


- state 去重
  - 处理多个组件状态同时更新这种case
- props 浅对比
- diff children 动静分离
在 React 中，随时间变化的数据称为状态，状态的行为更像是快照


- React
  - 并发渲染
    - 这使 React 能够在渲染阶段暂停工作以允许浏览器处理事件。React 将在以后适当地恢复、丢弃或重新计算该工作。一旦渲染过程完成，React 仍然会一步同步运行提交阶段。
  - vDom: render => diff => patch
    - reconcile
      - render => vdom
      - diff
    - commit: patch
  - React 是如何知道输出何时以及如何实际改变的呢？
    - state
      - setState
        - 异步更新、批处理
          - React 17 及更早版本，React 事件处理程序中进行批处理
          - React 18 现在对任何单个事件循环 tick 中排队的所有更新进行“自动批处理”
        - 同步？
    - diff 算法
  - 功能组件：
    useState二传手
    useReducer派遣
    类组件：
    this.setState()
    this.forceUpdate()
    其他：
    再次调用 ReactDOM 顶层render(<App>)方法（相当于调用forceUpdate()根组件）
    从新useSyncExternalStore钩子触发的更新
  - 标准渲染行为
    - React 从树的顶部开始渲染，如果组件没有被标记为需要更新则跳过
    - React 的默认行为是，当父组件渲染时，React 会递归地渲染其中的所有子组件！
      - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件，因为父组件渲染！
  - 渲染并不是一件坏事——它是 React 知道它是否需要对 DOM 进行实际更改的方式！
  - React Render 规则
    - 纯函数
  - 并发渲染
    - [Fiber](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193)
      - React 存储了一个内部数据结构，用于跟踪应用程序中存在的所有当前组件实例
      - React 将组件的所有 hooks 存储为附加到该组件的 fiber object 的链表



## 容器

### 容器突然被杀死
   
1. 容器内的主进程已成功结束
2. 交互程序的标准流没用附加管道或者终端
3. 收到关闭信号，如 `Ctrl+C`
4. 守护进程重启
5. docker stop
6. 系统杀死

7. 查看日志
8. 检查容器的状态，如退出状态码
9. 从相同的失败映像创建和启动容器，并使用 shell 覆盖入口sh点

## 程序设计语言

- 具有图灵完备性的计算机语言，就被称为图灵完备语言
  - “图灵完备”指的是语言指定的数据操作规则能够实现图灵机的全部功能
  - 图灵机是所有程序设计语言最底层的模型
  - 今天接触到的程序设计语言都是图灵完备的
- 程序设计语言发展简史
  - 机器语言
  - 汇编语言：对机器指令语义化封装
    - 缺点：不同厂商具有各自的 CPU 指令集
  - 高级程序设计语言：程序设计语言的发展就是一个“逐步远离计算机硬件，向着待解决的问题靠近”的过程
    - 屏蔽底层计算机硬件细节：如 C 语言
    - 类型系统：对内存抽象
      - 泛型编程
      - 动态类型
    - 内存管理
      - 自动垃圾回收机制
    - 如何组织程序
      - 结构化
      - 面向对象
    - 多核：高并发
      - 并发模型、异步模型
      - 内存安全
    - 语言表达力
      - 程序设计语言的一个重要发展趋势：声明式编程
      - DSL（Domain Specific Language，简称 DSL），它是一种用于某个特定领域的程序设计语言
        - DSL 不必做到图灵完备，它只要做到满足特定领域的业务需求，就足以缩短问题和解决方案之间的距离，降低理解的门槛
        - DSL 分类：区别 DSL 采用的是不是宿主语言
          - 外部 DSL 
          - 内部 DSL：本质就是一个程序库，**将意图与实现分离开来**
    - 函数式编程的程序设计语言
      - 关注如何解决问题，如何一层层构建抽象
      - 并发安全
- 首先是学习语法、编程模型
  - 命令式编程是面向计算机硬件的抽象：命令式程序就是一个冯诺依曼机的指令序列
      - 变量（对应着存储单元）
      - 赋值语句（获取存储指令）
      - 表达式（内存引用和算术运算）
      - 控制语句（跳转指令）
        - 顺序
        - 选择
        - 循环
      - 函数（过程）
    - 类型系统
    - 面向泛型
    - 面向对象：隔离（封装）、接口（多态）
    - 函数式：组合
  - 然后学习程序库
  - 最后学习运行时
- 类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。
不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。
- 类型系统
  - 静态、动态
    - 动态
      - 类型检查
  - 强弱类型
    - 弱类型
      - 类型转化
        - 访问到了不同的地址和内存空间，这就导致程序出现严重的问题
    - 强类型
      - 类型抽象 =〉泛型
- 如何实现跨语言调用？
- 内存回收
  - 手动管理
  - 追踪式 GC
    - STW
  - 自动引用计数
  - 所有权模型

## JavaScript

- Reflect主要是和Proxy配对使用，提供对象语义的默认行为
- get/set带有额外的receiver参数，现阶段，receiver其实只对访问器进行上下文修改。因为对于除了访问器（立即求值导致的）以外的属性，没有其他情况会出现这种上下文丢失的情况了，因为即使是一般函数调用，过程也是分步的，先获取函数对象（[[Get]]），再执行函数（[[Call]]）。而不会在[[Get]]的时候直接执行就意味着不会出现上下文丢失。receiver参数完全是为了解决访问器上下文问题而添加的。

- 二进制
  - ArrayBuffer
    - ArrayBuffer 对象表示通用的、固定长度的二进制数据缓冲区
    - 必须使用其封装类 ArrayBufferView 进行实例化后才能进行访问
    - ArrayBuffer 只是描述有这样一块空间可以用来存放二进制数据，但在计算机的内存中并没有真正地为其分配空间。只有当具体类型化后，它才真正地存在于内存中
  - ArrayBufferView
    - ArrayBufferView 并不是一个具体的类型，而是代表不同类型的 Array 的描述。这些类型包括：Int8Array、Uint8Array、DataView 等
  - Blob
    - Blob（Binary Large Object）是 JavaScript 的大型二进制对象类型


- 元编程
  - “With” 和 “eval” — ECMAScript中的动态作用域
    ，使用with和eval虽然加强了静态作用域，但相比之下，with和eval在实现上也可能会削弱变量查找和词法环境储存的性能（译注：因为这相当于扩充了当前作用域，增加了存储消耗和查找范围）。因此在ES5中，with在严格模式下被移除了，此外严格模式下的eval方法不再会在当前上下文创建变量。所以，ES5的严格模式下是完全遵守词法环境的实现。

## TypeScript

- 提取构造器参数签名
  - `ConstructorParameters<typeof Server>`
- 获取函数参数签名
  - `Parameters<typeof fn>;`
- 获取对象某一属性签名
  - `type Age = Person["age"];`

## NodeJS

- Node.js 优化
  - 计算
    - 增加线程池
- BFF
  - SFF = Serverless + BFF
- 模块
  - 使用模块代替全局变量
  - 模块风格
    - callback
    - sync
    - promise
- 如果你要学习一门新的技术，比如 Node.js，你该怎么学？
- 日志
  - 记录、格式化和存储
  - 类型
    - error
    - warn
    - info
    - verbose
    - debug
- web 服务
  - Fastify
  - trpc
  - zod

## 源码阅读技巧

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。你对细节部分的了解会随着你对项目的深入而逐渐增加。而有了主线后，你就有了着力点，就可以不断深入了。

尽量忽略其他不相干 case 情况，保持主逻辑功能流程分析
**这里有个小技巧：看源码过程一般建议关注主线逻辑，像各种特殊情况可通过注释、issue 或者测试用例查看原由**。


1. 理解功能需求
2. 实现猜想
3. 功能源码主流程 debugger
4. 源码细节
   1. 看 issue
   2. 看测试用例


## 并发编程体系

- 语言分类
  - 编译型 vs 解释型
  - 强类型 vs 弱类型：对变量类型检查的程度，隐式转换
  - 静态类型 vs 动态类型：类型检查发生的时机、变量可动态类型赋值
- 编程：CPU 计算 + IO 调用
- IO
  - 内存
  - 网络
  - I/O设备
    - 磁盘
- [IO 调用模型](https://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html)
  - 同步阻塞
  - 同步非阻塞（主动轮询）
    - 事件驱动
      - 单信号驱动
      - IO 多路复用
  - 异步IO
- 线程切换
  - 切换时机
    - 系统调用（system call）
      - 软中断
    - 中断（interrupt）
      - 中断信号
      - 时钟中断
  - 上下文切换(Context switching)
- 调度模式
  - 抢占式调度
  - 协作式调度
- 并发模型
  - 设计要素
    - 粒度
      - 指令
      - 函数
      - 程序
    - 调度
    - 通信
      - 共享内存
      - 消息传递
        - Actor
        - CSP
    - 同步
    - 编程范式
  - 编程模型
    - 线程模型
      - 多线程 + 同步原语 + 阻塞IO
    - 事件模型
      - 事件驱动 + 
        - 协程
          - 类似线程模型，线程：系统调度，协程：用户态调度
        - 事件循环
      - 事件驱动
        - 在合作型多任务处理中，总有一个处理内核负责所有I/O处理。其在设计模式中称为反应器模式
      - 模型
        - 单线程事件循环 + 异步回调队列
        - 协程模型
          - 特点
            - 协程就是用户态线程。协程的调度完全由开发者进行控制，因此实现协程的关键也就是实现一个用户态线程的调度器。由于协程是在用户态中实现调度，避免了内核态的上下文切换造成的性能损失，从而突破了线程在 IO 上的性能瓶颈。
            - 框架或者编程语言将阻塞操作转为无阻塞，同时将其控制权交到其他的执行线程中
          - 按调用栈分类（由于协程必须支持 挂起/恢复，因此对于挂起点的状态保存就显得极其关键。）
            - 有栈协程（Stackful Coroutine）：每个协程都有自己的调用栈，类似于线程的调用栈
            - 无栈协程（Stackless Coroutine）：协程没有自己的调用栈，挂起点的状态通过状态机或闭包等语法来实现。
          - 按调度方式分类
            - 对称协程（Symmetric Coroutine）：任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。对称协程有自己独立的调度器，除了挂起是由自己主动让出，它更像一个操作系统的原生线程，协程的调度运行完全取决于自己的调度器，在一个协程挂起后可以调度任何一个协程。
            - 非对称协程（Asymmetric Coroutine）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。
              - 通过语法 `yield`、`await` 显示协作
          - 范式
            - CSP
            - Actor

## rust


## 软件设计、语言设计

- 语言设计
  - 要素
    - 表达
    - 组合
    - 抽象
- 关注点分离
  - 变与不变分离
- 命令式语言设计
  - 语法结构
    - 变量、值和类型
    - 表达式与运算符
    - 控制流
      - 顺序
      - 循环
      - 分支
- 代码复用
  - 代码拷贝
  - 函数指针应用
    - 指针委托
    - 指针拷贝
- 编程技巧
  - Class 类
    - 类也是一种模块
    - 在一些情况下存在特定场景，需要抽象出与具体实现、实例化无关的通用逻辑，或者纯调用关系的逻辑，但是使用传统的抽象类会陷入到单继承的窘境。以往常见的做法是，实现由静态方法组成的工具类（Utils），比如 java.util.Collections。
    - 代码复用
      - 抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用、覆盖（多态）
      - 我们可以把通用功能放到抽象类；而一些特定的行为或属性，我们可以通过继承放到实现类中
- 函数式编程
  - Lambda 演算和图灵机是等价的？
  - 函数的运算方法
    - 伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的"函数式编程"。
    - 本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。
    - 函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。
    - 学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题
  - 意义
    - 函数式编程对程序中的赋值进行了限制和规范
      - 限制使用赋值语句，它是对程序中的**赋值**施加了约束
    - 封装复用
  - **面向对象编程是对系统结构的组合，函数式编程是对计算接口的组合**
  - 面向对象和函数式编程都提到了组合性，不同的是，面向对象关键在于结构的组合，而函数式编程在于函数接口的组合
  - 用面向对象编程的方式对系统的结构进行搭建，然后，用函数式编程的理念对函数接口进行设计/或者说计算设计
    - 分离可变状态
    - 副作用隔离
      - Monad
    - 可组合性 => 接口 => 抽象 => 分离关注点
      - 函数的合成还必须满足结合律
  - Monad
    - unit
    - map
      - 作满足结合律
    - join
    - 链式调用
    - 惰性求值特性使求值顺序很难确定，而 IO 操作需要确定的顺序
- 类型
  - 类型层次
    - 向上转型？
  - 结构化类型
    - 接口标记
- 接口和抽象类
  - 抽象类可扩展功能
  - 接口是对行为的抽象
  - 接口的多继承
  - 接口标记
- 架构设计
  - 面向服务架构（service-oriented architecture，简称 SOA）
    - 每个服务都是一个独立的功能单元，承担不同的功能，服务之间通过通信协议连在一起
    - **微服务**就是采用容器技术的面向服务架构
      - 一个微服务就是一个独立的进程

## JavaScript

- 迭代器、生成器
- UI 客户端是以**事件驱动**编程为主
  - **函数式 + 响应式**
- 函数式
  - 状态管理
    - 闭包对象
      - 闭包最大的特点是可以突破生命周期和作用域的限制，也就是时间和空间的控制
    - 对象
  - 不可变
    - 对象拷贝
      - immutable.js
- JS 对象
  - 基于原型链的继承
  - 属性遍历 for in
  - Object.is
- JSDoc + Typescript 实战


- 函数操作复习
  - 部分应用可以减少每次函数调用时需要传入的参数，而柯里化更是把函数调用时需要传入的参数数量，降到了 1。它们实际上都起到了控制参数数量的作用
  - 通过柯里化每次传一个参数
  - 反柯里化（uncurry），那么你知道反柯里化的用途和实现吗？
  - 等
- Pointe-Free Style
  - var isOdd = (x) => equalsToOne(remainderOfTwo(x));
  - point free的理解：把参数去掉，是指参数的含义已经体现在函数声明（名字）里面了，比如equalsToOne，那就是说传入的值是否等于1，如果是equalsToA，那么这个A就得传为参数，加上要比较的x就是两个参数了。这就是所谓“暴露给使用者的就是功能本身”。
- reducer
  - 它最主要的作用其实是解决在使用多个 map、filter、reduce 操作大型数组时，可能会发生的性能问题。而通过使用 transducer 和 reducer，我们就可以优化一系列 map、filter、reduce 操作，使得输入数组只被处理一次并直接产生输出结果，而不需要创建任何中间数组
  - 通过 reducer 的组合，做到普通的组合达不到的性能提升。
  - composeReducer 原理
  - mapReducer
  - filterReducer
  - 利用了reduce的第二个参数的初始值可以是一个“空数组”，映射或过滤后，放入“新数组”。



- IO是异步的，IO调用供给者提供可同步或者异步编程模型，存在异步就意味有时间差，有时间差就需要状态管理，才能保证逻辑同步性。在命令式编程中需要引入可变状态或者 IO 莫
- 谁告诉你Monad可以简化IO操作的？ Monad最大的作用就是在pure 函数式编程中处理副作用



- 异步处理
  - 函数式+响应式编程
- 动态加载策略：在前端开发中做资源加载设计
  - 按需加载
  - 懒加载
- 做逻辑计算 = 输入、计算、输出
  - 函数式：纯函数和不可变作为解决思路来管理副作用
  - 事件驱动：响应式编程和函数式编程，如何面对未知以及基于事件变化做出响应。
  





    - 插件式架构
    - 依赖倒置

- 控制反转，是框架经常使用到的一种模式，其核心是反转控制流，由框架来调用应用，而不是应用来调动框架。
- 依赖注入就是为了解决这个问题而生的，它的核心思路是：客户端只需要声明自己依赖的接口，而不要真正去实例化它，真正的实例会在合适的时机注入到客户端中去
- 依赖倒置原则，是面向对象设计原则 SOLID 中的 D（Dependency Inversion），核心要义是：不要让高层依赖底层，而要让底层依赖高层的抽象。
  - 依赖注入的最主要目的，就是为了实现依赖倒置。一个是手段，一个是目的。

- 对象
  - 公开属性
  - 私有属性
  - 静态属性
    - 静态属性只能作用于 class 本身。
    - 普通属性里调用
  - 静态私有属性
- 实现私有属性
  - 主要有闭包、WeakMap 和 Symbol 这三种方式。
    - 构造器 + 闭包
      ```js
      function WidgetG() { var appName = "天气应用"; this.getName = function(){ return appName; }}WidgetG.prototype = (function(){ var model = "支持安卓"; return { getModel: function(){ return model; } }}());var widget7 = new WidgetG();console.log(widget7.getName()); // 返回 “天气应用”console.log(widget7.getModel()); // 返回 “支持安卓”
      ```
- WeakMap，它的特点是只接受对象作为键名，键名是弱引用，键值可以是任意的
- JavaScript 中是通过哪些方法来解决代码复用
  - js：基于原型链的继承
  - 委托
  - 借用：在 JavaScript 中，函数有自带的 apply 和 call 功能。我们可以通过 apply 或 call 来“借用”一个功能。
  - 拷贝
  - 组合混入
- JS-代码复用
  - 复制
    - object.assign
  - 组合/委托
- 多态
  - 多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法
  - 可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。
  - 多态机制使内部结构不同的对象可以共享相同的外部接口。即子类可以重写父类的某个函数，从而为这个函数提供不同于父类的行为。一个父类的多个子类可以为同一个函数提供不同的实现，从而在父类这个公共的接口下，表现出多种行为。
  - 多态的使用场景：当类之间存在层次结构，并且类之间是通过继承关联时。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
- 组合、继承意义
  - 业务开发
  - 基础设施？
- object 接口
- 继承、组合
  - 继承 自定而下的关系定义
  - 组合 
- 父母都是以自身经历过往去教育孩子，可以他们为模板下的孩子有可能发展成为不了未来人才
- js 类实现、Object.create
- 实现私有属性的方法其实就两种：闭包和 symbol
- 在 JavaScript 中，this 是在运行时而不是编写时绑定的。所以要正确地使用它，需要考虑到函数调用时的执行上下文。
- 在 this 的绑定中，有一点是需要我们注意的，那就是当我们使用箭头函数的时候，this 是在词法域里面的，而不是根据函数执行时的上下文。
- 箭头函数区别
  - 不能作为构造函数
- JavaScript 当中有几种类型的值
  - 7+1
- 为什么 0.1+0.2 不等于 0.3？
  - 解决
- 如何判断一个值是不是数字
- Object.create
- 如何识别一个数组？ isArray
- 对象创建
  - 字面量语法
  - 构造器语法
- js debug
  - V8
  - debugger client
    - chrome devtool
    - vscode debugger
      - [Working with JavaScript](https://code.visualstudio.com/docs/nodejs/working-with-javascript)
      - [Node.js debugging in VS Code](https://code.visualstudio.com/docs/nodejs/nodejs-debugging)
      - 框架

## 编译原理

- 词法分析
- 语法分析
- 语义分析
- 代码生成

## 网络

- http
  - REST 架构？
- 可靠性保证数据无损地到达目的地
- 称呼
  - TCP,段
  - IP，数据包
  - 链路层，Frame（帧）
- 网络问题
  - 乱序
  - 丢包
    - 包损坏
    - 超过 MUT
    - 超过 TTL
  - 重发（数据被重发，比如中间设备通过 2 个路径传递数据）
  - 阻塞、延迟
- 其他
  - 吞吐率：吞吐量指单位时间内可以传输的平均数据量。比如用 bit/s 作为单位，就是 bps
- 传输层
  - 通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割
  - TCP
- 网络层、链路层
  - 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地
  - 网络层
    - IP 寻址
    - 选路
      - BGP
  - 性能至上的 IP 层
    - 无连接、非可靠、无确认
  - 数据链路层
    - 封装帧
    - MAC 寻址
    - 定义物理层标准
  - 路由器
    - 网络层
    - 连接不同网络
  - 交换机
    - 链路层
    - 连接同一网络下的不同主机
    - 交换
      - 交换技术的本质，就是让数据切换路径。因为，网络中的数据是以分组或封包（Packet）的形式传输，因此这个技术也称作封包交换技术（Packet Switch）
      - 具有交换能力的设备
        - 路由器
        - 链路层交换机


- 数据在网络中交换（封包交换算法），并不需要预先建立一个连接，而是任由数据在网络中传输，每个节点通过路由算法帮助数据封包选择下一个目的地
- 交换传输  ![图 1](https://s0.lgstatic.com/i/image6/M00/38/82/Cgp9HWB5WbqAVlGaAHeNbdcL7hg030.gif)  
- 称呼
  - 传输层：TCP 段
  - 网络层：IP 封包 Packet
  - 链路层：Frame





- 稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。
  - 序号
- 保证顺序的具体算法，以及如何在保证顺序的基础上，同时追求更高的吞吐量
  - 滑动窗口
    - 传输需要保证可靠性，还需要控制流速，这两个核心能力均由滑动窗口提供
- 网络安全
  - https 安全协议
  - 防火墙
- Whireshark 追溯的是最底层网卡传输的 Frame（帧），可以追溯到数据链路层。因此对二进制形式的解读，也就是我们的消息视图也要分层。因为对于同样的数据，不同层的解读是不同的。
- 网之初，性本善，不丢包，不乱序

## 工程

- 工程思维
  - 分解问题
  - 分层
- 应用及工程优化问题
  - 计算
    - 算法优化
    - 增量计算
      - 缓存
    - 并发计算
      - 多核：并行计算
      - 单线程：分片计算

## css

- CSS Modules
- Atomic CSS
- CSS in JS
   - https://github.com/vanilla-extract-css/vanilla-extract
   - https://emotion.sh/docs/introduction
   - https://styled-components.com/

## Web

- Web 缓存
  - http
  - js storage
    - cookie，localStorage和sessionStorage
    - IndexDB
- 性能优化
  - 图片
    - 格式
      - webp
      - jpg
      - png
    - 响应式图片
      - 根据屏幕大小和分辨率选择性加载
        - DPR
        - srcset
        - sizes
    - Image组件的最佳实践
    - Img
      - loading="lazy"：延迟加载
        - 未指定大小的图片会降低 CLS
      - srcset/img-set
      - sizes
- pwa
  - 首屏优化
    - 静态资源优化
      - precache
    - 动态数据优化
      - 字典数据 swr
    - 直出的 html
- webrtc
  - 场景
    - 实时互动
    - 多媒体
- 实现端到端类型安全
  - tRPC、Zod、PrismatTanStack Router

## 可视化

- 可视化
  - 图形引擎
  - 图表
  - UI

## 规划

- 前端工程师发展方向
  - 互联网四大件：ui，api，rpc，service 和 db
  - 转型
    - 全栈
      - BFF
        - 所谓的 api 胶水层解决方案，搞来搞去也无非缓存，RPC、MQ
      - 低代码
        - MPA + 微前端 + CSR、SSR
        - 低代码框架
          - [amis](https://github.com/baidu/amis)
      - 前后类型一体化
    - 平台前端
    - 垂类前端
      - 互动游戏，3d，xr，音视频

## 其他



- DI
  - 分离依赖
  - 可测试性


- 面向对象系统设计，对需求进行分析从而产生概念模型
- 模型
  - 业务层面：概念模型
  - 实现层面：设计模型
- UML 工具
- 业务需求层面，原型
- 实现层面，模型



- 代码算法组成
  - 业务逻辑 Logic：Logic 部分是真正意义上的解决问题的算法
  - 控制逻辑 Control
- 有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！（代码就会变得更容易改进和维护）



```js
onst program = require('commander');
const build = require('../lib/commands/build');

(async () => {

  // build 命令注册
  program.command('build').description('build project').action(build);

  // 判断是否有存在运行的命令，如果有则退出已执行命令
  const proc = program.runningCommand;
  if (proc) {
    proc.on('close', process.exit.bind(process));
    proc.on('error', () => {
      process.exit(1);
    });
  }

  // 命令行参数解析
  program.parse(process.argv);

  // 如果无子命令，展示 help 信息
  const subCmd = program.args[0];
  if (!subCmd) {
    program.help();
  }

})();

```



- hash：每次 hash 值的变化，浏览器不发出请求，也就不会刷新页面，还会触发hashchange
- history：pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求
  - 但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求
    - 为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。



- js 数组
  - 断言
    - some
    - every
  - 转换
    - map
    - filter
    - **reduce**


逗号表达式


- stale-while-revalidate
  - 场景
    - 资源的 URL 是不能变的
    - 可接受牺牲一次资源的新鲜性
  - 配置：stale-while-revalidate大、max-age小应该是主流的选择
  - must-revalidate指令，可以屏蔽 stale-while-revalidate指令



- 构建工具
  - Bundler
  - Transformer
  - Minimizer
- SWC 的兼容性更好适合 web 前端场景，Esbuild 更适合 node 场景下的开发
  - esbuild
    - [tsx](https://github.com/esbuild-kit/tsx)


- git
  - husky
  - lint-staged 
  - commitlint
- 版本发布：发版与 CHANGELOG 自动化
  - standard-version
  - 根据指定规则自动升级项目不同级别（major、minor、patch）的版本并打 tag
  - 对比历史 commit 提交自动生成不同版本间的可阅读、分类的 CHANGELOG 日志





- em 相对于自身元素的 font-size


- web 攻击
  - 点击劫持
  - 跨站脚本 (XSS)
  - 跨站请求伪造 (CSRF)



- 环境锁定
- 项目模板
  - plop 代码模板生产
  - 支持 Mock 数据
  - 自动生成router，过滤components组件
  - Proxy 代理


css 重叠
相同类名
相同属性

https://github.com/dcastil/tailwind-merge


提示浏览器如何加载资源






JWT的场景，是可靠地发布信息，就像IOS登录一样，将用户信息封装成JWT提供给第三方业务服务，业务服务只需要apple发布的公钥用于验证JWT的真实性，以决定是否使用其提供的内容。
我想，这也是为什么IOS登录时提供的不仅有JWT，还有一个用于访问API的code，后者才是对应的访问凭证。


页面加载速度优化的核心包括三点：减少资源文件的请求数量；减小每个资源文件的大小；提高每个资源的加载速度；


- 循环
- 遍历
  - 迭代
    - for await...of
  - 递归





- Referer
  - Referrer-Policy
    - 默认：`Referrer-Policy: strict-origin-when-cross-origin`
      - 同源时，发送完整的 Referer 字段；
      - 跨域时，如果 HTTPS 网址链接到 HTTP 网址，不发送 Referer 字段，否则发送源信息
  - 设置 Policy 的方法
    - 元素属性
      - rel 
      - referrerpolicy
    - 标签设置整个网页的 Referer Policy 策略
    - Headers 请求头：`Referrer-Policy: no-referrer`
  - 作用及使用场景
    - 防盗链：按照 Referer 来源来判断是否在配置的白名单或者黑名单中，来决定资源能否可被访问
    - 埋点分析：Referer 提供用户的来源网址和整体访问链路
    - 错误排查（接口日志）








- vite
  - 按需编译
  - 没有打包？
  - 冷启动性能优势。
  - 开发和生产环境的一致性
  - 极致的缓存复用
- esbuild
  - 没有热更新
  - 没有缓存
  - 不支持懒打包，比如基于路由和请求的按需打包方案



- 单链表翻转（递归或者循环）
- 树的前中后序遍历
- 动态规划（爬楼梯以及变形问题、斐波那契数列、股票问题）
- 二分查找（以及变形）
- 排序（快排）
- 搜索二维矩阵
- 零钱兑换
- 验证二叉搜索树


- 页面加载
  - 网络层
    - 连接复用
    - 并发连接
    - CDN
    - 缓存
  - 减少页面初载时，所需加载资源的「数量」和「体积」
    - 代码分割
      - 如何查看代码利用率
  - 初始渲染
    - 减少阻塞渲染的请求
      - 将脚本标签放在 body 标签的底部；
      - 使用 async 异步加载脚本；
      - 内联小型 JS 或 CSS 代码段（如果它们需要同步加载）
    - 避免阻塞渲染的顺序请求链
      - 内联合并
      - 预加载或预连接
- 页面交互


- goto
  - 结构化编程
- 指针
  - 修改
    - 面向对象
  - 空引用
    - Maybe，通过类型强制处理？
- 纯函数
  - 状态？


- react
  - render => diff => patch
  - 渲染阶段
    - render
    - 整个组件树的渲染输出之后，React 将 diff 新的对象树
    - diff
  - 提交阶段
    - patch
  - 功能组件：
    useState二传手
    useReducer派遣
    类组件：
    this.setState()
    this.forceUpdate()
    其他：
    再次调用 ReactDOM 顶层render(<App>)方法（相当于调用forceUpdate()根组件）
    从新useSyncExternalStore钩子触发的更新
  - 标准渲染行为
    - React 从树的顶部开始渲染，如果组件没有被标记为需要更新则跳过
    - React 的默认行为是，当父组件渲染时，React 会递归地渲染其中的所有子组件！
      - 在正常渲染中，React 并不关心“props 是否改变”——它会无条件地渲染子组件，因为父组件渲染！
  - 渲染并不是一件坏事——它是 React 知道它是否需要对 DOM 进行实际更改的方式！
  - React Render 规则
    - 纯函数
  - 并发渲染
    - [Fiber](https://github.com/facebook/react/blob/v18.0.0/packages/react-reconciler/src/ReactInternalTypes.js#L64-L193)
      - React 存储了一个内部数据结构，用于跟踪应用程序中存在的所有当前组件实例
      - React 将组件的所有 hooks 存储为附加到该组件的 fiber object 的链表



- 分治
  - 分治思想应用
    - 海量数据排序
      - 分治：拆分成多份小数据
      - 合并：归并
    - 二分查找
- 枚举
  - 算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。
    - 如何穷举
      - 回溯
  - 应用
    - 最值问题：穷举所有可能情况，搜索正确答案
- 回溯
  - 构建状态树，多分支选择模型
  - **剪枝优化**
    - 优化搜索条件
    - 贪心策略
    - 重叠子问题：备忘录/记忆化搜索
  - 题目
    - 全排列
    - 没有重复
    - 八皇后
  - 其他
    - 回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」
    - 要素
      - 问题状态
      - 选择
      - base 结束条件
- 动态规划
  - 应用
    - 求最值
  - 极客
    - 解决动态规划问题，一般有两种思路
      - 状态转移表法
        - 回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码
      - 状态转移方程法：找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码
        - 一种是递归加“备忘录”
        - 另一种是迭代递推
    - 回溯加“备忘录”的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别
  - 子问题
    - 要符合「最优子结构」，子问题间必须互相独立
    - 能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
  - why dp 效率更高
    - DP是枚举有希望成为答案的解。这个空间比暴力的小得多
    - 也就是说：DP自带剪枝。
    - DP的核心思想：尽量缩小可能解空间
  - 关键
    - 状态定义
      - 问题状态x，求问题结果f(x)
      - 重叠子问题
      - 确定「选择」，也就是导致「状态」产生变化的行为
    - 状态表
    - 问题状态
    - 能让状态发生变化的选择
    - 状态转移方程
      - 最优子结构：子问题的最优解能够推导原问题的最优解，这样就不会反复回溯到子问题求解
      - 本质：递推关系
        - 将问题分解成子问题，找重复性，找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
        - **归纳法**
      - 状态转移
        - 我从哪里来？
      　　我要到哪里去？
  - 题目
    - fib
    - 路径计数
    - 最长公共子序列
    - 零钱兑换
    - 爬楼梯
    - 最短路径
    - 背包
  - 做动规思路
    - 「分解问题」的思维模式：大事化小，小事化了”的思想:分层分解问题，分别求解这些子问题，即可推断出大问题的解
    - 数学归纳法
  - 判断问题类型
    - 能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。
- 回溯 vs 贪心 vs 动态
  - 动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的
    - **树结构思维**
  - 区别
    - 回溯（递归）：重复计算
    - 贪心：局部最优解
      - 每一个阶段，我们都选择当前看起来最优的决策
      - 它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。
    - 动态：
    - 动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。
  - 回溯，从条件出发，需要暴力搜索出所有可能结果，再从中搜索出正确答案
- 动态规划与回溯区别
  - 动态规划和回溯算法底层都把问题抽象成了树的结构，但这两种算法在思路上是完全不同的
  - 回溯
    - 遍历
  - 动规
    - 关注问题及问题分解过程


- 问题 => 树结构思维
  - 树的遍历
    - 问题状态升纬度 => 状态树/解答树
  - 分解问题 => 推导原问题
    - 递推形式
    - 递归形式
      - 前序写法
        - 先进先出
      - 后序写法
        - 后序遍历，利用递归的堆栈帮你实现了倒序遍历的效果
          - 利用堆栈保存原来状态

- 二叉树
  - 题目
    - 104. 二叉树的最大深度
    - 144. 二叉树的前序遍历
    - 543. 二叉树的直径
    - 剑指 Offer 55 - I. 二叉树的深度
  - 二叉树解题的思维模式分两类
    - 通关遍历一遍二叉树得到答案：用一个 traverse 函数配合外部变量来实现
      - 需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。
    - 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。
  - 快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历
  - 前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点
    - 前序位置的代码在刚刚进入一个二叉树节点的时候执行
    - 后序位置的代码在将要离开一个二叉树节点的时候执行；
      - 本质上是利用递归的堆栈帮你实现了倒序遍历的效果
    - 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。
      - 遍历有序数组
  - 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。
- 递归写法（有返回）、遍历写法（有全局结果）
  - 意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。
  - 一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了
- 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。
- 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。

2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。









JVM标记清除算法：

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。
- 核心就是标记可达对象，清除不可达对象

不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。





常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。


循环链表
链表操作


单链表 字符串是否是回文字符串的问题






两个有序的链表合并
删除链表倒数第 n 个结点
求链表的中间结点


栈在表达式求值中的应用
栈在函数调用中的应用
栈在括号匹配中的应用
如何实现浏览器的前进、后退功能
leetcode上关于栈的题目大家可以先做20,155,232,844,224,682,496.


循环队列
确定好队空和队满的判定条件。
队空 head = tail
队满(tail+1)%n=head
队列应用 09 | 队列：队列在线程池等有限资源池中的应用
请求排队 任务排队调度
不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。


- 将 table / list 抽象，用类似 scheme 驱动的方式
- ui 都有差异,在设计层面，可能由于业务需求，很难做到统一，不得已自带设计体系
- 后端数据模型没有统一，因此对接数据前后涉及到的前端状态管理、数据流转也未能统一，复用性大打折扣。


性能问题





- 浏览器渲染原理

  - canvas
    - https://www.html5canvastutorials.com/tutorials/html5-canvas-wrap-text-tutorial/
    - https://joshondesign.com/p/books/canvasdeepdive/toc.html
    - https://juejin.cn/post/6844903828916011022
    - https://www.kirupa.com/canvas/canvas_high_dpi_retina.htm
    - https://github.com/jondavidjohn/hidpi-canvas-polyfill
  - 资源调度
    - https://mp.weixin.qq.com/s/K24X2uNPvtbD4vZlXwJMYA
    - https://github.com/GoogleChromeLabs/preload-webpack-plugin
    - https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf
  - https://www.youtube.com/watch?v=kNzoswFIU9M&list=PLNYkxOF6rcICgS7eFJrGDhMBwWtdTgzpx


- 计算机导论

  - https://www.coursera.org/learn/jisuanji-biancheng/home/week/1
  - https://www.bilibili.com/video/av21376839/




- 相比中心化的计算，边缘计算延迟低、链路短，能够将更好的体验带给距离边缘计算集群最近的节点。从而让用户享受到更优质、延迟更低、算力更强的服务。

- 会话（Session），会话是应用的行为
- 因为可靠性给予 请求响应，你发请求同步包，对方需要回复你一个 ack 包作为响应
- TCP 是一个面向连接的协议
- UDP 是一个面向报文（Datagram-oriented）的协议


- 这个  FIN 报文代表客户端不会再发送数据了



- Symbol
  - 使用 Symbol 做为私有属性
- Symbol.for(str) 是新建一个以该字符串为名称的值，并注册到全局，如果已注册过，就直接返回
- Symbol.iterator 迭代器协议


- “JS 是单线程的”指的是执行 JS 代码的线程只有一个
- 这里的异步不是 JS 自身实现的，其实是浏览器为其提供的能力。
- 浏览器异步任务的执行原理背后其实是一套事件驱动的机制
- 事件循环其实就是在事件驱动模式中来管理和执行事件的一套流程。


- 迭代器协议
  - for of
  - 数组
  - 生成器函数




因为屏幕像素密度问题，根据devicePixelRate不同要将canvas设置对大小





二分查找法：有序对半查找


去中心化的JWT token
        优点：
            1. 去中心化，便于分布式系统使用
            2. 基本信息可以直接放在token中。 username，nickname，role
            3. 功能权限较少的话，可以直接放在token中。用bit位表示用户所具有的功能权限
        缺点：服务端不能主动让token失效

    1. 中心化的 redis token / memory session等
        优点：服务端可以主动让token失效
        缺点：
           1. 依赖内存或redis存储。
           2. 分布式系统的话，需要redis查询/接口调用增加系统复杂性


- JWT的场景，是可靠地发布信息，就像IOS登录一样，将用户信息封装成JWT提供给第三方业务服务，业务服务只需要apple发布的公钥用于验证JWT的真实性，以决定是否使用其提供的内容
  - 无状态服务

用户状态管理

将认证信息存放在标记为HttpOnly，Secure，Same-Site=strict的Cookie中，从而避免XSS和CSRF；


- 代码无非对输入数据的计算
  - 数据处理操作
    - 增
    - 删
    - 查
  - 这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？
  - 寻找合理的数据结构最能帮助你提高数据操作的使用效率



- 递归
  - fibo
- 分治
  - 没有重复计算
    - 动态规划
    - 记忆
  - pow
- 贪心
  - 子问题的最优解能够递推到最终问题的最优解
  - 最优子结构
- 分支选择模型
  - 买卖股票
  - 优化
    - 剪枝


- 阿里三面：灵魂拷问——有react fiber，为什么不需要vue fiber呢？
  - React 从诞生之日的设计哲学就是，当状态发生变化时，重新创建所有视图。
  - 即使你只是修改了组件树最深处的一个小小的状态，React 仍然需要自顶重新创建整个 vdom 树并且 Diff
  - 引入 fiber 机制后使得 React 的渲染过程可以中断，让出主线程响应用户事件，或者允许插入更高优先级的更新
  - Vue 有一套细粒度的响应式机制，框架的更新粒度是组件级别，除此之外还有 Block Tree 等分离静态/动态模板的优化手段，更新的效率是足够高的，也就没有必要引入 fiber 这样的机制
- why react fiber



- 范式层：API + 语法
- 运行时/框架层
  - 线程模型
  - 事件驱动模型
- 操作系统
  - 屏蔽硬件
  - 向上层提供异步特性
    - 多线程
    - 异步事件
- 硬件是可以异步、并发工作的


- 闭包是指函数能够记住和访问其词法范围，即使该函数在其词法范围之外执行也是如此。



- 箭头函数
  - 没有 arguments
  - 无法通过 apply、call、bind 改变this指向


- 位运算
  - 与
  - 或
  - 异或
  - 取反
  - 左移
  - 右移
- 字典树






- 创建包
  - 运行 `npm init -y` 以创建 package.json 文件
  - package.json name
- 代码
  - 构建 CommonJS (CJS) 和 ECMAScript (ESM) 模块格式
    - p
     ```
     "exports": {
    ".": {
      "import": {
        "types": "./lib/esm/types/index.d.ts",
        "default": "./lib/esm/index.mjs"
      },
      "require": {
        "types": "./lib/cjs/types/index.d.ts",
        "default": "./lib/cjs/index.js"
      }
    }
  },
    ```

    ```
    “types": "./lib/cjs/types/index.d.ts",
"main": "./lib/cjs/index.js",
    ```
- 单元测试
  Mocha.js、Chai.js 和 ts-node。Mocha.js是一个测试运行器，Chai.js是一个断言库，用于帮助确定您是否从代码中获得了预期的结果，而ts-node帮助我们在 TypeScript 项目中使用这些工具。
- 集成测试
  - 本地
    - npm link
    - npm pack
  - 代理
    - Verdaccio
- 发布包
  - 在您的文件中添加一个files字段package.json，以指示当 npm 打包您的代码以供发布时应包含哪些文件。
  - npm version <major|minor|patch>
  - prepack在打包 npm 包以准备发布到注册表之前，npm 使用该脚本
  - 安全检查
  - `npm publish --access=public`
  - 自动化版本管理和发布
- 集成 CI/CD 





- 状态逻辑的组合特别棘手
- 如果您需要它们与组件状态交互怎么办？








- JS
  - Tagged template literals
  - Symbols
  - 2020
    - Optional chaining
    - Nullish coalescing operator (??)
    - import()
    - String.matchAll
    - Promise.allSettled()
  - 2021
    - String.replaceAll()
    - Promise.any
    - Nullish coalescing assignment (??=)
    - Logical and assignment (&&=)
    - Logical or assignment (||=)
    - WeakRef: Hold a “weak” reference to an object, without preventing the object from being garbage-collected.
  - 2022


- 日志
  - 级别
  - 格式化
  - 持久化

- `new Function`
  - `new Function ([arg1, arg2, …argN], functionBody)`
  - 上下文是全局的
  - 场景：动态生成代码、计算



```js
const pipe = (...fns) => (value) => fns.reduce((v, fn) => fn(v), value)

const asyncPipe = (...fns) => (value) => fns.reduce((chain, fn) => chain.then(fn), Promise.resolve(value))

const compose = (...fns) => (value) => fns.rightReduce((v, fn) => fn(v), value)
```

- 异步编程
  - ?
  - 实现
    - 观察者模式
    - 链式调用
  - 应用
    - 取消一个 Promise
      - Promise.race() 
    - 并发请求
    - 顺序执行一堆异步程序


- Vue
  - 如何避免 data 中一个复杂对象（自身或属性对象）被默认被创建为响应式（Non-reactive Object）的过程
    - Object.defineProperty
    - Object.frezen


- NodeJS
  - 架构
  - 模块
    - 模块规范
      - 全局对象
    - 模块解析以及加载机制
    - 包管理
      - 创建包
      - 安装、更新包
      - 脚本命令
  - 错误处理
  - 异步编程
  - 事件循环
  - 深入
    - 源码
    - 插件扩展

- 日志：收集程序运行期间的信息
  - 字段
    - 信息
    - 时间戳
    - 日志级别
    - 来源
    - 目的地
  - 日志级别：表示消息优先级
    - FATAL：您的应用程序无法恢复
    - 0: error：表示系统中的错误情况恰好会停止特定操作，但不会停止整个系统。当第三方 API 返回错误时，您可以在此级别登录。
    - 1: warn
    - 2: info
    - 3: verbose
    - 4: debug
    - 5: silly
  - 格式化
  - 持久化
  - 查询

- JavaScript 异步原理
  - 有个事件循环不断给 JS 引擎分发队列任务
  - 事件循环
  - 宏任务、微任务
  - 异步编程
    - 回调函数
    - Promise
    - Generator
    - async/await
    - 浏览器与 Nodejs 中的异同


- 软件评估标准
  - 性能
  - 可维护
  - 可扩展
  - 可复用


- 规划
  - 跟着公司业务走，尽可能转管理，完成很多的价值转换
  - 深入 3d，如果未来这块有路，朝这块走走，音视频
  - 转行？
  - 副业？

- 一件商品吸引顾客的要素
  - 非常好
  - 性价比高
  - 信仰、喜欢、爱好之类


- 大型项目的 CSS 编写和维护
  - 难点
    - 协作难 易冲突 维护苦 灵活性差
  - 需求
    - 可维护性
    - 可扩展性
    - 可重用
  - CSS 规则难以管理
    - 全局命名空间
    - 权重(特异性)
    - 级联规则
  - CSS 的最佳实践
    - 样式表和关注点分离
    - CSS 方法论
      - Atomic Design
      - BEM


- 软件设计
  - 分层
- 前端架构组织
  - 前端代码逻辑 = 业务逻辑 + 视图逻辑 + 功能
  - 前端用ddd话，像是各种领域服务值对象聚合根的概念其实是弱的，因为逻辑基本都在后端，所以大部分前端场景都是贫血模型，在前端的业务领域主要关注的是概念模型，模型核心属性，概念模型关联关系这些，前后端和产品对于领域模型的理解应该是一致的。所以像是检验这块应该属于视图/交互模型的职责，业务模型本身应该是不感知的
  - 分层
    - DB 持久化
    - Model：数据模型、业务模型
    - Service 业务交互服务场景
    - View（视图框架）
      - MVVM：面向 Model
      - MDV：把 Model 实例化并和 DOM 联动
      - UI 状态逻辑
- 框架原理
  - react、vue、ng这些框架的功能其实可以分为两个部分，一个是UI视图的部分，负责对接dom，另一个是响应系统的部分，负责实现数据联动。这两部分理论上不是耦合的，是可以相互组合的。
  - 响应原理
    - 作用
      - UI视图的部分，负责对接dom，响应系统的部分，负责实现数据联动
      - 由前端框架来响应式地连接UI和model
    - 原理
      - Vue
        - vue和mobx这类基于proxy的响应方案，核心依赖的就是“容器对象引用不变，内部属性状态发生改变”，而面向对象的class实例的本质，就是一个引用不变的对象，里面有一些可变的状态，还有一些用来改变这些状态的动作。完美配合！
      - React
        - react原生的响应式方案是非常依赖数据不可变性的
        - 监测变量引用（reference）的变化，然后整个子树去协调更新
        - 要求“内部不要变，容器整体引用要变”，也就是你每一个动作都必须生成一个新的实例，这样它才能检测到状态的变化。刚好和对象的特性是反的。这就天然切合声明式编程、FP的特质。
    - 上层范式
      - 视图范式
      - 模型范式
      - 我们讨论react class组件是FP还是OOP，其实不是讨论class组件API本身的风格，而是讨论“它作为UI库，更容易和FP/OOP哪种风格的model模型相对接
- js的函数一等公民加上词法作用域，带来的闭包特性
- 单线程模型风格
  - 最基础的是声明式编程，或者说函数式编程。这个风格最大的特点就“数据不可变”，变量和属性都只能赋值一次，不能重新赋值。
  - 在声明式编程的基础上，加上可变状态，也就是允许变量和属性重新赋值，就变成了“基于对象的编程”
    - 所谓“对象”，就是可变的数据的组合
  - 在此基础上，再加上对象之间的继承关系，就从OBP变成了OOP，“面向对象的编程”
    - 通过class父类子类来继承，或者通过prototype原型链来继承，各种不同的继承方案，都可以。但是继承是很容易误用的，组合优于继承，所以至少在前端开发中，实际上真正的OOP比较少，大部分是OBP。
- 这五个东西里面，只有C和D之间有强相关性，其他两两之间其实都没啥关系。对于前端开发，真正需要讨论的重大的技术方案决策，其实就是选择proxy响应式+OOP模型，还是选择react响应式+FP模型
  - C 响应原理：react 原生 vs. mobx 代理
D 模型风格：面向对象 OOP vs. 函数式 FP
- 所以，在“正常”的语言里，你搞一个user充血对象，里面挂俩save load方法，或者你搞一个user贫血对象，然后给他配两个专属saveUser loadUser函数，效果是完全一样的。事实上，c这样缺乏class基础设施的语言就是这么搞oo的，只要把user struct和相关的函数归类放好，比如放在同一个文件里，别乱掉，就完全可以表达大部分充血entity能够表达的业务逻辑。


- 设计
  - 分层与协议


- 其主要原因是只用了 Node.js 做一些工具或者简单的服务端应用，并没有真实地了解 Node.js 的特点以及所适用的场景，因此谈不上熟练应用 Node.js。如果你想在简历中带上，熟练应用 Node.js，那你可以带着这些问题来学习下本讲的知识点。
- node 服务开发
  - 首先我们需要应用工具将服务发布到远程机器上，这里就涉及devops 工具；

我们需要保证远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们常见的 PM2；

我们需要判断远程服务运行是否正常，这就涉及远程服务的监控和告警机制；

遇到运行问题时，我们需要通过远程日志来定位分析问题，这就涉及日志打印和跟踪染色。

- 后端服务应用则必须关注服务的稳定与安全。因为都是基于用户发送的内容，用户有时候发送一些非法或者违法的内容。其次需要关注并发性能，因此必须充分考量服务器所能承载的最大用户并发数，在并发即将达到阈值时，又需要考量平行扩容方案。还有就是为了用户体验，需要充分做好服务的性能优化，做到极致的接口响应时间。
- 你需要在每个业务场景中，思考在哪里进行一些关键逻辑或者数据打印日志信息，这里就需要 Node.js 日志服务模块，而这类日志服务又不能影响性能，因此需要考虑一些高性能日志打印工具。其次在服务端运行，你可能会遇到诸如内存泄漏、句柄泄漏或者进程异常退出等问题，因此这里就需要这类工具和方法来分析定位现网问题。


- 一个是前端工程化的应用，另外一个是后端服务应用






- 在分层理念中，一种通用的分层思想，是将应用分为“数据层”“逻辑层”“表现层”
  - 前端分层架构
    - 视图层
    - 应用层
    - 领域层
    - 基础设施层
- 我们的代码同时承载了业务的逻辑和界面的交互逻辑
- 领域模型
  - Model：描述业务的实体对象，是业务所围绕的核心概念，你的公司所做的业务，本质上就是在创建和处理这些对象
  - Service：描述工作流程的服务对象，它们主要是对实体对象的处理过程、逻辑、事件，是使得业务产生实际效果的非实体对象
    - 领域模型帮我们描绘了有关这个业务的核心对象的各种逻辑，但是，我们的这个业务实体会面对很多场景，每一个场景下，可能存在有些特定的转化逻辑，这就需要我们在领域模型的基础上，提供对应场景的服务。简单讲，你可以把领域服务想象成领域模型实例的处理工厂，在这些处理中，我们是为了描述特定场景下的业务需求，所以，领域服务仍然是业务描述，和UI无关。
  - 总而言之，领域模型是相对比较普遍的业务描述，而领域服务是相对比较特殊的业务描述。
    - 一般来讲，服务需要遵循无状态的原则，状态一般会放在领域模型中。
  - 交互模型
    - 交互有两种，一种是界面交互，一种是业务交互
    - 交互模型会引用领域模型和领域服务，同时，它还会被用到视图层中，交给视图层使用
    - 可以把交互模型和我们平时讲的“状态管理器”划一个约等号，交互模型的实例向视图层提供状态属性和方法，属性用于视图层进行渲染，而方法用于事件回调
  - ViewModel
- 大部分业务逻辑基本都在后端，所以大部分前端场景都是贫血模型，在前端的业务领域主要关注的是概念模型，模型核心属性，概念模型关联关系这些
- ui => view-model => store/container => service => model
  - data 的 reactivity 应当仅用于从 model 向 view 的数据绑定，除此之外的逻辑都不应该依赖 data 的 reactivity
  - 数据驱动视图，事件驱动业务逻辑
    - 业务开发下，更应该关注的是业务模型，行为指令，这才是最好维护的
  - 视图层只做 data 消费，业务写在 Model 层
  - 不要视图驱动业务模型


- srs、zlm、m7s

- NAT(网络地址转换)技术
  - 原理
    - 内外网 IP、端口映射关系
  - 方式
    - 只 IP 转换
    - 端口多路复用







- 软件
  - 设计模式：代码编写层面的设计指导
    - 是一种使代码更加面向对象、可维护、可重用的指导原则12。软件设计模式强调的是解决方案，目的是提高代码的质量和效率
  - 软件架构：软件架构是一种软件系统的结构组织，是对软件系统的各个模块、组件、接口、数据流等的描述和规划，是一种使软件系统更加稳定、可扩展、可测试的指导原则34。软件架构强调的是组织和纲要，目的是提高系统的性能和可靠性。


- fs
  - stat
  - path
    - relative
    - resolve
    - basename
    - dirname
    - extname
    - normalize
  - open
    - filehandle
      - fd
  - close
  - readFile
  - writeFile


- 业务层
- 渲染层

- this week
  - 博客
  - 延迟还贷
  - 找工作
    - 简历
      - 复盘项目经验
    - 复习
- 学习思路
  - what：是什么
  - why：为什么
  - how：怎么做
    - 做经典题
  - use：应用
- 规划
  - 职业
    - 不写代码，你还会做什么？
    - 或者说你怎么在代码这条路写到极致？
      - 大头兵
        - 技术经验过硬
        - 性价比要高
  - 大前端方向
    - 传统 Web 前端
    - 前端工程化
    - 跨端：桌面端、移动端、小程序
    - 图形：图表、3D
    - 游戏
    - 后端服务：Node BFF
    - 音视频
- 面试刷题/重学
  - 算法
  - Vue
  - JS
- 学习
  - node
  - rust
  - 音视频
  - 可视化
    - canvas 学习及应用
  - 软件设计
- 悟
  - 人生就是一个见招拆招的过程




- 小程序
  - 双线程架构
    - 沙盒
  - JS的执行和页面绘制逻辑运算是一个线程中的

- 进程通信
  - 序列化
  - 内存拷贝


- react
  - ui is a value
  - ui 即 state
  - 组件就是 state 与 ui 映射关系


- 图形
  - API
    - WebGPU
  - Babylon.js 
- 可视化
  - 数据 => 图表
  - UI


- 性能
  - TTFB： Time to First Byte——被视为点击链接和第一位内容进入之间的时间。
  - FP： First Paint - 任何像素第一次对用户可见。
  - FCP： First Contentful Paint - 请求的内容（文章正文等）变得可见的时间。
  - TTI: Time To Interactive——页面开始交互的时间（事件连接等）。



- 部署
  - node server
  - static
    - ssg
    - sw


- 工具层
- 运行层
- 语言层