- Web 性能优化
  - 客户端
  - 网络
    - 延迟
  - HTTP 服务器
    - 吞吐量（requests per second）
      - `ab -c 100 -n 10000 'http://www.xxx.com'`
    - 并发数（concurrency）
    - 响应时间（time per request）
    - 硬件
      - CPU
      - 内存
      - 硬盘
      - 网卡
      - 带宽
  - 前端
  - 网络传输
    - 请求链接
      - 建立连接
        - 长连接、多路复用
  - 后端
    - 选用高性能的 Web 服务器
      - Nginx/OpenResty
      - 利用 Nginx 强大的反向代理能力实现“动静分离”
    - TCP 的新特性“TCP Fast Open”

```
server {
  listen 80 deferred reuseport backlog=4096 fastopen=1024; 


  keepalive_timeout  60;
  keepalive_requests 10000;
  
  location ~* \.(png)$ {
    root /var/images/png/;
  }
  
  location ~* \.(php)$ {
    proxy_pass http://php_back_end;
  }
}
```


- 性能
  - 网络
    - CDN
  - 页面
    - 页面加载
      - 关键资源
        - 大小
        - 数量
      - 关键渲染路径
    - 页面交互


- 网络问题
  - 带宽
  - 阻塞、延迟
  - 丢包
- TCP 带宽与延迟
  - 发送方和接收方之间的往返时间 （RTT） 越短，发送方根据接收方容量调整其传出带宽的速度就越快
- TCP
  - TCP 使用三次握手来创建新连接
    - 发送方选择一个随机生成的序列号“x”，并将 SYN 数据包发送给接收方。
    - 接收方递增“x”，选择随机生成的序列号“y”并发回 SYN/ACK 数据包。
    - 接收方递增“x”，选择随机生成的序列号“y”并发回 SYN/ACK 数据包。
  - Flow Control 流控制
    - 防止发送方压倒接收方
  - 拥塞控制
    - 防止淹没底层网络，丢包
    - 发送方如何找出底层网络的可用带宽是多少？估计它的唯一方法是通过测量经验
- TLS 握手还需要最多两次往返


性能

  - TTFB： Time to First Byte——被视为点击链接和第一位内容进入之间的时间。
  - FP： First Paint - 任何像素第一次对用户可见。
  - FCP： First Contentful Paint - 请求的内容（文章正文等）变得可见的时间。
  - TTI: Time To Interactive——页面开始交互的时间（事件连接等）。


- 性能优化
  - 计算
    - 并发
      - 目的：实现多个任务同时或者高效执行
        - 做异步：让任务独立于当前执行流，比如避免 IO 等待导致 CPU 空闲，提高程序响应能力
        - 并行计算能力
      - 并发设计要点
        - 事务同步
          - 阻塞 API
          - 并发模型都可以视作是事件驱动的，它们大多依赖于一些消息队列，管道，邮箱这些设施，来保证并发事务间正确交互和同步所需要的特性
        - 并发模型
          - 线程模型/同步模型
          - 事件模型/异步模型
          - 对比
            - 线程适合处理事务之间有着明显因果关系或者相关性很强的场合
            - 事件驱动比较擅长处理异步事件的问题，但当需要处理跨事件的事务逻辑时，事件驱动都会变得复杂难解；事务驱动有一点优势的地方，就是它与生俱来的并发性和灵活性
        - 运行时
          - 调度
            - 抢占式
            - 协作式
          - 通信
        - 硬件层
          - 单核 => 分时方式
          - 多核 => 并行方式
      - 原理
        - 单机
          - 
        - 集群
          - 集群是将多个计算资源（可以是物理计算机、虚拟机、容器等）连接在一起，以实现共享资源、提高性能、可用性和可扩展性的技术
        - 内核态、操作系统层面提供的并发能力：多进程多线程（抢占式调度）
          - 进程通信
            - 进程外
              - 管道
              - 消息队列
              - 信号量
              - RPC
            - 进程内
              - SM，SharedMemory 共享内存
              - FFI，Foreign Function Interface
              - WASM
          - 多线程共享内存 => 状态竞争
            - 互斥锁机制
            - 通信范式
              - CSP
              - Actor
        - 用户态（协作式调度）
          - 协程
          - 事件循环
    - 算法
    - 缓存


- 性能优化
  - 性能指标
    - 服务器性能
      - 吞吐量（requests per second）
      - 并发数（concurrency）
      - 响应时间（time per request）
        - 合理利用系统资源，提高服务器的吞吐量和并发数，降低响应时间。
    - 客户端
      - 资源请求：客户端 HTTP 性能优化的关键就是：降低延迟
        - 网络
          - 地理距离
            - CDN
          - 带宽
      - 页面渲染
  - 性能优化思路
    - 硬件
    - 软件
      - 体积
        - 拆分
        - 编码
      - 调度/算法
        - 并发
      - 缓存


- ui、api、rpc、mq、servcie、db
- node 服务开发
  - 部署、devops 工具；
  - 远程服务的安全与稳定，这就涉及一些进程管理工具，例如我们常见的 PM2；
  - 我们需要判断远程服务运行是否正常，这就涉及远程服务的监控和告警机制；
    - 遇到运行问题时，我们需要通过远程日志来定位分析问题，这就涉及日志打印和跟踪染色。
  - 后端服务应用则必须关注服务的稳定与安全。因为都是基于用户发送的内容，用户有时候发送一些非法或者违法的内容。
  - 其次需要关注并发性能，因此必须充分考量服务器所能承载的最大用户并发数，在并发即将达到阈值时，又需要考量平行扩容方案。还有就是为了用户体验，需要充分做好服务的性能优化，做到极致的接口响应时间。
- 你需要在每个业务场景中，思考在哪里进行一些关键逻辑或者数据打印日志信息，这里就需要 Node.js 日志服务模块，而这类日志服务又不能影响性能，因此需要考虑一些高性能日志打印工具。其次在服务端运行，你可能会遇到诸如内存泄漏、句柄泄漏或者进程异常退出等问题，因此这里就需要这类工具和方法来分析定位现网问题。


- Web 性能优化
  - 前端性能优化
  - 后端性能优化