---
discussionID: gKcL1LRHEhEl6Fm-AZng6
release: true
tags:
 - 函数式编程
 - 编程范式
---

# 函数式编程

- 函数式编程
  - 函数式编程（Functional Programming，FP）是一种将计算视为函数求值过程的编程范式，并强调使用纯函数、不可变数据和函数组合来构建软件系统
  - 特征
    - **纯函数**：函数式编程中的函数指的是**数学**中的函数，即一个输入到输出的映射，其特点：
      - 给定同样的输入有且只有唯一的输出
        - 意味着函数的结果只能依赖于输入参数
      - **无副作用**：函数不会产生除计算结果以外的事，比如 IO 操作、全局状态修改等
    - **不可变数据**：函数式编程语言中的变量不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即**某个符号所对应的值是永远不变的**
    - **函数是一等公民**，强调使用**高阶函数**组合其他函数，将多个函数组合成一个更复杂的函数，提高代码的复用性和可读性
    - **惰性求值**：惰性求值（Lazy Evaluation）是一种求值策略，只有在需要结果时才会进行计算
      - Thunk：将把函数的参数看作是个数学上的计算表达式，在真正需要的时候才会计算，相当于带回调参数的函数
      - 定义无穷数据结构，抽象“**数据流**”：由于惰性求值，我们可以抽象构造一个无限长集合，无限长集合中的元素并不是预置进去的，而是在需要的时候才计算出来的。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们。
  - 函数式编程的优点
    - 可读性：函数式编程强调代码的表达能力和可读性，使代码更易于理解和维护。
    - 可测试性：纯函数和不可变数据使函数式代码更易于测试，减少了对外部状态和依赖的需求。
    - 并发性：函数式编程天然适合并发编程，由于纯函数没有副作用，可以安全地在多线程环境中执行
      - 可以说，**函数式编程对程序中的赋值进行了限制和规范**
  - 函数技巧
    - 输入
      - 柯里化（Currying）：将一个多参函数，转换成一个依次调用的单参函数（柯里化是为了规范统一函数参数，更好得**适配**函数组合）
        - js 实现
          ```js
          // f(a, b, c) => f(a)(b)(c)
          function curry(func) {
              return function inner(...args){
                  if(args.length >= func.length){
                      return func.apply(this, args)
                  } else {
                      return function(...args2){
                          return inner.apply(this, args.concat(args2))
                      }
                  }
              }
          }

          function sum(a, b) {
              return a + b
          }

          let currySum = curry(sum)

          console.log('currySum(1)(2)', currySum(1)(2))
          console.log('currySum(1, 2)', currySum(1, 2))
          ```
        - 反柯里化
      - 部分应用函数（Partially Applied Functions）：固定部分的参数，返回一个更少参数的函数
    - 输出
      - 记忆（Memoization）
    - 结构
      - 组合（Compose）：从右往左执行函数列表，按照类似  `f(g(x))` 的传参执行顺序来排列的
        - js 实现例子
          ```js
          // compose
          function compose(...fns) {
            return fns.reduce((fn1, fn2) => (...args) => fn2(fn1(...args)))
          }

          const add10 = x => x + 10
          const mul10 = x => x * 10
          const add100 = x => x + 100

          // (10 + 100) * 10 + 10 = 1110
          compose(add10, mul10, add100)(10)
          ```
      - 管道（Pipeline）：从左往右执行函数列表
      - reducer: 最主要的作用其实是解决在使用多个 map、filter、reduce 操作大型数组时，可能会发生的性能问题
        - composeReducer
    - 值操作
      - map
      - filter
      - reduce
      - [函子：Functor、Applicative、Moand](#函子functorapplicativemoand)
        - Optional（Maybe Monad）
        - IO Monad：可以用来延迟函数的执行，它的 value 里面存储的是一个函数

## 函子：Functor、Applicative、Moand

函子（Functor）是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。可以理解成一种容器对象类型，其包装一个值并且围绕值提供一些特殊的运算功能。函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器----函子。

学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。

一般约定，函子的标志就是容器具有`map`方法。该方法将容器里面的每一个值，映射到另一个容器：

```js
function Just(val) {
    return { map };

    function map(fn) { return Just( fn( val ) ); }
}

const A = Just(3)
const B = A.map(v => v + 2) // Just(5)
```

![图 1](./images/1665764790545.png)  

`map` 也同样可适用于集合：

![图 2](./images/1665764954907.png)  

应用函子（Applicative）：在 Functor 基础上，能够把一个函数值的函子应用到另一个函子的值上

```js
function Just(val) {
    return { map, ap };

    function map(fn) { return Just( fn( val ) ); }

    function ap(anotherMonad) { return anotherMonad.map( val ); }
}

const A = Just((x, y) => x + y)
const B = Just(2)
A.map(curry( add, 3)).ap(B) // Just(5)
```

![图 6](./images/1666196183912.png)  

函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是这样就会出现多层嵌套的函子。

单子（Monad）：单子是一个带有 chain 的函子，

- 平铺值:处理嵌套函子
- 链式调用：即通过包装数据并赋予其额外的链式运算能力来简化一系列多步骤的计算

chain 通常又叫做 flatMap 或 bind，它的作用是 flatten 或 unwrap，也就是说它可以展开被 Just 封装的值 val

```js

function Just(val) {
    return { map, chain };
    
    function map(fn) { return Just( fn( val ) ); }
   
    function flatMap(fn) { return fn( val ); }
}
```
- Applicative 将一个封装的函数应用到封装值上
- Monad 将一个 “接受一个普通值并回传一个被封装的值” 的函数应用到一个被封装的值上


## 参考

- 极客专栏《软件设计之美》
- [函数式编程入门教程](https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)
- [对普通程序员来说，Monad有什么用？ - 袁洋的文章 - 知乎](https://zhuanlan.zhihu.com/p/575642401)
- [图解 Functor、Applicative、Monad](https://sxyz.blog/functors-applicatives-and-monads-in-pictures/)















函数式的纯洁性在于对于一个特定的参数，必定存在一个特定的返回值。所以函数式的执行是无关顺序的。
而在现实世界里，很多东西就必须是有顺序的，比如输入输出。于是Haskell决定用monad去模拟这种操作。monad来源于范畴论，他并不解决副作用问题本身，而是对此类问题提供了抽象。

- 函子：它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。
  - 一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。
  - 函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位
- Monad 函子
  - Monad 函子的作用是，总是返回一个单层的函子。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。


我们就理解了Monad大概是个什么。它可以看做是对纯函数的一种补充。如果函数中有一些脏东西，它把脏东西装到盒子里，然后以一种假设/计划的方式描述这个脏东西，使得形成的东西仍然是一个纯函数，没有对世界产生影响。只有当我们真正打算大干一场的时候，才会真正和世界接触交互，把脏活累活给干了

从我们刚谈及的IO Monad角度来看，Monad是一种对程序实现的抽象。我们可以把要怎么干活（计划，纯函数）和具体去干活（实践，不纯的函数）拆分开来，让专业的人/机器/程序做专业的事情

串联的时候可以将泛型内部的值取出来返回新的泛型，可以用来把操作串起来但不执行





- 伴随着范畴论的发展，就发展出一整套函数的运算方法
  - 合成
  - 柯里化
- 函子
  - 它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。
- Monad 函子的作用是，总是返回一个单层的函子


- 继承的问题
  - 紧耦合的关系——父类的任何变化，都将直接地影响到子类



- FP vs OOP
  - FP 重行为
  - OOP 求解，是因为这是一个重数据结构、轻行为的场景
    - 通过寻找事物之间的共性，来抽象出对一类事物的描述
  - 采用面向对象进行系统设计、程序模块组织
    - 采用函数式编程的风格指导类的接口设计
    - 接口具体的实现中使用结构化编程提供的控制结构


函数式编程
    - Lambda 演算和图灵机是等价的？
    - 函数式编程来自 λ 演算法
      - λ 演算，规则非常简单，只有三条
        - `<表达式>::= <标识符>`
        - `<表达式>::= (λ<标识符>.<表达式>)`
          - λx.2*xx => 2*x 
          -  λ 字符后面的变量是函数的参数，点后面的表达式是您将替换作为参数传递的任何值的位置
        - `<表达式>::= (<表达式> <表达式>)`
    - 用面向对象编程的方式对系统的结构进行搭建，然后，用函数式编程的理念对函数接口进行设计/或者说计算设计
      - 分离可变状态
      - 如何做到“不可变”？
        - 使用不可变的语法
        - 拷贝数据而不是修改
        - 如果要使用变量，只使用局部变量
        - **事件溯源（Event Sourcing）**：把对象的状态每次变化抽象成独立的事件进行保存，对象的状态变化可由一系列事件的调用重现。
      - 副作用隔离
        - Monad
      - 可组合性 => 接口 => 抽象 => 分离关注点
        - 函数的合成还必须满足结合律

- 函数式语言的理论模型是lambda演算？
  - <表达式>::= <标识符>
  - <表达式>::= (λ<标识符>.<表达式>)
  - <表达式>::= (<表达式> <表达式>)
  - 特征
    - 数据不可变
    - 其他
      - Curry
      - Lazy evaluation (惰性求值)
        - 函数的参数如果是个计算表达式的话，这个将被看成一个thunk, 真正需要的时候才会计算
        - 无限数据流


- 函数式更关系逻辑本身
  - 状态 -> 态射 -> 状态 -> 态射 -> ...
- 面向对象
  - 构造 -> 属性 -> 行为1 -> 行为2 -> ... -> 析构
- 面向对象认为事物有生命周期（构造析构），而函数式认为世间万物都只是变化而已
面向对象人为对象在生命周期内是稳定的，而函数式认为事物在每个时刻都是不同的，上一秒的你和下一秒的你就是完完全全两种东西
- 面向对象自顶向下，而函数式依靠组合编排



- 值保证不会显式改变一个量，而纯函数保证的是，不会隐式改变一个量
- 不可变就是在减少程序被外界影响的同时，纯函数减少对外界的影响



        - 脏东西，这种被称为对现实世界的影响（Effect）
        - 因为脏东西被装在盒子里，我们又回到了纯函数的世界。换句话说，在计算的过程中，一旦出现了脏东西，那我们就用一个新盒子把它装进去，然后对自己说，“这个盒子里有个脏东西”，然后进行下一步。注意到，我们没有打开盒子，所以自然就没有对世界产生任何影响。
        - 把这个装了脏东西的盒子当做函数的输出
          - 打开的过程是有影响的，但是在计算f(x)的过程中，是纯函数，是没有影响的。这就是我们经常说的，要把影响（或者说副作用）push to edge，即推到纯函数的外面，程序的边缘地带。

- 函数操作复习
  - 部分应用可以减少每次函数调用时需要传入的参数，而柯里化更是把函数调用时需要传入的参数数量，降到了 1。它们实际上都起到了控制参数数量的作用
  - 通过柯里化每次传一个参数
- Pointe-Free Style
  - var isOdd = (x) => equalsToOne(remainderOfTwo(x));
  - point free 的理解：把参数去掉，是指参数的含义已经体现在函数声明（名字）里面了，比如 equalsToOne，那就是说传入的值是否等于 1，如果是 equalsToA，那么这个 A 就得传为参数，加上要比较的 x 就是两个参数了。这就是所谓“暴露给使用者的就是功能本身”。
- reducer

  - 它最主要的作用其实是解决在使用多个 map、filter、reduce 操作大型数组时，可能会发生的性能问题。而通过使用 transducer 和 reducer，我们就可以优化一系列 map、filter、reduce 操作，使得输入数组只被处理一次并直接产生输出结果，而不需要创建任何中间数组
  - composeReducer 原理

- Pointfree 就是如何使用函数式编程的答案
- Pointfree：不使用所要处理的值，只合成运算过程
- Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算
- 简单说，Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。



- 范畴论
  - 范畴论对于函数式编程最关键的影响，就在于“复合”，或者说在于“函数的组合”
    - 复合运算与结合律
  - 容器/盒子，范畴论在函数式编程中的一种表达
    - 链式组合解法
- Functor
  - Maybe
  - 顺序操作步骤
  - 函子是某种容器，它允许我们应用于 其内容，生成相同类型的新容器
- Monad 单子
  - Monad 是一个同时实现了 map 方法和 flatMap 方法的盒子
  - flatMap 解决嵌套盒子问题