---
discussionID: Q3L8icEcts8j8G7XRZfZc
---
- 软件开发几大思想原则
  - 最小原则
  - 单向原则

·

  - 面向对象分析 OOA
  - 面向对象设计 OOD
    - UML 是 Unified Modeling Language（统一建模语言）的缩写
      - 类图表示 OOP 程序的结构
      - 使用时序图和通信图表示动作
    - 业务建模
      - 用例图
        - 确定角色与系统功能
      - 活动图
        - 业务活动流程
      - 状态机图
        - 表示外部动作事件导致状态变迁
  
 
- 如何判断该用组合还是继承？


- watch vs. watchEffect
  - https://cn.vuejs.org/guide/essentials/watchers.html#watch-vs-watcheffect
- watch：state sync pre effect post

- 组合+接口+委托



- 继承 多台
- 组合 接口






- 基于充血模型的 DDD 开发模式
  - 领域驱动设计，即 DDD，主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。领域驱动设计这个概念并不新颖，
- 软件设计
  - 架构
    - 模型，职责分明、最小原则
    - 通信流程方向
  - 模式
    - 分层架构，自上而下单向依赖关系架构
  - 优化
    - 数量
    - 拆分
    - 缓存
    - 并发
- 需求分析
  - 方案 -> 提出问题 -> 优化 -> 迭代
  - 使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进
  - 方案
    - 模型设计
      - 流程图
- 面向对象设计
  - 划分职责进而识别出有哪些类
  - 封装、行为抽象
  - 定义类与类之间的交互关系
    - 对类与类之间的关系做了调整，只保留了四个关系：泛化、实现、组合、依赖，这样你掌握起来会更加容易。
  - 将类组装起来并提供执行入口






  - 对事物进行分类整理的结构和表示职责分配的结构的通用的归纳整理法
    - 集合论，对数据结构归纳
      - 根据集合论进行分类整理的现实世界的事物之间的关系
    - 职责分配，行为抽象、接口





- 软件设计
  - 软件架构
    - 运行架构
      - 运行环境
    - 软件结构
      - 构件
        - 去重复
        - 独立性
          - 高内聚，低耦合
        - 避免循环关系
          - 单向依赖


- 功能概念对照现实世界进行抽象类比理解，但计算机程序与现实世界的抽象理解是不同的，是似是而非的。
  - 归类
    - “在面向对象和现实世界中，对类的定位有很大不同。在面向对象中，类是用来创建实例的结构，实例只属于一个类。而在现实世界中，首先有具体的物（实例），然后再根据观察该物的人的立场和兴趣而采用不同的基准进行分类（类）。以笔者自己为例，在公司就是“员工”，与客户打交道时就是“技术人员”，而回到家就是“父亲”，走在街上时就是“路人” 

- 虚拟表
  - “我们创建一个方法表来汇集指向方法存储位置的指针，将对象类统一为该形式，这样就完成了准备工作”
  - “当调用方法时，编译器会通过该方法表找到目标方法进行执行。这样一来，即使方法中编写的代码不同，也可以统一调用方法”




- 数据模型
  - 表示数据库的结构
“用例图只是表示信息的输入和引用，而概念模型则能够表示现实世界中的人和物、发生的事情。这正是业务应用程序的特征。计算机的主要工作是将现实世界中的事物和事情作为信息进行记录，并搜索这些信息，而判断和交涉、商品和货款的交付等实际工作依然由人在计算机外部的现实世界中进行 ”

“在业务应用程序中，数据结构反映现实世界”

“面向对象设计：拟人化和职责分配”



- 多态特性的实现方式
  - 方法表
    - 继承加方法重写
    - 接口类
  - duck-typing 语法

闭包是指函数能够记住并访问其词法范围，即使该函数在其词法范围之外执行也是如此。



- 惰性求值
  - 无限流
  - 空指针、Optional





      - 列表
        - map
        - filter
        - reduce
    - 使用分类（模式匹配）和递归来编写循环处理



无副作用
      - 在没有副作用的情况下，可以实现**延迟求值**方式

        - Thunk：将把函数的参数看作是个数学上的计算表达式，在真正需要的时候才会计算，相当于带回调参数的函数
        - 定义无穷数据结构，抽象“**数据流**”：由于惰性求值，我们可以抽象构造一个无限长集合，无限长集合中的元素并不是预置进去的，而是在需要的时候才计算出来的。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们。

- 分层
  - 职责分明
- 将较纯的计算与不纯的副作用分离
- 把状态的变更集算出来传递给视图层，那视图层就只管更新




  - 函数式编程中的 Semigroup 盒子
  - // 定义一个类型为 Add 的 Semigroup 盒子
const Add = (value) => ({
  value,  
  // concat 接收一个类型为 Add 的 Semigroup 盒子作为入参
  concat: (box) => Add(value + box.value)
})   

// 输出一个 value=6 的 Add 盒子
Add(1).concat(Add(2)).concat(Add(3))



- 半群的应用:
  - 半群通常用于定义和处理组合性的操作，比如列表连接、字符串拼接、数值累加等。
  - 在编程中，半群常用于数据聚合、操作组合等场景
- 函子的应用:
  - 函子常用于数据类型的映射和变换，比如在函数式编程中使用 Functor 来处理可变容器（如列表、Maybe、Either）。
  - 函子是构建 Applicative 和 Monad 等更复杂结构的基础




```js

function Just(val) {
    return { map, chain };
    
    function map(fn) { return Just( fn( val ) ); }
   
    function flatMap(fn) { return fn( val ); }
}
```
- Applicative 将一个封装的函数应用到封装值上
- Monad 将一个 “接受一个普通值并回传一个被封装的值” 的函数应用到一个被封装的值上


- bind：有一个bind函数可以转换任何函数，使其接受与返回相同的类型，从而使其可组合
- unit：有一个unit函数将值包装为可组合函数接受的类型
  - lfit which converts a ‘simple’ function into a debuggable function