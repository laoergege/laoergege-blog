---
tags:
 - vue
 - vnode
---

# vue 组件渲染流程

任何前端框架，最主要的核心功能就是渲染视图。在 Vue 中，整个应用的页面都是通过组件来构成并渲染来实现的。

![picture 2](images/1281db002d7238b2948c8b50b3bb8882d7353ff9248c5f3049de3d0e3277a27d.png)  


## VNode 与 Vue 组件

Vue 的内部渲染机制中引入 Virtual DOM 去抽象描述真实的 DOM。Virtual DOM 中每一个节点叫做 VNode，VNode 本质上是用来描述 DOM 的 JavaScript 对象，通过 `type` 指定不同的类型，比如普通元素节点、组件节点等。

```html
<button class="btn" style="width:100px;height:50px">click me</button>
```

```javascript
const vnode = {

  type: 'button',

  props: { 
    'class': 'btn',
    style: {
      width: '100px',
      height: '50px'
    }
  },
  children: 'click me'
}

```

```javascript
// packages/runtime-core/src/vnode.ts
export type VNodeTypes =
  | string // element
  | VNode // slot
  | Component // 组件
  | typeof Text // 文本
  | typeof Static // 
  | typeof Comment // 注释
  | typeof Fragment // 片段
  | typeof TeleportImpl // 传送组件
  | typeof SuspenseImpl // 挂载组件

export interface VNode<
  HostNode = RendererNode,
  HostElement = RendererElement,
  ExtraProps = { [key: string]: any }
> {
  type: VNodeTypes
  props: (VNodeProps & ExtraProps) | null
  children: VNodeNormalizedChildren
	...
}
```

我们可以用 vnode 这样表示`<button>`节点。一个 VNode 节点属性最主要的是 `type`，`props`，`children`。

引入 VNode 的好处：

1. 任何常规的 GUI 都能用**类 DOM 数据结构**去描述，引入 VNode，做一层界面**抽象**，提供了**跨平台**能力。
2. 赋予 JSX 更丰富的界面表达能力

前面我们说过，可以通过 vnode 的 type 属性是指定节点类型，在 vue 中如何声明组件类型的节点?

```javascript
// 模板中引入一个组件标签
<custom-component msg="test"></custom-component>


// 组件标签 转换对于的 vnode 
const CustomComponent = {
  // 在这里定义组件对象
}

const vnode = {
  type: CustomComponent,
  props: { 
    msg: 'test'
  }
}

```

**组件类型的 vnode 在 Virtual DOM 树中是个抽象节点，Virtual DOM 到真实 DOM 的映射中是不包含抽象节点，即组件类型节点是不会被渲染在页面上，真正反映在页面的是组件的模板**。

## 组件渲染流程

> 渲染流程分初始渲染和更新渲染，以下分析主要为初始渲染，更新渲染下篇介绍。

1. 使用特定渲染器的 createApp 创建应用实例
2. 挂载应用（app.mount）
   1. 创建 vnode （createVNode）
   2. 渲染 vnode（render）
         

### 使用特定渲染器的 createApp 创建应用实例

```javascript
// 在 Vue.js 3.0 中，标准初始化一个应用的方式如下
import { createApp } from 'vue'
import App from './app'
const app = createApp(App)
app.mount('#app')

-------------------------------------------------------------

// 在 web 平台下，runtime-dom 包中可以找到 createApp 方法定义
// packages/runtime-dom/src/index.ts
const createApp = ((...args) => {
  // 1. 使用自定义渲染器，创建 app 对象
  const app = ensureRenderer().createApp(...args)

  const { mount } = app

  // 重写 mount 方法
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector)
    // 2. 调用 app.mount 核心标准方法，创建 vnode, 渲染 vnode
    mount(container)
    // ...
  }

  return app
})

```

其实 createApp = renderer + apiCreateApp

- renderer 渲染器，相当于可自定义的扩展插件
- apiCreateApp 标准化应用创建

> 技巧提升:bulb: 
> 1. 阅读代码技巧：要分清代码角色关系、流程关系
> 2. 提高代码扩展性：分开标准流程和自定义插件

#### 渲染器 renderer

vue 是跨平台支持，不同平台根据接口标准实现自定义渲染器。`renderer = createRenderer(nodeOps)`

```javascript
// packages/runtime-dom/src/index.ts
const app = ensureRenderer().createApp(...args) // 延迟创建渲染，方便 tree-shakable

// 创建自定义渲染器
function ensureRenderer() {
  return renderer || (renderer = createRenderer<Node, Element>(rendererOptions))
}

// 实现不同平台的渲染操作接口
const rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps)

```

nodeOps(packages/runtime-dom/src/nodeOps.ts)

<img src="${images}/image-20210415164529699.png" alt="image-20210415164529699" style="zoom:50%;" />

```javascript
// packages/runtime-core/src/renderer.ts

// createRenderer 是 vue 自定义渲染器的核心方法
function createRenderer(options) {
  return baseCreateRenderer(options)
}

function baseCreateRenderer(options) {
  function render(vnode, container) {
    // 组件渲染的核心逻辑
  }

  return {
    render,
    // createAppAPI 创建 createApp 
    createApp: createAppAPI(render)
  }
}

```

#### createAppAPI

createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程：**标准的跨平台渲染流程是先创建 vnode，再渲染 vnode**。

```javascript
// Vue.js 利用闭包和函数柯里化，createAppAPI 包装 render
function createAppAPI(render) {
  // createApp createApp 方法接受的两个参数：根组件的对象和 prop
  return function createApp(rootComponent, rootProps = null) {
    const app = {
      _component: rootComponent,
      _props: rootProps,
      mount(rootContainer) {
        // 创建根组件的 vnode
        const vnode = createVNode(rootComponent, rootProps)
        // 调用渲染器的 render vnode
        render(vnode, rootContainer)
        app._container = rootContainer
        return vnode.component.proxy
      }
    }
    return app
  }
}
```

这里的代码的执行逻辑都是与平台无关的，启动标准渲染流程。但我们可能需要在外部重写这个方法，来完善特定平台下的渲染逻辑。

进入应用挂载阶段后，接下来就是核心渲染流程。

### 核心渲染流程：创建 vnode 和渲染 vnode

#### 创建 vnode

```javascript
// packages/runtime-core/src/vnode.ts
function _createVNode(
  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,
  props: (Data & VNodeProps) | null = null,
  children: unknown = null,
  patchFlag: number = 0,
  dynamicProps: string[] | null = null,
  isBlockNode = false
): VNode {

  // 对 vnode 类型信息编码
  // 以便在后面的 patch 阶段，可以根据不同的类型执行相应的处理逻辑
  const shapeFlag = isString(type)
    ? ShapeFlags.ELEMENT
    : __FEATURE_SUSPENSE__ && isSuspense(type)
      ? ShapeFlags.SUSPENSE
      : isTeleport(type)
        ? ShapeFlags.TELEPORT
        : isObject(type)
          ? ShapeFlags.STATEFUL_COMPONENT
          : isFunction(type)
            ? ShapeFlags.FUNCTIONAL_COMPONENT
            : 0

  const vnode: VNode = {
    type,
    props,
    key: props && normalizeKey(props),
    ...
  }
	
  // 标准化子节点，把不同数据类型的 children 转成数组或者文本类型
  normalizeChildren(vnode, children)

  return vnode
}
```

工厂模式创建 vnode，并且对 props、children 做标准化处理、对 vnode 的 type 做编码。

#### 渲染 vnode

```javascript
const render: RootRenderFunction = (vnode, container, isSVG) => {
  if (vnode == null) {
    // 销毁组件
    if (container._vnode) {
      unmount(container._vnode, null, null, true)
    }
  } else {
    // 创建或者更新组件
    patch(container._vnode || null, vnode, container, null, null, null, isSVG)
  }
  
  // 缓存 vnode 节点，表示已经渲染
  container._vnode = vnode
}
```

patch 的功能是对比新旧节点，然后挂载 DOM 或者更新 DOM。

patch 会根据不同的组件类型派发任务给 process 处理。根 vnode 是个组件类型，故 processComponent进行处理，调用 mountComponent 方法渲染组件。

```javascript
const patch: PatchFn = (
    n1,
    n2,
    container,
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    slotScopeIds = null,
    optimized = false
  ) => {
    // 如果存在新旧节点, 且新旧节点类型不同，则销毁旧节点
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1)
      unmount(n1, parentComponent, parentSuspense, true)
      n1 = null
    }

    const { type, ref, shapeFlag } = n2
    switch (type) {
      case Text:...
      case Comment:...
      case Static:...
      case Fragment:...
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
         ...
        } else if (shapeFlag & ShapeFlags.COMPONENT) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag & ShapeFlags.TELEPORT) {
          ...
        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
         ...
        } else if (__DEV__) {
          ...
        }
    }
          

 const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {

  if (n1 == null) {
   // 挂载组件
   mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)
  }
  else {
    // 更新组件
    updateComponent(n1, n2, parentComponent, optimized)
  }
}
 

// 挂载组件
const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {

  // 创建组件实例
  const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))

  // 设置组件实例，调用组件的 setup 
  setupComponent(instance)

  // 设置并运行带副作用的渲染函数，渲染组件内容
  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)
}
```

`mountComponent` 方法渲染组件中最主要的是 `setupRenderEffect`，该函数利用响应式库的 effect 函数创建了一个副作用渲染函数 componentEffect，当组件的数据发生变化时，effect 函数包裹的内部渲染函数 componentEffect 会重新执行一遍，从而达到重新渲染组件的目的。

```javascript
const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {

  // 创建响应式的副作用渲染函数

  instance.update = effect(function componentEffect() {

    if (!instance.isMounted) {

      // 渲染组件生成子树 vnode

      const subTree = (instance.subTree = renderComponentRoot(instance))

      // 把子树 vnode 挂载到 container 中

      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG)

      // 保留渲染生成的子树根 DOM 节点
      initialVNode.el = subTree.el

      instance.isMounted = true

    }

    else {

      // 更新组件

    }

  }, prodEffectOptions)

}
```
初始渲染会调用组件的 `render` 方法生成 subTree，subTree 也是一个 vnode 对象。组件 vnode 只是个抽象节点，实际是 patch subTree 渲染到页面。

这里要注意别把 subTree 和 initialVNode 弄混了（其实在 Vue.js 3.0 中，根据命名我们已经能很好地区分它们了，而在 Vue.js 2.x 中它们分别命名为 _vnode 和 $vnode），下图把 vnode、subTree、el 引用关系标记出来。

![picture 3](images/6695ff886904a788fe1e8e6027a22e78f84e7310d28b17292c8f97b3000beda3.png)  


经过 patch 函数的递归处理，对这个子树的 vnode 类型进行判断，普通元素类型的节点才会被最终渲染到界面上。函数调用过程 patch => processElement => mountElement。

```javascript
const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {

  let el

  const { type, props, shapeFlag } = vnode

  // 创建 DOM 元素节点

  el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is)

  if (props) {

    // 处理 props，比如 class、style、event 等属性

    for (const key in props) {

      if (!isReservedProp(key)) {

        hostPatchProp(el, key, null, props[key], isSVG)

      }

    }

  }

  if (shapeFlag & 8 /* TEXT_CHILDREN */) {

    // 处理子节点是纯文本的情况

    hostSetElementText(el, vnode.children)

  }

  else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {

    // 处理子节点是数组的情况

    mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren)

  }

  // 把创建的 DOM 元素节点挂载到 container 上

  hostInsert(el, container, anchor)

}

```

最后调用抽象的 host 相关方法，比如 `hostCreateElement`，在 web 平台底层就是调用 `document.createElement` 方法。

如果子节点是数组，则执行 `mountChildren` 方法， 递归 patch 挂载 child，**挂载的顺序是先子节点，后父节点，最终挂载到最外层的容器上**，完成渲染。

## 总结

1. 创建特定渲染器（createRenderer render）
2. 创建应用实例（createApp apiCreateApp）
3. 应用挂载 app.mount
   1. 创建 app vnode createVnode
render(vnode)
patch(resiu)
组件节点 processComponent 、mountComponent、setupRenderEffect、
renderComponentRoot
processElement、mountElement
hostXXX