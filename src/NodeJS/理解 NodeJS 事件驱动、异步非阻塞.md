

Node.js 应用程序运行于单个进程中，无需为每个请求创建新的线程。 Node.js 在其标准库中提供了一组异步的 I/O 原生功能（用以防止 JavaScript 代码被阻塞），并且 Node.js 中的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。




为了保证安全和协同，只有内核才能与硬件直接打交互

系统调用过程
多数操作系统的设计都遵循一个原则：进程向内核发起一个请求，然后将 CPU 执行权限让出给内核。内核接手 CPU 执行权限，然后完成请求，再转让出 CPU 执行权限给调用进程

按照权限管理的原则，多数应用程序应该运行在最小权限下。因此，很多操作系统，将内存分成了两个区域：
- 内核空间（Kernal Space），这个空间只有内核程序可以访问；
- 用户空间（User Space），这部分内存专门给应用程序使用。

用户态和内核态
用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态（User Mode） 执行。内核空间中的代码可以访问所有内存，我们称这些程序在内核态（Kernal Mode） 执行。

进程切换，时机：
1. 中断
2. 系统调用

提到 NodeJS，总会想到异步回调、非阻塞 IO，

## 如何理解区分同步/异步、阻塞/非阻塞？

可能很多人会难以区分、混淆两者概念？比如，

- 如果“同步”是发起了一个调用后， 没有得到结果之前不返回， 那它毫无疑问就是被“阻塞”了（即调用进程处于 “waiting” 状态）。
- 如果“异步”调用发出了以后就直接返回了， 毫无疑问， 这个进程没有被“阻塞”。

甚至可能会将两者意思等价起来。但回归本质来讲两者是不同的概念:

> 同步/异步关注的是事物之间的协作关系，是一种行为模式；阻塞/非阻塞描述的是事物的状态

一个事物的发生必须等待另一事物的结束，这就是同步，反之亦是异步，说明事物之间没有顺序关系，是独立发生的。

阻塞/非阻塞描述的是事物的状态，在计算机世界，事物即为线程。阻塞状态时就是只能等待，其他事都做不了。

**区分两者只要明白两者关注点不同，一个是双方行为关系，一个是单方状态**。

接下来，通过一个系统 I/O 调用过程分层来将同步/异步、阻塞/非阻塞串联起来理解，因为要让一个进程进入阻塞的状态, 要么是它主动调用 `wait()` 或 `sleep()` 等挂起自己的操作，另一种就是它调用 System Call, 而 System Call 因为一般会涉及到了 I/O 操作，不能立即完成，于是内核就会先将该进程置为阻塞状态，调度其他进程的运行，等到它所请求的 I/O 操作完成了以后，再将其状态更改回就绪状态。

一个 系统 I/O 调用过程需要经历：
1. 从 A 的业务代码到A的软件框架
2. 从 A 的软件框架到计算机的操作系统内核
   > 同步IO 跟异步IO 
3. 从 A 所在计算机的内核到 I/O 设备
4. 从 I/O 设备到A所在计算机的内核
5. 从 A 所在计算机的内核到 A 的程序的用户空间
6. 从 A 的软件框架到 A的业务代码

为什么会两者混淆，大家经常争论是因为同步异步阻塞非阻塞根本就说的不在一个点上。有些人看了经典的书是关于系统的，但有些人看得是框架，自然争论起来了。

编程层次



异步编程
- 异步调用
- 协程



3和5，内核与 IO 设备一般通过缓冲区，使用DMI来传输数据，所以这一步又是异步的。

讨论究竟是异步还是同步，一定要严格说明说的是哪一部分。其他答主说非阻塞是同步而不是异步，这毫无疑问是正确的，然而说某个框架是异步IO的框架，这也是正确的，因为说的其实是框架提供给业务代码的接口是异步的，不管是回调还是协程，比如说我们可以说某个库是异步的HTTPClient，并没有什么问题，因为说的是给业务代码的接口。由于通常异步的框架都需要在2中使用非阻塞的接口，的确会有很多人把非阻塞和异步混为一谈。
