## 递归

- 从计算机角度来看：**递归本质是循环**，通过函数体，自己调自己来进行的循环。由于是循环，也需要临界点，去结束循环。

- 从问题思考角度来看：递归求解问题是一种自顶向下的分解问题过程，去的过程叫“递”，回来的过程叫“归”

  一个递归问题需要满足下边三种条件：

  1. 大问题可以分解成小问题解决
  2. 大问题与小问题的区别除了**数据规模是不同**，求解思路是一样
  3. 存在递归终止条件

### 如何编写递归代码？

分解问题，找**重复子问题**、大问题和小问题形成**递推公式**、找出**终止条件**。

递归逻辑不同于循环，循环是一种“直白”的思考过程方式，递归比较逻辑抽象，这也正是写出递归代码比较难的一点，但递归代码有比循环代码更容易理解和简洁。

题目： [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

看到这题的时候，一开始我也是人脑枚举多种情况，寻找最优解，但人脑枚举想象是有限制的，穷举，这就容易陷入误区，头脑空白，从而不知如何求解。

对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。

这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区

1. 数学归纳，向前递推

2. 



### 递归模板

```javascript
function recursion(level) {
  // 终止条件
  // 逻辑处理
  // 递归调用
  // 结果返回（可选）
}
```



递归，自顶向下

数学归纳法，自底向上？动态规划？









- 递归代码要警惕堆栈溢出

- 递归代码要警惕重复计算

  可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

- 递归代码转非递归代码

  模拟栈调用



```

int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```



### 分治

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

原问题分解成的**子问题可以独立求解，子问题之间没有相关性**。

![image-20210610215850817](${images}/image-20210610215850817.png)

### 回溯

### 动态规划

所有动态规划问题都能通过暴力方法解决