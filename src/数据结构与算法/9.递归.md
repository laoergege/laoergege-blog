---
tags:
 - 递归
---

> 参考阅读
> - [递归：如何用三行代码找到“最终推荐人”？](https://time.geekbang.org/column/article/41440)

## 递归
### 什么是递归

从计算机角度来看：**递归本质是循环**，通过函数体，自己调自己来进行的循环。由于是循环，也需要临界点，去结束循环。

从问题思考角度来看：递归求解问题是一种自顶向下的分解成相似问题过程，去的过程叫“递”，回来的过程叫“归”

一个可以使用递归解决的问题需要满足下边三种条件：

1. 大问题可以分解成相似的小问题解决
2. 大问题与小问题的区别除了**数据规模是不同**，求解思路是一样
3. 存在递归终止条件
### 如何编写、理解递归代码？

结合上面不同的角度，总得来说关键是以下三点：

1. 抵制人肉递归、人肉枚举
2. 找最近重复性问题
3. 数学归纳法、递推公式

我们应该避免这样思维误区：
1. 不要总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。你只需要思考大问题跟小问题之间的关系，屏蔽掉递归细节，这样子理解起来就简单多了。
2. 计算机擅长做重复的事情，递归本身也是循环重复。遇到问题时，切勿去人脑枚举多种情况，寻找最优解，人脑枚举想象是有限制的，一旦陷入穷举，就容易头脑空白，从而不知如何求解。

> 这两种都是常见的要避免的计算机思维，切记不要去人脑重复性操作

**递归是一种编程技巧，使用递归解题时，首先找问题的重复性，找到了问题的最近重复性，才能把相似操作写在一起作为递归使用**，

题目：[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

生成 n 对有效括号，即为 2*n 个占位需要写入左括号或者右括号（这就是一个重复操作问题）

```javascript
var generateParenthesis = function(n) {
    const res = []
    dfs(str = '', n, n, res)
    return res
};

// 生成左括号或者右括号
var dfs = function (str, left, right, res) {
    // 左边括号数等于右边括号数
    if (left === 0 && right === 0) {
        res.push(str)
        return
    }
    // 生成左括号或者右括号
    if (left !== 0) {
        dfs(str + '(', left - 1, right, res)
    }

    // 生成右括号
    // 右括号大于左括号
    if (right !== 0 && right > left) {
        dfs(str + ')', left, right - 1, res)
    }
}
```

满足递归条件的问题就可以使用递归写法，但写递归代码最关键的是**找到如何将大问题分解为小问题的规律，写出递推公式，找到终止条件**。

**递归逻辑不同于循环，循环是一种“直白”的思考过程方式，递归逻辑是比较抽象，依赖问题的分解关系、递推关系，这也正是写出递归代码比较难的一点，但递归代码有比循环代码更容易理解和简洁。**




题目： [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)



### 递归模板

```javascript
function recursion(level) {
  // 终止条件
  // 逻辑处理
  // 递归调用
  // 结果返回（可选）
}
```
### 递归代码要警惕堆栈溢出

### 递归代码要警惕重复计算

![picture 2](images/4b8832b280706247de2fe1086c3fc77c6a49ad393eb94e9607d7bd56a36a3645.png)  

像求斐波拉契存在很多重复计算过程，可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，就不需要重复计算。

按照上面的思路，优化下“爬楼梯”的代码：

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {

    if(n === 1) {
        return 1
    }
    if(n === 2) {
        return 2
    }
  	// 缓存计算
    if(!climbStairs.tmp) {
        climbStairs.tmp = {}
    }

    return climbStairs.tmp[n] || (climbStairs.tmp[n] = climbStairs(n-1) + climbStairs(n-2))
};
```

### 递归代码转非递归代码

1. 模拟栈调用
2. 数学归纳、递推

## 分治

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

原问题分解成的**子问题可以独立求解，子问题之间没有相关性**。

![image-20210610215850817](${images}/image-20210610215850817.png)

## 回溯