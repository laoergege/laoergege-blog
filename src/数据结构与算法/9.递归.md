---
tags:
 - 递归
 - 分治
 - 回溯
---
# 递归、分治、回溯
## 递归

- 递归
  - 递归思路
  - 注意 堆栈溢出、重复计算
  - 递归模板
### 什么是递归

从计算机角度来看：**递归本质是循环**，通过函数体，自己调自己来进行的循环。

从问题思考角度来看：递归是**一种自顶向下分阶段分解成问题的求解模型**，去的过程叫“递”，回来的过程叫“归”，而且分解的问题是具有重复性。
### 如何使用递归编写代码？

1. 抵制人肉递归、人肉枚举
   > 相比较
   > 1. 不要总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。你只需要思考大问题跟小问题之间的关系，屏蔽掉递归细节，这样子理解起来就简单多了。
   > 2. 计算机擅长做重复的事情，递归本身也是循环重复。遇到问题时，切勿去人脑枚举多种情况，寻找最优解，人脑枚举想象是有限制的，一旦陷入穷举，就容易头脑空白，从而不知如何求解。
2. 分解 n 阶段问题求解、找最近重复性问题
   > 递归是一种编程技巧，使用递归解题时，首先找问题的重复性，找到了问题的最近重复性，才能把相似操作写在一起作为递归使用
3. 数学归纳法、递推公式
   > 递归是自顶向下的求解问题，从未知到已知。  
   > 递推是从初值出发反复进行某一运算得到所需结果，从已知到未知。
   >
   > 递归是数学归纳法衍生出来的，利用递推的原理。当你无法通过自顶向下求解，可通过归纳法，寻找递推公式。  
   >[《递归和数学归纳法》](https://www.cnblogs.com/GODYCA/archive/2013/01/15/2861545.html)

题目：[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

生成 n 对有效括号（阶段），即为 2*n 个占位需要写入左括号或者右括号（这就是一个重复操作问题）

```javascript
var generateParenthesis = function(n) {
    const res = []
    dfs(str = '', n, n, res)
    return res
};

// 生成左括号或者右括号
var dfs = function (str, left, right, res) {
    // 左边括号数等于右边括号数
    if (left === 0 && right === 0) {
        res.push(str)
        return
    }
    // 生成左括号或者右括号
    if (left !== 0) {
        dfs(str + '(', left - 1, right, res)
    }

    // 生成右括号
    // 右括号大于左括号
    if (right !== 0 && right > left) {
        dfs(str + ')', left, right - 1, res)
    }
}
```

题目： [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

1 阶：1  
2 阶：2  
3 阶：2 阶 + 1 阶  
4 阶：3 阶 + 2 阶  
...

递推公式：f(n) = f(n - 1) + f( n - 2)

```javascript
var climbStairs = function(n) {
    if(n === 1) {
        return 1
    }
    if(n === 2) {
        return 2
    }
  	// 缓存计算
    if(!climbStairs.tmp) {
        climbStairs.tmp = {}
    }

    return climbStairs.tmp[n] || (climbStairs.tmp[n] = climbStairs(n-1) + climbStairs(n-2))
};
```
### 递归模板

```js
function recursion(level) {
  // 终止条件
  // 递归缓存返回（可选）
  // 逻辑处理
  // 递归调用
  // 结果返回（可选）
}
```
#### 深度优先

一般用深度优先遍历：
- 代码好写，使用递归的方法，直接借助系统栈完成**状态的转移**；
- 广度优先遍历得自己编写结点类和借助队列。

```python
#Python

# 缓存计算，防止重复计算
visited = set() 

def dfs(node, visited):    
    if node in visited: # terminator    	
        # already visited     	
        return 	visited.add(node) 	
        
    # process current node here. 	
    ...	
     
    for next_node in node.children(): 		
        if next_node not in visited: 			
            dfs(next_node, visited)
```

非递归写法，模拟栈调用

```python
#Pythondef DFS(self, tree): 	
    if tree.root is None: 		
        return [] 	

    visited, stack = [], [tree.root]	

    while stack: 		
        node = stack.pop() 		
        visited.add(node)		

        process (node) 		
        nodes = generate_related_nodes(node) 		
        stack.push(nodes) 	
    
    # other processing work 	
    ...
```
#### 广度优先

```python
# Python

def BFS(graph, start, end):
    # 队列    
    queue = [] 	
    queue.append([start]) 	
    
    while queue: 		
        node = queue.pop() 		
        process(node) 		
        
        # 将 children 排进下一队列中
        nodes = generate_related_nodes(node) 		
        queue.push(nodes)	
        
        # other processing work 	...
```
## 分治

分治算法，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

原问题分解成的**子问题可以独立求解，子问题之间没有相关性**。

> 分治相比递归，就是多了不断重复分治合并的处理

通过不断缩小问题的数据规模而降低问题难度，从而能够从最小问题快速解决起，逐渐，
## 回溯

回溯算法，暴力穷举算法。

状态复制转移

根据重复性怎么构造怎么分解，就分为分治、回溯等各种方法

动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 最优子结构，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。

关于重复性：
1. 最近重复性：涉及到各种办法
2. 最有重复性：即为动态规划

能够顺应思维就用迭代
不能，就更抽象，用递归之类

1. 找重复性
2. 分n阶段
   1. 回溯
   2. 最优解 动态规划
3. 分治问题、缩小数据规模、缩小问题
4. 归纳法、递推

组合、排列、子集 回溯

## 贪心算法

贪心算法，在**每一步**都做出一个**局部最优**的选择，**从而希望最终的结果就是全局最优**。

> 局部最优、希望结果最优，说明贪心算法在日常生活和工程中一般不能得到我们想要的结果

- 回溯，能够回退
- 贪心算法，当下做局部最优判断，不能回退
- 动态规划，根据以前结果做选择 + 回退

问题能够分解成子问题，子问题的最优解能够递推到到最终问题的最优解，这种子问题最优解称为最优子结构



## 分治算法

分治（英语：Divide and Conquer），字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

> 这和递归的概念很吻合，所以在分治算法通常以递归的方式实现(当然也有非递归的实现方式)。

![图 4](./images/04ca52444b3140b2446123205332f75f65eef11772d08e97ec19c54da7c3ab22.png)  


:thinking:

## 动态规划

动态规划 => 动态递推

动态规划问题的一般形式就是求最值（最优解、最大值或者最小值等）

动态规划 = 分治 + 最优子结构

所谓最优子结构：推导出的第n步的值，是前面几个值的最佳值的简单累加，或者最大值，或者最小值。



技巧：

暴力求解

1. 抵制人肉枚举、人肉递归
2. 找最近重复性（本质找重复性 -> 计算机简单指令集：分支、循环）
3. 数学归纳法（找递推公式，又称 状态转移方程、DP 方程）
   1. 自顶向下（递归 + 记忆化搜索）
   2. 自底向上 循环
      1. 最优子结构
      2. 中间状态
      3. 递推公式

形成机器思维（就是只会 if else for loop recursive）
面对理解复杂逻辑也就是找重复性