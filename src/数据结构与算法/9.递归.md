---
tags:
 - 递归
 - 分治
 - 回溯
---
# 递归、分治、回溯
## 递归

- 递归
  - 递归思路
  - 注意 堆栈溢出、重复计算
  - 递归模板
### 什么是递归

从计算机角度来看：**递归本质是循环**，通过函数体，自己调自己来进行的循环。

从问题思考角度来看：递归是**一种自顶向下分阶段分解成问题的求解模型**，去的过程叫“递”，回来的过程叫“归”，而且分解的问题是具有重复性。
### 如何使用递归编写代码？

1. 抵制人肉递归、人肉枚举
   > 相比较
   > 1. 不要总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。你只需要思考大问题跟小问题之间的关系，屏蔽掉递归细节，这样子理解起来就简单多了。
   > 2. 计算机擅长做重复的事情，递归本身也是循环重复。遇到问题时，切勿去人脑枚举多种情况，寻找最优解，人脑枚举想象是有限制的，一旦陷入穷举，就容易头脑空白，从而不知如何求解。
2. 分解 n 阶段问题求解、找最近重复性问题
   > 递归是一种编程技巧，使用递归解题时，首先找问题的重复性，找到了问题的最近重复性，才能把相似操作写在一起作为递归使用
3. 数学归纳法、递推公式
   > 递归是自顶向下的求解问题，从未知到已知。  
   > 递推是从初值出发反复进行某一运算得到所需结果，从已知到未知。
   >
   > 递归是数学归纳法衍生出来的，利用递推的原理。当你无法通过自顶向下求解，可通过归纳法，寻找递推公式。  
   >[《递归和数学归纳法》](https://www.cnblogs.com/GODYCA/archive/2013/01/15/2861545.html)

题目：[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

生成 n 对有效括号（阶段），即为 2*n 个占位需要写入左括号或者右括号（这就是一个重复操作问题）

```javascript
var generateParenthesis = function(n) {
    const res = []
    dfs(str = '', n, n, res)
    return res
};

// 生成左括号或者右括号
var dfs = function (str, left, right, res) {
    // 左边括号数等于右边括号数
    if (left === 0 && right === 0) {
        res.push(str)
        return
    }
    // 生成左括号或者右括号
    if (left !== 0) {
        dfs(str + '(', left - 1, right, res)
    }

    // 生成右括号
    // 右括号大于左括号
    if (right !== 0 && right > left) {
        dfs(str + ')', left, right - 1, res)
    }
}
```

题目： [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

1 阶：1  
2 阶：2  
3 阶：2 阶 + 1 阶  
4 阶：3 阶 + 2 阶  
...

递推公式：f(n) = f(n - 1) + f( n - 2)

```javascript
var climbStairs = function(n) {
    if(n === 1) {
        return 1
    }
    if(n === 2) {
        return 2
    }
  	// 缓存计算
    if(!climbStairs.tmp) {
        climbStairs.tmp = {}
    }

    return climbStairs.tmp[n] || (climbStairs.tmp[n] = climbStairs(n-1) + climbStairs(n-2))
};
```
### 递归模板

```js
function recursion(level) {
  // 终止条件
  // 递归缓存返回（可选）
  // 逻辑处理
  // 递归调用
  // 结果返回（可选）
}
```
#### 深度优先

一般用深度优先遍历：
- 代码好写，使用递归的方法，直接借助系统栈完成**状态的转移**；
- 广度优先遍历得自己编写结点类和借助队列。

```python
#Python

# 缓存计算，防止重复计算
visited = set() 

def dfs(node, visited):    
    if node in visited: # terminator    	
        # already visited     	
        return 	visited.add(node) 	
        
    # process current node here. 	
    ...	
     
    for next_node in node.children(): 		
        if next_node not in visited: 			
            dfs(next_node, visited)
```

非递归写法，模拟栈调用

```python
#Pythondef DFS(self, tree): 	
    if tree.root is None: 		
        return [] 	

    visited, stack = [], [tree.root]	

    while stack: 		
        node = stack.pop() 		
        visited.add(node)		

        process (node) 		
        nodes = generate_related_nodes(node) 		
        stack.push(nodes) 	
    
    # other processing work 	
    ...
```
#### 广度优先

```python
# Python

def BFS(graph, start, end):
    # 队列    
    queue = [] 	
    queue.append([start]) 	
    
    while queue: 		
        node = queue.pop() 		
        process(node) 		
        
        # 将 children 排进下一队列中
        nodes = generate_related_nodes(node) 		
        queue.push(nodes)	
        
        # other processing work 	...
```
## 分治

分治算法，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

原问题分解成的**子问题可以独立求解，子问题之间没有相关性**。

> 分治相比递归，就是多了不断重复分治合并的处理

通过不断缩小问题的数据规模而降低问题难度，从而能够从最小问题快速解决起，逐渐，
## 回溯

回溯算法，暴力穷举算法。

状态复制转移

根据重复性怎么构造怎么分解，就分为分治、回溯等各种方法

动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 最优子结构，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。

关于重复性：
1. 最近重复性：涉及到各种办法
2. 最有重复性：即为动态规划

能够顺应思维就用迭代
不能，就更抽象，用递归之类

1. 找重复性
2. 分n阶段
   1. 回溯
   2. 最优解 动态规划
3. 分治问题、缩小数据规模、缩小问题
4. 归纳法、递推

组合、排列、子集 回溯

## 贪心算法

贪心算法，在**每一步**都做出一个**局部最优**的选择，**从而希望最终的结果就是全局最优**。

> 局部最优、希望结果最优，说明贪心算法在日常生活和工程中一般不能得到我们想要的结果

- 回溯，能够回退
- 贪心算法，当下做局部最优判断，不能回退
- 动态规划，根据以前结果做选择 + 回退

问题能够分解成子问题，子问题的最优解能够递推到到最终问题的最优解，这种子问题最优解称为最优子结构

## 动态规划

递归是一种自顶向下分解问题的过程

动态规划 => 动态递推

动态规划问题的一般形式就是求最值（最优解、最大值或者最小值等）
计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

求解动态规划的核心问题是穷举。虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」，才能正确地穷举。

动态规划 = 递归、分治 + 最优子结构

- 最优子结构
- 储存中间状态
- 递推公式（状态转移方程、DP 方程）

动态规划问题最困难的就是写出这个暴力解，即状态转移方程。

傻递归
递归 + 缓存
递推

递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。