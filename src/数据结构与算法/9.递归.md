---
tags:
 - 递归
 - 分治
 - 回溯
---
# 递归、分治、回溯

- 递归
  - 递归思路
  - 递归模板
  - 堆栈溢出、重复计算
  - 转非递归代码
## 递归
### 什么是递归

从计算机角度来看：**递归本质是循环**，通过函数体，自己调自己来进行的循环。由于是循环，也需要临界点，去结束循环。

从问题思考角度来看：递归求解问题是一种自顶向下的分阶段分解成问题过程，去的过程叫“递”，回来的过程叫“归”，而且分解的问题是具有重复性。
### 如何编写递归代码？

结合上面不同的角度，总得来说关键是以下三点：

1. 抵制人肉递归、人肉枚举
   > 1. 不要总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。你只需要思考大问题跟小问题之间的关系，屏蔽掉递归细节，这样子理解起来就简单多了。
   > 2. 计算机擅长做重复的事情，递归本身也是循环重复。遇到问题时，切勿去人脑枚举多种情况，寻找最优解，人脑枚举想象是有限制的，一旦陷入穷举，就容易头脑空白，从而不知如何求解。
2. 分解 n 阶段问题求解、找最近重复性问题
   > 递归是一种编程技巧，使用递归解题时，首先找问题的重复性，找到了问题的最近重复性，才能把相似操作写在一起作为递归使用
3. 数学归纳法、递推公式
   > 递归是自顶向下的求解问题，从未知到已知。  
   > 递推是从初值出发反复进行某一运算得到所需结果，从已知到未知。
   >
   > 递归是数学归纳法衍生出来的，利用递推的原理。当你无法通过自顶向下求解，可通过归纳法，寻找递推公式。  
   >[《递归和数学归纳法》](https://www.cnblogs.com/GODYCA/archive/2013/01/15/2861545.html)

题目：[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

生成 n 对有效括号（阶段），即为 2*n 个占位需要写入左括号或者右括号（这就是一个重复操作问题）

```javascript
var generateParenthesis = function(n) {
    const res = []
    dfs(str = '', n, n, res)
    return res
};

// 生成左括号或者右括号
var dfs = function (str, left, right, res) {
    // 左边括号数等于右边括号数
    if (left === 0 && right === 0) {
        res.push(str)
        return
    }
    // 生成左括号或者右括号
    if (left !== 0) {
        dfs(str + '(', left - 1, right, res)
    }

    // 生成右括号
    // 右括号大于左括号
    if (right !== 0 && right > left) {
        dfs(str + ')', left, right - 1, res)
    }
}
```

题目： [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

1 阶：1  
2 阶：2  
3 阶：2 阶 + 1 阶  
4 阶：3 阶 + 2 阶  
...

递推公式：f(n) = f(n - 1) + f( n - 2)

```javascript
var climbStairs = function(n) {
    if(n === 1) {
        return 1
    }
    if(n === 2) {
        return 2
    }
  	// 缓存计算
    if(!climbStairs.tmp) {
        climbStairs.tmp = {}
    }

    return climbStairs.tmp[n] || (climbStairs.tmp[n] = climbStairs(n-1) + climbStairs(n-2))
};
```
### 递归模板

```javascript
function recursion(level) {
  // 终止条件
  // 逻辑处理
  // 递归调用
  // 结果返回（可选）
}
```
### 递归代码要警惕堆栈溢出

### 递归代码要警惕重复计算

![picture 2](images/4b8832b280706247de2fe1086c3fc77c6a49ad393eb94e9607d7bd56a36a3645.png)  

像求斐波拉契存在很多重复计算过程，**可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)**。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，就不需要重复计算。

按照上面的思路，优化下“爬楼梯”的代码：

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {

    if(n === 1) {
        return 1
    }
    if(n === 2) {
        return 2
    }
  	// 缓存计算
    if(!climbStairs.tmp) {
        climbStairs.tmp = {}
    }

    return climbStairs.tmp[n] || (climbStairs.tmp[n] = climbStairs(n-1) + climbStairs(n-2))
};
```

### 递归代码转非递归代码

1. 模拟栈调用
2. 数学归纳、递推

## 分治

分治算法，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

原问题分解成的**子问题可以独立求解，子问题之间没有相关性**。

> 分治相比递归，就是多了不断重复分治合并的处理

通过不断缩小问题的数据规模而降低问题难度，从而能够从最小问题快速解决起，逐渐，
## 回溯

回溯算法，暴力穷举算法。

状态复制转移

根据重复性怎么构造怎么分解，就分为分治、回溯等各种方法

动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 最优子结构，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。

关于重复性：
1. 最近重复性：涉及到各种办法
2. 最有重复性：即为动态规划

能够顺应思维就用迭代
不能，就更抽象，用递归之类

1. 找重复性
2. 分n阶段
   1. 回溯
   2. 最优解 动态规划
3. 分治问题、缩小数据规模、缩小问题
4. 归纳法、递推

组合、排列、子集 回溯