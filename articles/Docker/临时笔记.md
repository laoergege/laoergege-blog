Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。

## 核心概念
容器 === 镜像

## 操作命令

### 下载镜像
- docker search 查找镜像
- docker pull 获取镜像

### 查看镜像
- docker images 查看镜像
- docker images -a 为了加速镜像构建、重复利用资源，Docker 会利用中间层镜像，-a 显示包括中间层镜像在内的所有镜像的话
- docker inspect 查看容器/镜像详细信息
- docker history 镜像文件由多个层组成，查看镜像各层创建信息

> `docker images` 查看镜像大小信息只是表示了该镜像的逻辑体积大小， 实际上由于相同的镜像层本地只会存储一份， 物理上占用的存储空间会小于各镜像逻辑体积之和。

![](https://raw.githubusercontent.com/laoergege/laoergege-blog/master/images/20190918232256.png)

### 删除、清理镜像
- docker rmi IMAGE [IMAGE ... ] 删除镜像 -f 强删
- docker image prune 清理些临时的镜像文件， 以及一些没有被使用的镜像

> - 删除可以 tag 或者镜像 ID
> - 镜像删除行为分为两类，一类是 `Untagged`，另一类是 `Deleted`
> - 一个镜像可以对应多个标签，当该镜像所有的标签都被取消了，才会是 `Deleted` 行为
> - 镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。如果某个其它镜像正依赖于当前镜像的某一层，是不会触发删除该层的行为
> - 容器依赖的镜像也不会被删除

### 创建镜像
- docker commit 创建镜像

```
docker commit [选项] <容器ID或容器名> [<仓库名>[:<标签>]]
```

- docker create 创建容器
- docker start 启动容器
- docker ps 查看容器进程
- docker exec
- docker run 创建并启动容器

- docker login
- docker push

### 容器的三种运行模式
概括而言，Docker容器大体上有三种运行模式，如下：

#### 运行后退出
```
// 下面语句创建的容器，在运行后会退出。
$ docker run centos echo "hellowrold"
```

#### 常驻内存，就是守护进程的模式
```
// 如果容器中运行一个守护进程，则容器会一直处于运行状态，如：
$ docker run -d -p 80:80 nginx
```

#### 交互式
```
// 我们也可以在运行容器时，直接与容器交互。 
// --rm 容器退出后随之将其删除
$ docker run -it --rm centos /bin/bash
```

-f, --fiter filter: 过滤输出内容；
--format string: 格式化输出内容；

## dockerfile

### 构建缓存

[官方文档](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache)

Docker 镜像构建是分层的，一条指令一层，在没有带 `--no-cache=true` 指令的情况下如果某一层没有改动，Docker 就不会重新构建这一层而是会使用缓存。简单来说就是如果第n层有改动，则n层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致，但是对于 `COPY` 和 `ADD` 命令会计算镜像内的文件和构建目录文件的校验和然后做比较来判断本层是否有改动。

实践应用 [利用构建缓存机制缩短Docker镜像构建时间](https://segmentfault.com/a/1190000018222648)