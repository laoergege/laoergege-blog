Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。

## 核心概念
容器 === 镜像

## 操作命令
- docker search 查找镜像
- docker pull 或者 git pull xxx:version 获取镜像
- docker images 查看镜像
- docker rmi 删除镜像
- docker inspect 查看容器/镜像信息
- docker create 创建容器
- docker start 启动容器
- docker ps 查看容器进程
- docker exec
- docker run 创建并启动容器
- docker commit 创建镜像
- docker login
- docker push

### 容器的三种运行模式
概括而言，Docker容器大体上有三种运行模式，如下：

#### 运行后退出
```
// 下面语句创建的容器，在运行后会退出。
$ docker run centos echo "hellowrold"
```

#### 常驻内存，就是守护进程的模式
```
// 如果容器中运行一个守护进程，则容器会一直处于运行状态，如：
$ docker run -d -p 80:80 nginx
```

#### 交互式
```
// 我们也可以在运行容器时，直接与容器交互。 
// --rm 容器退出后随之将其删除
$ docker run -it --rm centos /bin/bash
```

## dockerfile

### 构建缓存

[官方文档](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache)

Docker 镜像构建是分层的，一条指令一层，在没有带 `--no-cache=true` 指令的情况下如果某一层没有改动，Docker 就不会重新构建这一层而是会使用缓存。简单来说就是如果第n层有改动，则n层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致，但是对于 `COPY` 和 `ADD` 命令会计算镜像内的文件和构建目录文件的校验和然后做比较来判断本层是否有改动。

实践应用 [利用构建缓存机制缩短Docker镜像构建时间](https://segmentfault.com/a/1190000018222648)