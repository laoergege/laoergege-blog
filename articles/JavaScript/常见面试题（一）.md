___

```
function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???
```
第一段会报错：Uncaught ReferenceError: a is not defined。

第二段会打印：1。

这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。

第一段执行 console 的时候， AO 的值是：
```
AO = {
    arguments: {
        length: 0
    }
}
```
没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。

当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。

___

```
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```
会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

___

下面的代码将输出什么到控制台，为什么？


```
(function(){

  var a = b = 3;

})();

 

console.log("a defined? " + (typeof a !== 'undefined'));

console.log("b defined? " + (typeof b !== 'undefined'));
```


由于 a 和 b 都定义在函数的封闭范围内，并且都始于 var关键字，大多数JavaScript开发人员期望 typeof a 和 typeof b 在上面的例子中都是undefined。



然而，事实并非如此。这里的问题是，大多数开发人员将语句 var a = b = 3; 错误地理解为是以下声明的简写：



var b = 3;

var a = b;



但事实上，var a = b = 3; 实际是以下声明的简写：



b = 3;

var a = b;



因此（如果你不使用严格模式的话），该代码段的输出是：



a defined? false

b defined? true



但是， b 如何才能被定义在封闭函数的范围之外呢？是的，既然语句 var a = b = 3; 是语句 b = 3; 和 var a = b;的简写， b 最终成为了一个全局变量（因为它没有前缀 var 关键字），因此仍然在范围内甚至封闭函数之外。



需要注意的是，在严格模式下（即使用 use strict），语句var a = b = 3; 将生成ReferenceError: b is not defined的运行时错误，从而避免任何否则可能会导致的headfakes /bug。 （还是你为什么应该理所当然地在代码中使用 use strict 的最好例子！）

___

NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaN ？



NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， "abc" / 4），要么是因为运算的结果非数字（例如，除数为零）。



虽然这看上去很简单，但 NaN 有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。



首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：


```
console.log(typeof NaN === "number");  // logs "true"
```


此外， NaN 和任何东西比较——甚至是它自己本身！——结果是false：


```
console.log(NaN === NaN);  // logs "false"
```


一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。



一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。另外，ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。

___

写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。



下面这个函数在 str 是回文结构的时候返回true，否则，返回false。


```
function isPalindrome(str) {

    str = str.replace(/W/g, '').toLowerCase();

    return (str == str.split('').reverse().join(''));

}
```


例如：


```
console.log(isPalindrome("level"));                   // logs 'true'

console.log(isPalindrome("levels"));                  // logs 'false'

console.log(isPalindrome("A car, a man, a maraca"));  // logs 'true'
```

___

获取数组中的最大值和最小值


```
var numbers = [5, 458 , 120 , -215 ];

var maxInNumbers = Math.max.apply(Math, numbers), //458

maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458

```

number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。


___

doctype是什么
告诉浏览器当前HTMl版本的指令,决定使用兼容模式还是标准模式对文档进行渲染
___

ES5的继承和ES6的继承有什么区别？
ES5的继承时通过prototype或构造函数机制来实现。ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）。
ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。
___

数组去重：
```javascript
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
let unique= arr =>{
        let newA=[];
    arr.forEach(key => {
        if( !newA.includes(key) ){ //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
            newA.push(key);
        }
    });
    return newA;
}
console.log(unique(a)) ;//["1", "2", "3", 1, NaN, NaN, undefined, null, "a", "b"]
```
```
let unique= [...new Set(array)];
//es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。
//Set内部使用===来判断是否相等，类似'1'和1会两个都保存，NaN和NaN只会保存一个
```
___

```
翻转一个字符串
let a="hello word";
let b=[...str].reverse().join("");//drow olleh
```
___
四种定位的区别

static 是默认值
relative 相对定位 相对于自身原有位置进行偏移，仍处于标准文档流中
absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。
fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。
sticky: position:relative 和 position:fixed 
___

怎么判断两个对象相等？
JSON.stringify(obj)==JSON.stringify(obj2);//true
JSON.stringify(obj)==JSON.stringify(obj3);//false
___

性能优化？
- 代码打包以及分割
- 减少DOM操作
- 减少 http 请求， 多用缓存
- 图片懒加载
___

数组中最大差值
```
let arr = [23, 4, 5, 2, 4, 5, 6, 6, 71, -3];
const difference = arr => {
    let max = Math.max(...arr),
        min = Math.min(...arr);
    return max - min ;
}
console.log(difference(arr)) // 74

```
___
输入a = 2,b = 3,输出 a = 3,b = 2
```
let a = 2,
    b = 3;
const swop = (a, b) => {
    b = b - a;
    a = a + b;
    b = a - b;
    return [a,b];
}
console.log(swop(2,3)) // [3,2]
```
___
冒泡排序算法就是依次跟其他元素比较大小，小的的大的进行位置上的交换。
```javascript
function bubbleSort(arr){
    for(let i = 0; i < arr.length; i++){
        for(let j = i+1; j < arr.length; j++){
            if(arr[i] > arr[j]){
                let tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
    }
    return arr
}
```
___
跨域

JSONP 
不支持post请求，因为script只支持get请求
原理：利用<script>标签支持跨域原理，请求地址附带回调函数名，让服务器端返回该可执行的函数，参数为要回发的数据。

CORS 
跨域资源共享 
参考[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)
Access-Control-Allow-Origin
___

闭包以及作用：
闭包主要是一个函数想要读取另外一个函数的内部变量称之为闭包。闭包主要有两个作用：一、保护内部变量不会被随意篡改。二、使内部变量不会被GC回收等展开来讲讲即可。

___