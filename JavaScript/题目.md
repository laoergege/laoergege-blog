___

```
function foo() {
    console.log(a);
    a = 1;
}

foo(); // ???

function bar() {
    a = 1;
    console.log(a);
}
bar(); // ???
```
第一段会报错：Uncaught ReferenceError: a is not defined。

第二段会打印：1。

这是因为函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。

第一段执行 console 的时候， AO 的值是：
```
AO = {
    arguments: {
        length: 0
    }
}
```
没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。

当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。

___

```
console.log(foo);

function foo(){
    console.log("foo");
}

var foo = 1;
```
会打印函数，而不是 undefined 。

这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

___

下面的代码将输出什么到控制台，为什么？


```
(function(){

  var a = b = 3;

})();

 

console.log("a defined? " + (typeof a !== 'undefined'));

console.log("b defined? " + (typeof b !== 'undefined'));
```


由于 a 和 b 都定义在函数的封闭范围内，并且都始于 var关键字，大多数JavaScript开发人员期望 typeof a 和 typeof b 在上面的例子中都是undefined。



然而，事实并非如此。这里的问题是，大多数开发人员将语句 var a = b = 3; 错误地理解为是以下声明的简写：



var b = 3;

var a = b;



但事实上，var a = b = 3; 实际是以下声明的简写：



b = 3;

var a = b;



因此（如果你不使用严格模式的话），该代码段的输出是：



a defined? false

b defined? true



但是， b 如何才能被定义在封闭函数的范围之外呢？是的，既然语句 var a = b = 3; 是语句 b = 3; 和 var a = b;的简写， b 最终成为了一个全局变量（因为它没有前缀 var 关键字），因此仍然在范围内甚至封闭函数之外。



需要注意的是，在严格模式下（即使用 use strict），语句var a = b = 3; 将生成ReferenceError: b is not defined的运行时错误，从而避免任何否则可能会导致的headfakes /bug。 （还是你为什么应该理所当然地在代码中使用 use strict 的最好例子！）

___

NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaN ？



NaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， "abc" / 4），要么是因为运算的结果非数字（例如，除数为零）。



虽然这看上去很简单，但 NaN 有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。



首先，虽然 NaN 意味着“不是数字”，但是它的类型，不管你信不信，是 Number：


```
console.log(typeof NaN === "number");  // logs "true"
```


此外， NaN 和任何东西比较——甚至是它自己本身！——结果是false：


```
console.log(NaN === NaN);  // logs "false"
```


一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数 isNaN()，但即使使用 isNaN() 依然并非是一个完美的解决方案。



一个更好的解决办法是使用 value !== value，如果值等于NaN，只会产生true。另外，ES6提供了一个新的 Number.isNaN() 函数，这是一个不同的函数，并且比老的全局 isNaN() 函数更可靠。

___

写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。



下面这个函数在 str 是回文结构的时候返回true，否则，返回false。


```
function isPalindrome(str) {

    str = str.replace(/W/g, '').toLowerCase();

    return (str == str.split('').reverse().join(''));

}
```


例如：


```
console.log(isPalindrome("level"));                   // logs 'true'

console.log(isPalindrome("levels"));                  // logs 'false'

console.log(isPalindrome("A car, a man, a maraca"));  // logs 'true'
```