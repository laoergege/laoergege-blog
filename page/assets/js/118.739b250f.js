(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{601:function(t,s,a){"use strict";a.r(s);var e=a(47),_=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),a("p",[t._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")]),t._v(" "),a("p",[t._v("数组特点："),a("strong",[t._v("连续的内存空间和相同类型的数据")]),t._v("。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“"),a("strong",[t._v("随机访问")]),t._v("”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。")]),t._v(" "),a("p",[t._v("从数组的内存模型来看，数组下标的本质是内存地址的"),a("strong",[t._v("偏移")])]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("a[k]_address = base_address + k * type_size\n")])])]),a("p",[t._v("计算机"),a("strong",[t._v("随机访问")]),t._v("数组元素只需要在寻址前，计算一下目标地址，而不需要记录内存地址。")]),t._v(" "),a("p",[t._v("为什么数组的下标是从 0 开始？")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("a[k]_address = base_address + (k - 1) * type_size\n")])])]),a("p",[t._v("如果是从 0 开始，寻址计算要多做一次减法指令。更主要原因是历史原因，一开始语言用 0 开始计算数组，后续的语言都效仿，或者一定程度减少学习成本。")]),t._v(" "),a("h3",{attrs:{id:"增删查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#增删查"}},[t._v("#")]),t._v(" 增删查")]),t._v(" "),a("p",[t._v("增删：考虑头尾中间，复杂度 O(n)")]),t._v(" "),a("p",[t._v("查：查都是 O(n)，下标随机访问 O(1)")]),t._v(" "),a("h3",{attrs:{id:"课后题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#课后题"}},[t._v("#")]),t._v(" 课后题")]),t._v(" "),a("ul",[a("li",[t._v("js数组实现不同数据类型？")]),t._v(" "),a("li",[t._v("js数组实现动态扩容？")]),t._v(" "),a("li",[t._v("数组越界处理？")]),t._v(" "),a("li",[t._v("前面我基于数组的原理引出 JVM 的标记清除垃圾回收算法的核心理念。我不知道你是否使用 Java 语言，理解 JVM，如果你熟悉，可以在评论区回顾下你理解的标记清除垃圾回收算法。")])]),t._v(" "),a("hr"),t._v(" "),a("Vssue",{attrs:{title:t.$title}})],1)}),[],!1,null,null,null);s.default=_.exports}}]);