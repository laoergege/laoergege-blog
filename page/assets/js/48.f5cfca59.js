(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{519:function(t,r,n){"use strict";n.r(r);var o=n(47),e=Object(o.a)({},(function(){var t=this,r=t.$createElement,n=t._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("微前端架构设计")]),t._v(" "),n("ul",[n("li",[t._v("各个子应用间的调度实现以及其运行态的维护\n"),n("ul",[n("li",[t._v("CSS  隔离中常见的命名空间前缀、Shadow DOM、 "),n("a",{attrs:{href:"https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/css.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("乾坤 sandbox css"),n("OutboundLink")],1),t._v(" 的运行时动态增删等")]),t._v(" "),n("li",[t._v("JavaScript 的沙箱隔离")])])])]),t._v(" "),n("p",[t._v("在微前端架构中，JavaScript 沙箱隔离需要解决如下几个问题：")]),t._v(" "),n("ol",[n("li",[t._v("挂在 window 上的全局方法/变量（如 setTimeout、滚动等全局事件监听等）在子应用切换时的清理和还原。")]),t._v(" "),n("li",[t._v("Cookie、LocalStorage 等的读写安全策略限制。")]),t._v(" "),n("li",[t._v("各子应用独立路由的实现。")]),t._v(" "),n("li",[t._v("多个微应用共存时相互独立的实现。")])]),t._v(" "),n("p",[t._v("在 "),n("a",{attrs:{href:"https://github.com/umijs/qiankun",target:"_blank",rel:"noopener noreferrer"}},[t._v("乾坤"),n("OutboundLink")],1),t._v(" 架构设计中，关于沙箱有两个入口文件需要关注，一个是 "),n("a",{attrs:{href:"https://github.com/umijs/qiankun/blob/master/src/sandbox/proxySandbox.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("proxySandbox.ts"),n("OutboundLink")],1),t._v("，另一个是 "),n("a",{attrs:{href:"https://github.com/umijs/qiankun/blob/master/src/sandbox/snapshotSandbox.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("snapshotSandbox.ts"),n("OutboundLink")],1),t._v("，他们分别基于 Proxy 实现代理了 window 上常用的常量和方法以及不支持 Proxy 时降级通过快照实现备份还原。结合其相关开源文章分享，简单总结下其实现思路：起初版本使用了"),n("strong",[t._v("快照沙箱")]),t._v("的概念，模拟 ES6 的 Proxy API，通过代理劫持 window ，当子应用修改或使用 window 上的属性或方法时，把对应的操作记录下来，每次子应用挂载/卸载时生成快照，当再次从外部切换到当前子应用时，再从记录的快照中恢复，而后来为了兼容多个子应用共存的情况，又基于 Proxy 实现了代理所有全局性的常量和方法接口，为每个子应用构造了独立的运行环境。")]),t._v(" "),n("hr"),t._v(" "),n("Vssue",{attrs:{title:t.$title}})],1)}),[],!1,null,null,null);r.default=e.exports}}]);