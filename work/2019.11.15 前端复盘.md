# 前端复盘主要内容
- [前端复盘主要内容](#%e5%89%8d%e7%ab%af%e5%a4%8d%e7%9b%98%e4%b8%bb%e8%a6%81%e5%86%85%e5%ae%b9)
  - [CDN](#cdn)
      - [后端回源配置](#%e5%90%8e%e7%ab%af%e5%9b%9e%e6%ba%90%e9%85%8d%e7%bd%ae)
      - [Work 脚本 同源要求](#work-%e8%84%9a%e6%9c%ac-%e5%90%8c%e6%ba%90%e8%a6%81%e6%b1%82)
        - [前端修改资源访问地址](#%e5%89%8d%e7%ab%af%e4%bf%ae%e6%94%b9%e8%b5%84%e6%ba%90%e8%ae%bf%e9%97%ae%e5%9c%b0%e5%9d%80)
  - [前端兼容](#%e5%89%8d%e7%ab%af%e5%85%bc%e5%ae%b9)
  - [http 请求限制](#http-%e8%af%b7%e6%b1%82%e9%99%90%e5%88%b6)
    - [重复请求限制](#%e9%87%8d%e5%a4%8d%e8%af%b7%e6%b1%82%e9%99%90%e5%88%b6)
    - [无效请求限制](#%e6%97%a0%e6%95%88%e8%af%b7%e6%b1%82%e9%99%90%e5%88%b6)
    - [实现方案](#%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%a1%88)
## CDN

#### 后端回源配置
后台只需配置回源地址，前端代码依旧构建放到 Nignx 上。CDN 首次找不到资源会访问 Nignx 资源，并作缓存 CDN 上，这样就不用自己上传代码到 CDN 服务器。

![](https://github.com/laoergege/laoergege-blog/blob/master/images/123.PNG?raw=true)

#### Work 脚本 同源要求
1. Work 脚本用源域名，不用 CDN 域名
2. inline 方式，及与原脚本合并一起，构建时不生成单独 work 脚本

##### 前端修改资源访问地址
前端只需在构建 prd 环境时，修改 webpack `publicPath` 配置即可。

## 前端兼容
  - Babel 代码降级
  - Browserslist 定义适配范围，再配合工具链增强开发![](https://github.com/laoergege/laoergege-blog/blob/master/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191114223857.png?raw=true)
  - 多做真机测试!

## http 请求限制
从之前的事故，主要问题还是后台“重逻辑”计算导致的。但从前端角度来看，可以做到限制请求数量，减少无用请求，缓存请求结果，达到减轻后端服务压力。

- 并发数量限制
- 缓存请求结果（优先 1）
  - 本地级别 localStroge
  - 会话级别 sessionStroge
  - 页面级别
- 重复请求限制（优先 2，全局改造，作为可选功能提供？还是针对某些场景进行修改即可？）
- 无效请求限制

### 重复请求限制
普遍场景下，**一定时间内**，是不应该发生多次相同请求，而且重复请求是没有意义。比如以下场景：
- 按钮多次点击提交，相同请求，只需发送一次
- 连续输入搜索，不同请求，只需发最后一次

### 无效请求限制
浏览器地址从 /a 切换到 /b，页面a 触发的请求返回的结果都使用不到。 

### 实现方案

重复请求判读，从以下三维度
  - 请求地址
  - 请求方式
  - 请求参数

请求控制
- Service Worker
- 对原有封装 http 客户端进行改造




